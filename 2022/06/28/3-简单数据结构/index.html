

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Harrison">
  <meta name="keywords" content="">
  
    <meta name="description" content="简单数据结构1.线性表1.数组vectorSTL容器中的可变长度数组 123456789#include&lt;vector&gt;	&#x2F;&#x2F;头文件1.vector&lt;int&gt;v(N,i):建立一个可变长度数组v，内部元素类型为int；该可变数组最开始有N个元素，每个元素初始化为i。可以省略i(默认值为0)，也可以把(N,i)同时省略，此时这个数组的长度就是0.内部元素类型可以换成其他的类型">
<meta property="og:type" content="article">
<meta property="og:title" content="3.数据结构">
<meta property="og:url" content="http://kingsprite.github.io/2022/06/28/3-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Harrion">
<meta property="og:description" content="简单数据结构1.线性表1.数组vectorSTL容器中的可变长度数组 123456789#include&lt;vector&gt;	&#x2F;&#x2F;头文件1.vector&lt;int&gt;v(N,i):建立一个可变长度数组v，内部元素类型为int；该可变数组最开始有N个元素，每个元素初始化为i。可以省略i(默认值为0)，也可以把(N,i)同时省略，此时这个数组的长度就是0.内部元素类型可以换成其他的类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220306211405118.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220309214514238.png">
<meta property="og:image" content="c:/Users/Harrison/Desktop/Notebook/C++/深入浅出程序设计竞赛/表达式树.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220318171000453.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220320141800652.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220320163345154.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220320173241340.png">
<meta property="og:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220320221845913.png">
<meta property="article:published_time" content="2022-06-27T18:27:00.000Z">
<meta property="article:modified_time" content="2022-07-29T12:15:12.303Z">
<meta property="article:author" content="Harrison">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/Harrison/AppData/Roaming/Typora/typora-user-images/image-20220306211405118.png">
  
  
  
  <title>3.数据结构 - Harrion</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kingsprite.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GRMqsFtMvmUycsrBujRlpTHD-gzGzoHsz","app_key":"jt128fDRPNbUz7ARHmgATnPM","server_url":"https://grmqsftm.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Harrison</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="3.数据结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-28 02:27" pubdate>
          2022年6月28日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          353 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          可恶！计划已经被 <span id="leancloud-page-views"></span> 人发现了
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">3.数据结构</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="简单数据结构"><a href="#简单数据结构" class="headerlink" title="简单数据结构"></a>简单数据结构</h1><h3 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h3><h4 id="1-数组vector"><a href="#1-数组vector" class="headerlink" title="1.数组vector"></a>1.数组vector</h4><p>STL容器中的可变长度数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span>	<span class="hljs-comment">//头文件</span></span><br><span class="hljs-number">1.</span>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v</span>(N,i):<br>建立一个可变长度数组v，内部元素类型为<span class="hljs-type">int</span>；该可变数组最开始有N个元素，每个元素初始化为i。可以省略<span class="hljs-built_in">i</span>(默认值为<span class="hljs-number">0</span>)，也可以把(N,i)同时省略，此时这个数组的长度就是<span class="hljs-number">0.</span>内部元素类型可以换成其他的类型，如<span class="hljs-type">double</span>;<br><span class="hljs-number">2.</span>v.<span class="hljs-built_in">push_back</span>(a):<br>将元素a插入到数组v的末尾，并增加数组长度<br><span class="hljs-number">3.</span>v.<span class="hljs-built_in">size</span>():<br>返回数组v的长度<br><span class="hljs-number">4.</span>v.<span class="hljs-built_in">resize</span>(n,m):<br>重新调整数组大小为n，如果n比原来的小，则删除多余的信息；如果n比原来大，则新增的部分都初始化为m，其中m是可以省略的。<br></code></pre></td></tr></table></figure>

<p>头文件<vector></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>vector&lt;<span class="hljs-type">int</span>&gt;: :iterator it:<br>定义一个名字叫作it的迭代器<br><span class="hljs-number">2.</span>v.<span class="hljs-built_in">begin</span>():<br>返回数组v首元素(也就是v[<span class="hljs-number">0</span>])的指针(迭代器)<br><span class="hljs-number">3.</span>v.<span class="hljs-built_in">end</span>():<br>返回数组v最后元素末尾的下一个元素的指针(迭代器)。类似于空指针，不指向任何元素。<br><span class="hljs-number">4.</span>v.<span class="hljs-built_in">rbegin</span>():<br>返回数组v的最后一个元素的反向迭代器<br><span class="hljs-number">5.</span>v.<span class="hljs-built_in">rend</span>():<br>返回数组v的第一个元素之前的一个位置的反向迭代器<br></code></pre></td></tr></table></figure>

<p>除了使用数组下标，还能通过“迭代器”来访问数组中的元素。迭代器类似指针，这里的it可以认为是一个指向vector中的元素的指针。it可以++或者–变成前一个或后一个元素的指针，也能和指针一样用*it取该指针中的元素。</p>
<p>由于迭代器和指针在表现方式上很接近，所以v[i]和*(v.begin()+i)是一样的，都是取对应的元素的值。其他STL容器的迭代器也有类似的性质。在算法竞赛中经常只把vector当作普通的可变数组来使用，比较少用到迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;q;	<span class="hljs-comment">//寄包柜个数和询问次数</span><br>    vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;<span class="hljs-built_in">locker</span>(n+<span class="hljs-number">1</span>);	<span class="hljs-comment">//初始化，一共0到n号寄包柜</span><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        cin&gt;&gt;opt;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;		<span class="hljs-comment">//存包操作</span><br>            cin&gt;&gt;i&gt;&gt;j&gt;&gt;k;<br>            <span class="hljs-keyword">if</span>(locker[i].<span class="hljs-built_in">size</span>()&lt;j+<span class="hljs-number">1</span>)	<span class="hljs-comment">//如果这个寄包柜不够大</span><br>                locker[i].<span class="hljs-built_in">resize</span>(j+<span class="hljs-number">1</span>);	<span class="hljs-comment">//就扩大新的寄包柜，直到能装下</span><br>			locker[i][j]=k;<br>        &#125;	<span class="hljs-keyword">else</span> &#123;<br>            cin&gt;&gt;i&gt;&gt;j;<br>            cout&lt;&lt;locker[i][j]&lt;&lt;endl;	<span class="hljs-comment">//像数组一样输出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要定义由10个可变数组组成的一个二维数组，可以写成vector<int>v[10]。甚至可变数组还能够嵌套，定义一个二维都不定长的二维数组，就像vector&lt; vector<int> &gt;v (注意尖括号里的空格，以免会被认为是移位运算符而编译错误)。</p>
<p>数组作为数据结构可以高效地存储与查询给定索引(下标)的数据，其复杂度都是O(1)，因为这个性质，数组可以用来模拟其他很多数据结构。但是如果要将整个数组的一段数据进行移位操作(在中间插入、删除数据)或者搜索指定元素(如果没有排序)，则时间复杂度可达O(n)，效率很低。</p>
<p>数组的特点和局限性：</p>
<ul>
<li>存储查询给定索引（下标）的数据：效率很高，复杂度 O(1)</li>
<li>将整个数组的一段数据进行插入或删除操作，或者搜索指定元素（如果没有排序）：效率很低，时间复杂度 O(n)</li>
</ul>
<h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h4><p>栈是一种”后进先出(Last in First Out,LIFO)“的线性表，其限制是仅允许在表的一端进行插入和删除运算。</p>
<p>一个栈可以提供以下几个功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">将x压入栈</span><br><span class="hljs-function"><span class="hljs-number">2.</span>void pop():</span><br><span class="hljs-function">弹出栈顶的元素</span><br><span class="hljs-function"><span class="hljs-number">3.</span>int top():</span><br><span class="hljs-function">查询栈顶的元素</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数的实现：<br><span class="hljs-type">int</span> stack[MAXN];	<span class="hljs-comment">//开辟栈需要的数组空间，其中MAXN是栈的最大支持的大小</span><br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;			<span class="hljs-comment">//栈顶指针，指向下一个待插入的数组位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;	<span class="hljs-comment">//压栈，需要判断栈是否溢出</span><br>    <span class="hljs-keyword">if</span>(p&gt;=MAXN)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack overflow&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        stack[p]=x;p+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;	<span class="hljs-comment">//弹出栈顶元素，需要判断是否栈为空</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)<br>        	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack is empty&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        p-=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;	<span class="hljs-comment">//查询栈顶元素，需要判断是否栈为空</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack is empty&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> stack[p<span class="hljs-number">-1</span>];	<span class="hljs-comment">//注意按照定义方式，p-1才是栈顶</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>一般使用数组来存储栈的数据，同时需要一个栈顶指针记录栈顶的位置。这个栈的栈底是stack[0]，栈顶是stack[p-1]。查询栈元素的数量，可以直接查询p。为了保证不会出现非法操作(栈溢出或者空栈弹出)，需要在程序中加入判断栈是否溢出或者是否为空，如果保证程序运行过程中不会出现非法操作时，可以省略判断部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以使用STL提供的stack容器，但是如果使用STL时不打开-O2优化，会变慢。在非常需要追求运行速度的情况下，往往需要自己手写栈。<br>栈的头文件是&lt;stack&gt;<br><span class="hljs-number">1.</span>stack&lt;<span class="hljs-type">int</span>&gt;s:<br>建立一个栈s，其内部元素类型是<span class="hljs-type">int</span><br><span class="hljs-number">2.</span>s.<span class="hljs-built_in">push</span>(a):<br>将元素a压进栈s<br><span class="hljs-number">3.</span>s.<span class="hljs-built_in">pop</span>():<br>将s的栈顶元素弹出<br><span class="hljs-number">4.</span>s.<span class="hljs-built_in">top</span>():<br>查询s的栈顶元素<br><span class="hljs-number">5.</span>s.<span class="hljs-built_in">size</span>():<br>查询s的元素个数<br><span class="hljs-number">6.</span>s.<span class="hljs-built_in">empty</span>():<br>查询s是否为空<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">char</span>&gt; s;<br><span class="hljs-type">int</span> num;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;		<span class="hljs-comment">//根据后面的括号找到前面对应的括号</span><br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;num;<br>    string p;<br>    <span class="hljs-built_in">getline</span>(cin,p);		<span class="hljs-comment">//假装换行符</span><br>    <span class="hljs-keyword">while</span>(num--)&#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())s.<span class="hljs-built_in">pop</span>();	<span class="hljs-comment">//清除</span><br>        <span class="hljs-built_in">getline</span>(cin,p);	<span class="hljs-comment">//读入一行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())&#123;	<span class="hljs-comment">//如果栈为空，直接放入栈中</span><br>                s.<span class="hljs-built_in">push</span>(p[i]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">trans</span>(p[i])==s.<span class="hljs-built_in">top</span>())<br>                s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">push</span>(p[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>使用cin读入一个独占的数字后，其读入指针在这一行的末尾，如果再使用getline读入一行字符串是，只会读到空串(第一行)。如果希望读到第二行，则必须要假装读入这一行，可以使用getline，也可以使用getchar等。<br></code></pre></td></tr></table></figure>

<p>判断一个过程能否使用栈来模拟，需要看能否满足“后进先出”或者”先进后出“</p>
<h4 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h4><p>队列是一种“先进先出(First in First Out,FIFO)”的线性表，其限制是允许在表的一端进行删除运算，另外一端进行插入运算。</p>
<p>一个队列可以提供以下功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">将x压入队列</span><br><span class="hljs-function"><span class="hljs-number">2.</span>void pop():</span><br><span class="hljs-function">弹出队首的元素</span><br><span class="hljs-function"><span class="hljs-number">3.</span>int front()：</span><br><span class="hljs-function">查询队首的元素</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数的实现:<br><span class="hljs-type">int</span> queue[MAXN];<br><span class="hljs-type">int</span> head=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tail&gt;=MAXN)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue overflow&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        queue[tail]=x;tail+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==tail)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    <span class="hljs-keyword">else</span> head+=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==tail)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> queue[head];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>队列和栈的程序实现很类似。队列和栈不同的地方就是：栈只有一个端口出入；而队列是后端入，前端出，所以需要头尾两个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">和栈一样，同样可以使用STL来操作队列。<br>队列的头文件是&lt;queue&gt;<br><span class="hljs-number">1.</span>queue&lt;<span class="hljs-type">int</span>&gt;q:<br>建立一个队列q，其内部的元素类型是<span class="hljs-type">int</span><br><span class="hljs-number">2.</span>q.<span class="hljs-built_in">push</span>(a):<br>将元素a插入到队列q的末尾<br><span class="hljs-number">3.</span>q.<span class="hljs-built_in">pop</span>():<br>删除队列q的队首元素<br><span class="hljs-number">4.</span>q.<span class="hljs-built_in">front</span>():<br>查询q的队首元素<br><span class="hljs-number">5.</span>q.<span class="hljs-built_in">back</span>():<br>查询q的队尾元素<br><span class="hljs-number">6.</span>q.<span class="hljs-built_in">size</span>():<br>查询q的元素个数<br><span class="hljs-number">7.</span>q.<span class="hljs-built_in">empty</span>():<br>查询q是否为空<br></code></pre></td></tr></table></figure>

<p>如果数据有先进先出的性质，那么可以考虑使用队列；队列常常使用在各类广度优先搜索算法上。</p>
<h4 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h4><p>知道每个元素之前&#x2F;之后的元素，利用这种方式来存储元素排列顺序的表，成为链表。</p>
<p>插入链表：y插到x的后面：x后面变成了y，y后面变成了原本在x后面的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>    next[y]=next[x];<br>    next[x]=y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>删除元素：next[x]退出，相当于x后面的元素变成了next[x]后面的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    next[x]=next[next[x]];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每次插入，删除元素只需要修改两个Next的值，是O(1)的复杂度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">链表的种类：<br><span class="hljs-number">1.</span>单链表:每个结点记录自己的后继<br><span class="hljs-number">2.</span>双链表:每个结点记录自己的前驱和后继。与单链表只能往后走相比，好处是可以向前、向后走<br><span class="hljs-number">3.</span>循环单链表:本身是一个单链表，但最后一个结点的后继为第一个结点，从而连成了环形结构<br><span class="hljs-number">4.</span>循环双链表:本身是一个双链表，连成环形<br><span class="hljs-number">5.</span>块状链表:一种特殊的链表。基本思想是将若干元素压缩成一块，将这些块串联起来<br><span class="hljs-number">6.</span>跳表:相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">排队模拟，实现一个数据结构，维护一张表。<br><span class="hljs-number">1.</span><span class="hljs-built_in">ins_back</span>(x,y):<br>将元素y插入到x后面<br><span class="hljs-number">2.</span><span class="hljs-built_in">ins_front</span>(x,y):<br>将元素y插入到x前面<br><span class="hljs-number">3.</span><span class="hljs-built_in">ask_back</span>(x):<br>询问x后面的元素<br><span class="hljs-number">4.</span><span class="hljs-built_in">ans_front</span>(x):<br>询问x前面的元素<br><span class="hljs-number">5.</span><span class="hljs-built_in">del</span>(x):<br>从表中删除元素x，不改变其他元素的先后顺序<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以利用双向链表维护，通过以下函数实现:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> pre,nxt;	<span class="hljs-comment">//分别记录前驱和后继结点在数组s中的下标</span><br>    <span class="hljs-type">int</span> key;		<span class="hljs-comment">//结点的值</span><br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _key=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _pre=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _nxt=<span class="hljs-number">0</span>)	<span class="hljs-comment">//结构体初始化</span><br>    &#123;pre=_pre;nxt=_nxt;key=_key;&#125;<br>&#125;;<br><br>node s[<span class="hljs-number">1005</span>];<br><span class="hljs-comment">//一个池。以后想要新建一个结点，就从s数组里面拿出一个位置给新结点。也可以采用指针，用new、delete来动态分配空间。</span><br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//记录s数组目前使用了多少个位置，下一个可用的位置是s[tot+1];</span><br><span class="hljs-comment">//代码技巧:令s[1]恒为起点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;	<span class="hljs-comment">//查找x的结点编号，需要遍历整个链表</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(now &amp;&amp; s[now].key!=x)now=s[now].nxt;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;		<span class="hljs-comment">//y插在x的后面</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,now,s[now].nxt);	<span class="hljs-comment">//结点y的前驱是now,后驱是s[now].nxt</span><br>    s[s[now].nxt].pre=tot;				<span class="hljs-comment">//更新原先now的后继的pre值</span><br>    s[now].nxt=tot;						<span class="hljs-comment">//更新now的后继</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;	<span class="hljs-comment">//y插在x的前面</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,s[now].pre,now);	<span class="hljs-comment">//结点y的前驱是s[now].pre,后驱是now</span><br>    s[s[now].pre].nxt=tot;				<span class="hljs-comment">//更新原先now的前驱的nxt的值</span><br>    s[now].pre=tot;						<span class="hljs-comment">//更新now的前驱</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">return</span> s[s[now].nxt].key;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">return</span> s[s[now].pre].key;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> le=s[now].pre,rt=s[now].nxt;<br>    s[le].nxt=rt;<br>    s[rt].pre=le;<br>&#125;<br>以上代码实现了链表的各项基本操作，但是效率不高。因为每次操作时都要调用find函数以查找x所在的结点编号，这个过程的时间复杂度是<span class="hljs-built_in">O</span>(n)。改进方法:创建一个数组，用于存放每个数字对应的结点编号来代替find函数。如果数字的范围非常大，无法创建这么大的数组，也可以使用Hash算法或者map容器来记录结点编号。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++">队列安排:N个同学排成一列，同学被编号为<span class="hljs-number">1</span>~N:<br><span class="hljs-number">1.</span>先将<span class="hljs-number">1</span>号同学安排进队列，这时队列中只有他一个人。<br><span class="hljs-number">2.2</span>~N号同学依次入列，编号为i的同学的入列方式为:指定编号为i的同学站在编号为<span class="hljs-number">1</span>~i<span class="hljs-number">-1</span>中某位同学(即之前已经入列的同学)的左边或右边。<br><span class="hljs-number">3.</span>从队列中去掉<span class="hljs-built_in">M</span>(M&lt;N)同学，其他同学的位置顺序不变<br>在所有同学按照上述方法排队完毕后，老师想知道从左到右所有同学的编号。<br>分析:利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都是<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)的时间复杂度。可以使用链表模板，使用数组index定位某位同学的结点编号，在插入和删除时直接找到这位同学的结点编号，在插入时记录下这名同学的结点编号。这样就不需要每次都要遍历整个链表。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> pre,nxt,key;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _key=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _pre=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _nxt=<span class="hljs-number">0</span>)&#123;		<span class="hljs-comment">//结构体初始化</span><br>        pre=_pre;nxt=_nxt;key=_key;<br>    &#125;<br>&#125;;<br>node s[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> n,m,tot=<span class="hljs-number">0</span>,index[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;;				<span class="hljs-comment">//记录每个位置的结点编号</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];							<span class="hljs-comment">//查找索引</span><br>    s[++tot]=node&#123;y,now,s[now].nxt&#125;;<br>    s[s[now].nxt].pre=tot;<br>    s[now].nxt=tot;<br>    index[y]=tot;								<span class="hljs-comment">//记录索引</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,s[now].pre,now);<br>    s[s[now].pre].nxt=tot;<br>    s[now].pre=tot;<br>    index[y]=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];<br>    in le=s[now].pre,rt=s[now].nxt;<br>    s[le].nxt=rt;<br>    s[rt].pre=le;<br>    index[x]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x,k,p,now;<br>    cin&gt;&gt;n;<br>    s[<span class="hljs-number">0</span>]=<span class="hljs-built_in">node</span>();					<span class="hljs-comment">//代码技巧:令0恒为最左边的结点，有利于之后处理问题</span><br>    <span class="hljs-built_in">ins_back</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;k&gt;&gt;p;<br>        p?<span class="hljs-built_in">ins_back</span>(k,i):<span class="hljs-built_in">ins_front</span>(k,i);<br>    &#125;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(index[x])<span class="hljs-built_in">del</span>(x);<br>    &#125;<br>    now=s[<span class="hljs-number">0</span>].nxt;<br>    <span class="hljs-keyword">while</span>(now)&#123;<br>        cout&lt;&lt;s[now].key&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        now=s[now].nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">链表一样可以使用STL来简化操作，链表需要使用list的头文件<br><span class="hljs-number">1.l</span>ist&lt;<span class="hljs-type">int</span>&gt;a;<br>定义一个<span class="hljs-type">int</span>类型的链表a<br><span class="hljs-number">2.</span><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(arr,arr+<span class="hljs-number">3</span>);<br>从数组arr中的前<span class="hljs-number">3</span>个元素作为链表a得到初始值<br><span class="hljs-number">3.</span>a.<span class="hljs-built_in">size</span>():<br>返回链表的结点数量<br><span class="hljs-number">4.l</span>ist&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>定义一个名为it的迭代器(指针)<br><span class="hljs-number">5.</span>a.<span class="hljs-built_in">begin</span>();a.<span class="hljs-built_in">end</span>():<br>链表开始和末尾的迭代器指针<br><span class="hljs-number">6.</span>it++;it--;<br>迭代器指向前一个和后一个元素<br><span class="hljs-number">7.</span>a.<span class="hljs-built_in">push_front</span>(x);a.<span class="hljs-built_in">push_back</span>(x);<br>在链表开头或者末尾插入元素x<br><span class="hljs-number">8.</span>a.<span class="hljs-built_in">insert</span>(it,x);<br>在迭代器it的前插入元素x<br><span class="hljs-number">9.</span>a.<span class="hljs-built_in">pop_front</span>();a.<span class="hljs-built_in">pop_back</span>():<br>删除链表开头或者结尾<br><span class="hljs-number">10.</span>a.<span class="hljs-built_in">erase</span>(it):<br>删除迭代器it所在的元素<br><span class="hljs-number">11.f</span><span class="hljs-keyword">or</span>(it=a.<span class="hljs-built_in">begin</span>();it!=a.<span class="hljs-built_in">end</span>();it++):<br>遍历链表<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>list&lt;<span class="hljs-type">int</span>&gt;a;<br><span class="hljs-comment">//list&lt;int&gt;::iterator index[105];</span><br><span class="hljs-comment">//可以用于快速定位每个元素的位置，插入后用a.rbegin()可以记录最后一个元素的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,cnt=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a.<span class="hljs-built_in">push_back</span>(i);		<span class="hljs-comment">//将同学插入到链表中</span><br>    &#125;<br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it,now;<br>    it=a.<span class="hljs-built_in">begin</span>();			<span class="hljs-comment">//从头开始</span><br>    <span class="hljs-keyword">while</span>(!a.<span class="hljs-built_in">empty</span>())&#123;<br>        cnt++;<br>        now=it;				<span class="hljs-comment">//备份一个待删除元素的指针</span><br>        <span class="hljs-keyword">if</span>(++it==a.<span class="hljs-built_in">end</span>())<br>            	it=a.<span class="hljs-built_in">begin</span>();	<span class="hljs-comment">//遍历下一个，循环链表</span><br>        <span class="hljs-keyword">if</span>(cnt==m)&#123;				<span class="hljs-comment">//数到了m</span><br>            cout&lt;&lt;*now&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            a.<span class="hljs-built_in">erase</span>(now);		<span class="hljs-comment">//删除结点</span><br>            cnt=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>注意:遍历的时候如果要删除元素，一定要备份出来一个迭代器;否则it原来指向的结点删除后就不复存在，导致询问下一个结点时会访问无效内存。<br></code></pre></td></tr></table></figure>

<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>**数组（vector）：给定下标，直接根据下标定位 **</p>
<p><strong>栈（stack）：元素满足 后进先出 或者 先进后出，类似于洗盘子。</strong></p>
<p>应用：后缀表达式、匹配括号等</p>
<p><strong>队列（queue）：元素满足 先进先出 的性质，类似排队。</strong></p>
<p>应用：广度优先搜索、秒杀商品等 </p>
<p><strong>链表（list）：知道每个元素前面一个和后面一个；中间插入删除效率高</strong></p>
<h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h3><p>二叉树的性质:</p>
<ol>
<li><p>二叉树中，第 i 层最多有 2<sup>i</sup>-1个结点</p>
</li>
<li><p>如果二叉树的深度为k，那么此二叉树最多有2<sup>k</sup>-1个结点</p>
</li>
<li><p>二叉树中，终端结点数(叶子结点数)为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>个，则n<sub>0</sub>&#x3D;n<sub>2</sub>+1</p>
<p>证明:：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n<sub>1</sub>），那么总结点 n&#x3D;n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n&#x3D;B+1。而分枝数是可以通过 n<sub>1</sub> 和 n<sub>2</sub> 表示的，即 B&#x3D;n<sub>1</sub>+2<em>n<sub>2</sub>。所以，n 用另外一种方式表示为 n&#x3D;n<sub>1</sub>+2</em>n<sub>2</sub>+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</p>
</li>
</ol>
<h4 id="1-二叉树的概念和建立"><a href="#1-二叉树的概念和建立" class="headerlink" title="1.二叉树的概念和建立"></a>1.二叉树的概念和建立</h4><p>二叉树是一种特殊的树，每次分叉不超过两部分。二叉堆、平衡树、线段树都是以二叉树为基础。</p>
<p>二叉树要么为空，要么由根结点、左子树、右子树构成，而左右子树分别还是一棵二叉树。如果一个结点没有任何子树，就称为叶子结点。</p>
<p>如果一个二叉树的高度为h，从第二层开始每一层的结点数都是上一层的两倍，一共有1&lt;&lt;k-1个结点的二叉树称为完美二叉树。</p>
<p>对于i号非叶子结点，它的左子树编号为2<em>i,右子树编号为2</em>i+1。可以创建若干足够大的数组将各个结点的信息记录进去，通过计算编号来访问左右子树，并使用递归的方式得到各个子树的统计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> value[<span class="hljs-number">260</span>],winnner[<span class="hljs-number">260</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span>&lt;&lt;n)		<span class="hljs-comment">//如果是叶子结点就不用继续遍历下去</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>*x);	<span class="hljs-comment">//遍历左子树</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>);	<span class="hljs-comment">//遍历右子树</span><br>        <span class="hljs-type">int</span> lvalue=value[<span class="hljs-number">2</span>*x],rvalue=value[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(lvalue&gt;rvalue)&#123;	<span class="hljs-comment">//左节点获胜</span><br>            value[x]=lvalue;<span class="hljs-comment">//记录下获胜方的能力值</span><br>            winner[x]=winner[<span class="hljs-number">2</span>*x];	<span class="hljs-comment">//获胜方的编号</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">//右节点获胜</span><br>            value[x]=rvalue;<br>            winner[x]=winner[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>        cin&gt;&gt;value[i+(<span class="hljs-number">1</span>&lt;&lt;n)];		<span class="hljs-comment">//读入各个结点的能力值</span><br>        winner[i+(<span class="hljs-number">1</span>&lt;&lt;n)]=i+<span class="hljs-number">1</span>;		<span class="hljs-comment">//叶子结点的获胜方就是自己国家的编号</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);							<span class="hljs-comment">//从根结点开始遍历</span><br>    cout&lt;&lt;value[<span class="hljs-number">2</span>]&gt;value[<span class="hljs-number">3</span>]?winner[<span class="hljs-number">3</span>]:winner[<span class="hljs-number">2</span>];		<span class="hljs-comment">//找亚军</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>这是一个完美二叉树，<span class="hljs-number">1</span>到(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>都是非叶子结点，不小于(<span class="hljs-number">1</span>&lt;&lt;n)的都是叶子结点。使用value[i]来记录叶子结点的能力值，或者非叶子结点的该子树最大值;使用winner[i]来记录该子树的获胜者。当所有比赛模拟完毕，winner[<span class="hljs-number">1</span>]记录了整场比赛的冠军，value[i]记录了冠军的能力值。<br>    由于需要维护和子树相关的两个值--value和winner,所以建立了两个数组存储子树的信息。可以用STL中的pair容器让函数返回两个(多个)返回值。也可以将dfs函数定义为具有返回值的函数，然后在递归函数中处理这个值。<br></code></pre></td></tr></table></figure>

<p>如果一个结点除了最后一层以外，其他层结点都是满的，而且最后一层的结点时从左到右的一排连续的，那么这样的二叉树称其为完全二叉树。</p>
<p>二叉树的深度是指从根结点到叶子结点时，最多经历的层数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> left,right;<br>&#125;t[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;t[i].left,&amp;t[i].right);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!x)	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(t[x].left),<span class="hljs-built_in">dfs</span>(t[x].right))+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">build</span>();<br>    cout&lt;&lt;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2.二叉树的遍历"></a>2.二叉树的遍历</h4><p>二叉树的遍历是将一棵二叉树从根结点开始，按照指定顺序，不重复、不遗漏地访问每一个结点。</p>
<p><strong>二叉树层次遍历:</strong></p>
<p>遍历是指沿着某条搜索路径，依次对树中的每个节点均做一次且仅做一次访问。直接对二叉树进行广度优先搜索，将根结点放入初始队列中，取出每次出队的结点，即可得到层序遍历。</p>
<p><strong>二叉树的深度优先遍历:</strong></p>
<p>对于任意给定结点，可以访问该结点本身、遍历左子树、遍历右子树。根据在某个节点中遍历的顺序不同，有以下3种遍历方式。</p>
<ol>
<li>前序遍历:首先访问根结点，然后遍历左子树，最后遍历右子树。</li>
<li>中序遍历:首先遍历左子树，然后访问根结点，最后遍历右子树。</li>
<li>后序遍历:首先遍历左子树，然后遍历右子树，最后访问根结点。</li>
</ol>
<p>无论哪种遍历方式，本质上都是深度优先遍历，只是递归的顺序不同。虽然这3种遍历方式都是深度优先搜索，但是处理子树的顺序是不一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;		<span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">pre_order</span>(t[x].left);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">pre_order</span>(t[x].right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;		<span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">in_order</span>(t[x].left);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">in_order</span>(t[x].right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">post_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;		<span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">post_order</span>(t[x].left);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">post_order</span>(t[x].right);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220306211405118.png" srcset="/img/loading.gif" lazyload alt="image-20220306211405118"></p>
<p>如图中的树，得到的遍历结果如下:</p>
<ul>
<li>前序遍历：1	2	3	4	5	6	7</li>
<li>中序遍历：4 	3	5	2	6	1	7</li>
<li>后序遍历：4	5	3	6	2	7	1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//已知前序遍历和中序遍历求后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;	<span class="hljs-comment">//前序遍历的起点l1，终点r1;中序遍历的起点l2，终点r2;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l2;i&lt;=r2;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i]==a[l1])&#123;					<span class="hljs-comment">//找到当前树的根;</span><br>            <span class="hljs-built_in">build</span>(l1+<span class="hljs-number">1</span>,l1+i-l2,l2,i<span class="hljs-number">-1</span>);		<span class="hljs-comment">//</span><br>            <span class="hljs-built_in">build</span>(l1+i-l2+<span class="hljs-number">1</span>,r1,i+<span class="hljs-number">1</span>,r2);		<span class="hljs-comment">//</span><br>            cout&lt;&lt;a[l1]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-二叉树的综合应用"><a href="#3-二叉树的综合应用" class="headerlink" title="3.二叉树的综合应用"></a>3.二叉树的综合应用</h4><h6 id="例1-二叉搜索树-二叉查找树"><a href="#例1-二叉搜索树-二叉查找树" class="headerlink" title="例1.二叉搜索树(二叉查找树):"></a>例1.二叉搜索树(二叉查找树):</h6><p>需要写一种数据结构来维护一些数的集合，开始时集合是空的，需要提供以下操作:</p>
<ol>
<li>查询x数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，应输出最小的排名)</li>
<li>查询排名为x的数</li>
<li>求x的前驱(前驱定义为小于x，且最大的数)</li>
<li>求x的后继(后继定义为大于x，且最小的数)</li>
<li>插入一个数x</li>
</ol>
<p>二叉搜索树具有以下的性质:</p>
<ol>
<li>若结点x的左子树不空，则x左子树中所有结点的值均小于结点x的值</li>
<li>若结点x的右子树不空，则x右子树中所有结点的值均大于结点x的值</li>
<li>任意结点的左、右子树也分别是二叉搜索树</li>
<li>没有键值相等的结点</li>
</ol>
<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220309214514238.png" srcset="/img/loading.gif" lazyload alt="image-20220309214514238"></p>
<p>如上图所示为一棵二叉搜索树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以对每个结点定义<span class="hljs-number">5</span>个变量，用left表示左儿子，用right表示右儿子，用value表示该结点的权值，size表示以该结点为根结点的子树的结点个数，num表示该结点权值出现的次数。<br><span class="hljs-number">1.</span>查询x数的排名。每次将x和根结点root的权值比较。如果x小于根结点root的权值，那么root的右子树里面的所有权值都比x要大，所以递归下去查询左子树。如果x大于根结点root的权值，那么root的左子树里面的所有权值都比x要小，所以递归下去查询右子树，并且把左子树的大小加入到答案里面。如果x等于根结点root的权值，那么我们已经找到了x，返回答案即可<br><span class="hljs-number">2.</span>查询排名为x的数。当查询root子树中第x小的值时:如果x小于或等于root左子树的大小，则排名为x的数一定在root的左子树中，递归下去查询root的左子树中排名为x的数;如果x等于root左子树的大小+<span class="hljs-number">1</span>，由于左子树里面的权值都小于根结点root的权值，右子树里面的权值都大于根结点root的权值，所以排名为x的数一定是根结点root的权值，将其返回即可;如果x大于root左子树的大小+<span class="hljs-number">1</span>，则排名为x的数一定在root的右子树中，递归下去查询root的右子树中排名为x-左子树大小<span class="hljs-number">-1</span>的数<br><span class="hljs-number">3.</span>求x的前驱后继。可以先查询x的排名rank,然后查询排名为rank<span class="hljs-number">-1</span>的数与排名为rank+<span class="hljs-number">1</span>的数，这两个查询结果即分别为x的前驱和后继<br><span class="hljs-number">4.</span>插入一个数x。每次将x和根结点root的权值比较。如果x小于根结点root的权值，那么把x插入root的左儿子里面;如果x大于根结点root的权值，那么把x插入root的右儿子里面，这样操作之后这个二叉搜索树仍然保持了其性质。如果此时将x插入的那个位置的结点并不存在，比如要将x插入root的左子树中，但是root的左儿子是空的，则新建一个结点，权值为x，来替代那个不存在的结点，然后回溯的时候更新该结点的size值<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,root,cnt,opt,x;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> left,right,size,value,num;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> v)<br>        :<span class="hljs-built_in">left</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">right</span>(r),<span class="hljs-built_in">size</span>(s),<span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-comment">//	冒号后面赋值是C++的特性</span><br><span class="hljs-comment">//	相当于</span><br><span class="hljs-comment">//	Node(int l,int r,int s,int v)&#123;</span><br><span class="hljs-comment">//		left=l;</span><br><span class="hljs-comment">//		right=r;</span><br><span class="hljs-comment">//		size=s;</span><br><span class="hljs-comment">//		value=v;</span><br><span class="hljs-comment">//		num=1;</span><br><span class="hljs-comment">//	&#125;</span><br>    <span class="hljs-built_in">Node</span>()&#123;&#125;<br>&#125;t[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123;<br>    t[root].size=t[t[root].left].size+t[t[root].right].size+t[root].num;<br>    <span class="hljs-comment">//更新结点信息</span><br>&#125;<br><span class="hljs-comment">//inline内联函数，牺牲内存空间省去调用时间，提高速度，适合在函数代码较少时使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span></span>&#123;		<span class="hljs-comment">//查找数的排名</span><br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;t[root].value)		<span class="hljs-comment">//右子树所有数都比x小，故进入左子树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">rank</span>(x,t[root].left);<br>        <span class="hljs-keyword">if</span>(x&gt;t[root].value)<br>            <span class="hljs-comment">//左子树所有数都比x小，故进入右子树并且加上左子树的size</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">rank</span>(x,t[root].right)+t[t[root].left].size+t[root].num;<br>        <span class="hljs-keyword">return</span> t[t[root].left].size+t[root].num;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span></span>&#123;		<span class="hljs-comment">//查询排名为x的数</span><br>    <span class="hljs-keyword">if</span>(x&lt;=t[t[root].left].size)<br>        <span class="hljs-comment">//排名为x的数在左子树，故进入左子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x,t[root].left);<br>    <span class="hljs-keyword">if</span>(x&lt;=t[t[root].left].size+t[root].num)<br>        <span class="hljs-comment">//当前根结点就是排名为x的数，返回当前根结点的值</span><br>        <span class="hljs-keyword">return</span> t[root].value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x-t[t[root].left].size-t[root].num,t[root].right);<br>    <span class="hljs-comment">//排名为x的数在右子树，故进入右子树，并把x减去左子树size+t[root].num(根结点);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> &amp;root)</span></span>&#123;		<span class="hljs-comment">//插入值为x的数</span><br>    <span class="hljs-keyword">if</span>(x&lt;t[root].value)				<span class="hljs-comment">//插入到左子树中</span><br>        <span class="hljs-keyword">if</span>(!t[root].left)<br>            <span class="hljs-comment">//左儿子不存在，则新建一个权值为x的结点作为左儿子</span><br>            t[t[root].left=++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,x&#125;;<br>    	<span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">insert</span>(x,t[root].left);	<span class="hljs-comment">//左儿子存在，则递归插入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;t[root].value)		<span class="hljs-comment">//插入到右子树中</span><br>        <span class="hljs-keyword">if</span>(!t[root].right)<br>            <span class="hljs-comment">//右儿子不存在，则新建一个权值为x的结点作为右儿子</span><br>            t[t[root].right=++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,x&#125;;<br>    	<span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">insert</span>(x,t[root].right);<span class="hljs-comment">//右儿子存在，则递归插入</span><br>    <span class="hljs-keyword">else</span> t[root].num++;				<span class="hljs-comment">//x的结点已经存在，把结点大小+1</span><br>	<span class="hljs-built_in">update</span>(root);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    t[root==++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2147486847</span>&#125;;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;opt&gt;&gt;x;<br>        num++;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)	cout&lt;&lt;<span class="hljs-built_in">rank</span>(x,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>)	cout&lt;&lt;<span class="hljs-built_in">kth</span>(x,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">3</span>)	cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-built_in">rank</span>(x,root)<span class="hljs-number">-1</span>,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">4</span>)	cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-built_in">rank</span>(x,root)+<span class="hljs-number">1</span>,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> num--,<span class="hljs-built_in">insert</span>(x,root);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>当搜索树退化成一条链时，深度会达到<span class="hljs-built_in">O</span>(n)查询复杂度可能会退化到单词<span class="hljs-built_in">O</span>(n).<br>可以改良二叉搜索树，将其变成平衡二叉搜索树，简称平衡树。平衡树可以通过特有的平衡策略来保证其深度。<br></code></pre></td></tr></table></figure>

<h6 id="例2-表达式树"><a href="#例2-表达式树" class="headerlink" title="例2.表达式树"></a>例2.表达式树</h6><p>表达式树的叶结点是操作数，非叶子结点是操作符，假设所有的运算符都是双目运算符，那么表达式树就是一棵二叉树。可以通过递归计算左子树和右子树的值，得到根结点的值，从而可以得到整个表达式的值。</p>
<p><img src="C:\Users\Harrison\Desktop\Notebook\C++\深入浅出程序设计竞赛\表达式树.png" srcset="/img/loading.gif" lazyload alt="表达式树"></p>
<p>表达式树的性质:</p>
<p>表达式树的前序遍历也叫做这个表达式的前缀表达式，上图所示的前缀表达式即为++a*bc*de。</p>
<p>表达式树的中序遍历也叫做这个表达式的中缀表达式，上图所示的中缀表达式即为a+b*c+d*e。中序表达式是平常最常见的表达式。</p>
<p>表达式树的后序遍历也叫做这个表达式的后缀表达式，上图所示的后缀表达式即为abc*+de*+。后缀表达式是计算机最常用的表达式，因为便于计算机计算，使用线性表来计算后缀表达式。</p>
<h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h3><h6 id="集合：无序集"><a href="#集合：无序集" class="headerlink" title="集合：无序集"></a>集合：无序集</h6><p>集合，数学中默认指无序集，用于表达元素的聚合关系。两个元素只有属于同一个集合与不属于同一集合两种关系。</p>
<p>常见应用场景： </p>
<ul>
<li>两个元素是否属于同一个集合？</li>
<li>一个元素是否在集合中存在？</li>
</ul>
<p>常见实现方式：</p>
<ul>
<li>std::unordered_set、std::unordered_map</li>
<li>并查集、哈希表</li>
<li>启发式可并堆</li>
</ul>
<h6 id="集合：偏序集"><a href="#集合：偏序集" class="headerlink" title="集合：偏序集"></a>集合：偏序集</h6><p>在实际应用中，可能需要关心集合元素顺序。</p>
<p>集合上定义偏序关系（即≤号），可构成一个偏序集。有序性作为重要规律，可引入算法（如二分法）提升运行效率。</p>
<p>常见应用场景： </p>
<ul>
<li>某个元素在的前驱&#x2F;后继是什么？</li>
<li>插入&#x2F;删除若干元素，使集合仍然有序？</li>
<li>某个元素是第几名？第几名是哪个元素？</li>
</ul>
<p>常见实现方式：</p>
<ul>
<li>std::set、std::map</li>
<li>二叉排序树(平衡二叉树)</li>
</ul>
<h4 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1.并查集"></a>1.并查集</h4><p><strong>两个元素是否属于同一个集合？</strong></p>
<p>例：如果x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x和y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p>
<p>将家族视为集合，若两人是亲戚，等价两个元素属于同一集合。初始时，我们不知道任何人的亲属关系。可以认为每一个人单独属于一个集合，其代表为自己。每添加一组亲属关系，则等将于合并两者所属的集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">样例输入:										样例输出:<br><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>											Yes	<br><span class="hljs-number">1</span> <span class="hljs-number">2</span>												Yes<br><span class="hljs-number">1</span> <span class="hljs-number">5</span>												No<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">将家族视为集合，若两人是亲戚，等价两个元素属于同一集合。<br>初始时，我们不知道任何人的亲属关系。可以认为每一个人单独属于一个集合，其代表为自己。每添加一组亲属关系，则等将于合并两者所属的集合。<br>考察第一组亲属关系&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&gt;。将<span class="hljs-number">1</span>所属的集合&#123;<span class="hljs-number">1</span>&#125;与<span class="hljs-number">2</span>所属的集合&#123;<span class="hljs-number">2</span>&#125;合并为&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;。<br>此处，我们假定以左侧元素<span class="hljs-number">1</span>作为这个集合的代表。那么<span class="hljs-number">1</span>的代表仍是<span class="hljs-number">1</span>，<span class="hljs-number">2</span>的代表变为<span class="hljs-number">1</span>。<br>考察第四组亲属关系 &lt;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&gt;。查询<span class="hljs-number">25</span>的代表，发现代表均为<span class="hljs-number">1</span>，意味他们已属于同一个集合。因此，这一条关系并没有增加任何的信息，可以忽略。<br>考察第五组关系&lt;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&gt;。此时<span class="hljs-number">1</span>、<span class="hljs-number">3</span>属于不同的集合&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;和&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;，代表分别为<span class="hljs-number">1</span>、<span class="hljs-number">3</span>。我们设置<span class="hljs-number">3</span>的代表为<span class="hljs-number">1</span>。图中可以看到，代表关系具有传递性；<span class="hljs-number">4</span>的代表也随着<span class="hljs-number">3</span>变为了<span class="hljs-number">1</span>。这样一来，&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125; 也并入了集合 &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;<br><br>我们期望的结果是 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 均有亲属关系。但若直接修改 <span class="hljs-number">4</span> 的代表为 <span class="hljs-number">2</span>，则丢失<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 之间的关联。<br>代表关系具有传递性。我们不需要直接修改<span class="hljs-number">2</span>、<span class="hljs-number">4</span>的代表，而是修改<span class="hljs-number">2</span>和<span class="hljs-number">4</span>的代表的代表，那么<span class="hljs-number">2</span>、<span class="hljs-number">4</span>的关系也会改变，同时所属集合中其他所有元素也随代表被更改！<br>因此，先查找<span class="hljs-number">2</span>的代表为<span class="hljs-number">1</span>，<span class="hljs-number">4</span>的代表为<span class="hljs-number">3</span>。然后合并，将<span class="hljs-number">3</span>的代表设置为<span class="hljs-number">1</span>。此时，<span class="hljs-number">4</span>的代表也随着<span class="hljs-number">3</span>变成了<span class="hljs-number">1</span>。这样，集合的合并与查询就都实现了，“并查集”因此得名。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">实现时，用数组fa来存储“代表”，代表具有传递性。当查找代表时，需要向上递归，直至代表为自身<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==fa[x])	<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br>当合并两个元素时，需先判断两者是否属于同一集合。若否，则将其中一个集合的代表设置为另一方的代表。<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1,<span class="hljs-type">int</span> c2)</span></span>&#123;<br>    <span class="hljs-type">int</span> f1=<span class="hljs-built_in">find</span>(c1),f2=<span class="hljs-built_in">find</span>(c2);<span class="hljs-comment">//f1为c1的代表，f2为c2的代表</span><br>    <span class="hljs-keyword">if</span>(f1!=f2)	fa[f1]=f2;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    fa[i]=i;<br>&#125;<br><span class="hljs-comment">//合并亲属关系</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    <span class="hljs-built_in">join</span>(X,y);<br>&#125;<br><span class="hljs-comment">// 根据代表是否相同，查询亲属关系</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)&#123;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(X)==<span class="hljs-built_in">find</span>(y))<br>        cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化并查集</p>
<p>寻找代表的过程可能需要多次溯源。随着集合合并的深度增加，溯源的次数会越来越多，严重影响效率。</p>
<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220318171000453.png" srcset="/img/loading.gif" lazyload alt="image-20220318171000453"></p>
<p>两种优化方式：</p>
<ul>
<li>路径压缩(左图)</li>
</ul>
<p>在查询完成后，将路径每一个元素的fa值直接更新为代表，使得下一次递归时，只需要一步即可找到代表。</p>
<ul>
<li>启发式合并(右图)</li>
</ul>
<p>当合并两个集合时，选择较大的集合代表作为代表，即更改元素较少的集合的代表，可以减少路径压缩的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">经过优化后的并查集实现(可以用作模板)其查询的时间复杂度接近常数。<br><span class="hljs-comment">//初始化，每个元素单独属于一个集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        fa[i]=i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;	<span class="hljs-comment">// 查询集合的&quot;代表&quot;</span><br>    <span class="hljs-keyword">if</span>(f[x]==x)	<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);	<span class="hljs-comment">//路径压缩</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1,<span class="hljs-type">int</span> c2)</span></span>&#123;		<span class="hljs-comment">//合并两个集合</span><br>    <span class="hljs-comment">//f1为c1的代表，f2为c2的代表</span><br>    <span class="hljs-type">int</span> f1=<span class="hljs-built_in">find</span>(c1),f2=<span class="hljs-built_in">find</span>(c2);<br>    <span class="hljs-keyword">if</span>(f1!=f2)&#123;<br>        <span class="hljs-keyword">if</span>(size[f1]&lt;size[f2])	<span class="hljs-comment">//取较大者为代表</span><br>            <span class="hljs-built_in">swap</span>(f1,f2);<br>        <span class="hljs-comment">//f1元素多,f2元素少</span><br>        fa[f2]=f1;<br>        size[f1]+=size[f2];		<span class="hljs-comment">//将代表的size延长</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//路径压缩可以使查询时间复杂度降低至O(logn)，按秩合并优化(输的深度小的一方指向深度大的一方)，可以将查询复杂度优化到接近常数。</span><br></code></pre></td></tr></table></figure>

<p><strong>带路径长度的并查集</strong>：</p>
<p>并查集除了可以维护元素之间的聚类关系外，还可以维护距离。只需要额外添加一个距离记录项即可；路径压缩时动态更新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 查询集合的“代表”</span><br>	<span class="hljs-keyword">if</span> (x == fa[x])<span class="hljs-keyword">return</span> x;<br>	fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>	dist[x] += dist[fa[x]];<br>	<span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1, <span class="hljs-type">int</span> c2, <span class="hljs-type">int</span> d)</span> </span>&#123; <span class="hljs-comment">// 合并两个集合</span><br>	<span class="hljs-comment">// f1为c1的代表，f2为c2的代表</span><br>	<span class="hljs-type">int</span> f1 = <span class="hljs-built_in">find</span>(c1), f2 = <span class="hljs-built_in">find</span>(c2);<br>	<span class="hljs-keyword">if</span> (f1 != f2)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (size[f1] &lt; size[f2]) <span class="hljs-comment">// 取较大者作为代表</span><br>			<span class="hljs-built_in">swap</span>(f1, f2);<br>		fa[f2] = f1;<br>		dist[f2] = d;<br>		size[f1] += size[f2]; <span class="hljs-comment">// 只有“代表”的size是有效的</span><br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h4><p><strong>一个元素是否在集合中存在？</strong></p>
<p>字符串哈希：</p>
<p>给定N(N≤10000)个字符串（第i个字符串长度为M<sub>i</sub>(M<sub>i</sub>≤1500)，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">样例输入:										样例输出:<br><span class="hljs-number">5</span>												<span class="hljs-number">4</span><br>abc<br>aaaa<br>abc<br>abcc<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<p>任意两个字符串两两比较时间上必然是不可取的，时间只允许处理每一个字符串仅一次。</p>
<p>联想<strong>计数排序</strong>的思想，我们可以将每一个字符串装入一个投票箱， 使得相同的投票箱里只有同一类字符串。 </p>
<table>
<thead>
<tr>
<th>票箱#1</th>
<th>票箱#2</th>
<th>票箱#3</th>
<th>票箱#4</th>
<th>票箱#5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
</tbody></table>
<p>至于如何将字符串变为数字，就取决于Hash函数如何构造。 </p>
<p>先考虑一个简单的问题：</p>
<p>给定N个自然数，值域是 [0, 10<sup>18</sup>]，求出这 N 个自然数中共有多少个不同的自然数。</p>
<p>将整数映射到较小的整数，不难想到一个经典的运算：取模。</p>
<table>
<thead>
<tr>
<th>原数</th>
<th>1</th>
<th>14</th>
<th>514</th>
<th>1919810</th>
<th>1145141919810</th>
</tr>
</thead>
<tbody><tr>
<td>模11</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>2</td>
<td>9</td>
</tr>
</tbody></table>
<p>余与模的区别：<br>$$<br>余数由除法定义：r&#x3D;q-\left [\frac{a}{q} \right ] \times q所得，符号与被除数相同<br>\<br>模数由数轴划分：m&#x3D;q-k\left [\frac{a}{q} \right ]所得，符号永远为正<br>$$</p>
<table>
<thead>
<tr>
<th>a</th>
<th>-9</th>
<th>-8</th>
<th>-7</th>
<th>-6</th>
<th>-5</th>
<th>-4</th>
<th>-3</th>
<th>-2</th>
<th>-1</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>余</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
<td>0</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>模</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>**可以注意到余数在正负方向表现不一致。所以我们一般使用模数。 **</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 233333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,ans,a[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;x;<br>        x%=mod;<br>        <span class="hljs-keyword">if</span>(!a[x])	a[x]=<span class="hljs-number">1</span>,ans++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优势：有效地减少了空间的利用，只需要定义一个大小为mod的数组。</p>
<p>劣势：如果有两个不同的数恰好对mod取模之后得到了相同的结果，算法会认为这两个数是同一个数，产生了冲突。</p>
<p>把int数组改成一个vector&lt;int&gt;的数组或者一个链表，然后将取模后为同一个数的所有制都存在其对应的vector或者链表中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 233333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; linker[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;linker[x%mod].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(linker[x%mod][i]==x)<br>            <span class="hljs-keyword">return</span>;<br>        linker[x%mod].<span class="hljs-built_in">push_back</span>(x);<br>        ans++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例如，当需要存储的数字为1 2 3 4 5 6，模数为4时，这个vector数组就是这样的：模4为0的数只有4，模4为1的数有1和5，模4为2的数有2和6，模4为3的数只有3。当加入一个新的数233时，先算出233mod4&#x3D;1，然后遍历1的vector，发现没有233这个元素，于是答案++，然后将233这个元素push_back到1所对应的vector后面。这样的数据结构被称为哈希表或者Hash表。</p>
<p>原来的哈希表：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>插入数据后的哈希表：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">233</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如何将一个字符串当作一个数字？</p>
<p>用ASCII码将单个字符映射成一个数字，例如字符串abAB01可以映射成[97,98,65,66,48,49]。</p>
<p>把这串序列映射成0到mod-1中的一个数字，称为字符串的Hash值。转换的方式和k进制转换成十进制一样，不断地进行迭代运算hash&#x3D;(hash*k+s[i])%mod即可。</p>
<p>基数k可以任选，但一般来说不少于128(ASCII字符集的数量)。求Hash值方法不唯一，例如如果字符集局限于a到z的小写字母，也可以把每个字母映射为0到25，此时基数是26。</p>
<p>这里的模数mod会取一个比较大的质数以减少冲突的可能性，而且在空间足够的情况下越大越好，常见的模数有10007,999983等，可以根据实际情况选择合适的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">由于可能有多个不同字符串对应同一个Hash值，对每个Hash值建立一个<span class="hljs-built_in">vector</span>(或者链表)，用来存储对应于每个Hash值的所有字符串。这样每次只需要将这个插入的字符串和其Hash值相同的所有字符串比较，判断是否相等，就可以知道这个字符串有没有出现过了。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1510</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> base 261</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 23333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">char</span> s[MAXN];<br>vector&lt;string&gt;linker[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> hash=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>        hash=(hash*<span class="hljs-number">1ll</span>*base+s[i])%mod;	<span class="hljs-comment">//计算出字符串的Hash值</span><br>    &#125;<br>    string t=s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;linker[hash].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-comment">//遍历Hash值为当前字符串Hash值的Hash链表，以检查这个字符串是否已经存在</span><br>        <span class="hljs-keyword">if</span>(linker[hash][i]==t)<br>            <span class="hljs-keyword">return</span>;						<span class="hljs-comment">//如果找到了一个同样的字符串，那么新的这个字符串不计入答案</span><br>        linker[hash].<span class="hljs-built_in">push_back</span>(t);		<span class="hljs-comment">//否则把这个字符串计入答案</span><br>        ans++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;s,<span class="hljs-built_in">insert</span>();<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="哈希函数："><a href="#哈希函数：" class="headerlink" title="哈希函数："></a>哈希函数：</h6><p>理论表明，并不是任意选择 Hash 函数都能取得同样的效果。</p>
<ol>
<li><p>使用较大的质数作为模数</p>
<p>模数越大，空间越多，越难以冲突。</p>
<p>同时，由于质数除了1和自身外没有其他因子，包含乘除运算的 Hash 函数不会因为有公因子而导致不必要的 Hash 冲突。</p>
</li>
<li><p>使用复杂的 Hash 函数</p>
<p>直接取模是最简单的方式。</p>
<p>但复杂的 Hash 函数可使值域分布更均匀，降低冲突的可能。</p>
</li>
</ol>
<p><strong>Hash函数的输入应只与对象本身有关，而与随机数等任何外界环境无关。</strong></p>
<p>折叠之后，不同的数可能映射到同一个区域，这一现象称为 Hash 冲突。例如4，-1，9模5均为4</p>
<p>三种解决方法：</p>
<ol>
<li>使用稳健的 Hash 函数，效率最高，冲突率最高</li>
<li>使用十字链表，完全解决冲突，效率较低</li>
<li>使用 Multi-Hash，折中的方法</li>
</ol>
<h6 id="1-十字链表"><a href="#1-十字链表" class="headerlink" title="1.十字链表"></a>1.十字链表</h6><p>使用链表（或 std::vector 等结构）将 Hash 冲突的元素保存起来。这样，查找一个元素时只需要与 Hash 冲突的较少元素进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;hash[MAXN]<br><span class="hljs-comment">//以下是插入集合的方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(x)</span></span>&#123;<br>    <span class="hljs-type">int</span> h=<span class="hljs-built_in">f</span>(x);				<span class="hljs-comment">//计算哈希值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=hash[h].size;i&lt;sz;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x==hash[h][i])	<span class="hljs-comment">//从数组中找到了这一项</span><br>            <span class="hljs-keyword">return</span>;			<span class="hljs-comment">//什么都不做，直接退出</span><br>    hash[h].<span class="hljs-built_in">push_back</span>(x);	<span class="hljs-comment">//插入这个元素</span><br>    &#125;<br>&#125;<br>用这种方式可以完全解决 Hash 冲突问题。 但是查找元素的复杂度会有所上升（取决于 Hash 冲突的次数）。<br></code></pre></td></tr></table></figure>

<h6 id="2-Multi-Hash-多哈希"><a href="#2-Multi-Hash-多哈希" class="headerlink" title="2.Multi Hash(多哈希)"></a>2.Multi Hash(多哈希)</h6><p>将映射f调整为高维，例如同时使用两个模数</p>
<table>
<thead>
<tr>
<th>原数</th>
<th>1</th>
<th>14</th>
<th>514</th>
<th>114514</th>
<th>1145141919810</th>
</tr>
</thead>
<tbody><tr>
<td>模5</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>模7</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>0</td>
</tr>
</tbody></table>
<p>只有当多个Hash函数值同时相等才会导致Hash冲突。冲突概率大幅降低。 </p>
<p>注意Multi Hash对空间的开销较大，因为需要使用二维数组。</p>
<h6 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h6><p>字符在计算机中是以ASCII码（8位整数）的形式存储的。所以可进行整数运算，把字符串视作超长的256进制高精度整数。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>L</th>
<th>u</th>
<th>o</th>
<th>g</th>
<th>u</th>
<th>4</th>
<th>!</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>76</td>
<td>117</td>
<td>111</td>
<td>103</td>
<td>117</td>
<td>52</td>
<td>33</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">由于取模运算具有关于乘法的结合律和关于加法的分配率，可以构造出最简单的Hash函数：将字符串视作整数取模。<br>string s;<br><span class="hljs-type">int</span> hash=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>    <span class="hljs-comment">// 计算base进制下模mod的值作为hash值</span><br>    hash=((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)hash*base+s[i])%mod;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计算哈希函数的 base 和 mod 根据经验选取。 </p>
<ul>
<li>base 应当选择不小于字符集数的质数。例如，a-z 字符串为 26，任意 ASCII 字符串为 256。 </li>
<li>mod应该选取允许范围内尽可能大的质数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, ans;<br><span class="hljs-type">char</span> s[MAXN];<br>vector &lt;string&gt; linker[mod + <span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		cin &gt;&gt; s, <span class="hljs-built_in">insert</span>();<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> hash = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; i++)<br>		hash = (hash * <span class="hljs-number">1ll</span> * base + s[i]) % mod;<br>		<span class="hljs-comment">//计算出字符串的hash值</span><br>	string t = s;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; linker[hash].<span class="hljs-built_in">size</span>(); i++)<br>	<span class="hljs-comment">//遍历hash值为该字符串hash值的链表，检查字符串是否存在</span><br>		<span class="hljs-keyword">if</span> (linker[hash][i] == t)<br>			<span class="hljs-keyword">return</span>; <span class="hljs-comment">//如果找到同样的字符串，这个字符串不计答案</span><br>	linker[hash].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">//否则计入答案</span><br>	ans++;<br>&#125;<br>这里取 base=<span class="hljs-number">261</span>，mod=<span class="hljs-number">23333</span>。<br></code></pre></td></tr></table></figure>

<h4 id="3-STL中的集合"><a href="#3-STL中的集合" class="headerlink" title="3.STL中的集合"></a>3.STL中的集合</h4><p><strong>某个元素在偏序关系上的后继（或前驱）是什么？可以使用 STL 简化编程的过程吗？</strong></p>
<h6 id="STL中的集合与映射"><a href="#STL中的集合与映射" class="headerlink" title="STL中的集合与映射"></a>STL中的集合与映射</h6><p>STL中也有集合的实现，分为无序集和偏序集</p>
<p>其中分为集合(set)和映射(map)</p>
<ul>
<li><p>无序集在STL中是unordered_set和unordered_map</p>
<p>其本质为Hash表，因此增删改查均为O(1)，对于复杂数据类型，需要手动实现Hash函数</p>
</li>
<li><p>偏序集在STL中是set和map</p>
<p>本质为排序树，增删改查均为O(logn)，对于复杂数据类型，需要手动实现偏序关系，即&lt;运算符。</p>
</li>
</ul>
<p>集合在STL中有两种，分别是有序集合和无序集合</p>
<p>无序集合需要头文件<unordered_set></p>
<p>unordered_set的行为(无序)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;Type&gt; s;<span class="hljs-comment">//创建Type类型的集合</span><br><br>s.<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 插入元素x s.erase(x); // 删除值为x的元素</span><br>s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的元素</span><br>s.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>s.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查询x；不存在则返回s.end()</span><br>s.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回集合的大小</span><br></code></pre></td></tr></table></figure>

<p>有序集合需要头文件<set></p>
<p>set的行为(有序)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;Type&gt; s; <span class="hljs-comment">// 创建一个Type类型的集合</span><br>s.<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 插入元素x s.erase(x); // 删除值为x的元素</span><br>s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的元素</span><br>s.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>s.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查询x；不存在则返回s.end()</span><br>s.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回集合的大小</span><br>s.<span class="hljs-built_in">upper_bound</span>(x); <span class="hljs-comment">// 查询大于x的最小元素</span><br>s.<span class="hljs-built_in">lower_bound</span>(y); <span class="hljs-comment">// 查询不小于x的最小元素</span><br><span class="hljs-comment">// 使用方法与二分查找一章所介绍的一致</span><br>lower_bound会找出序列中第一个大于等于x的数<br><br>upper_bound会找出序列中第一个大于x的数<br></code></pre></td></tr></table></figure>

<p>功能上有序集与无序集类似，但有序集可以查找前驱后继。</p>
<p>映射在STL中也有两种，分别是有序映射和无序映射</p>
<p>有序映射需要头文件<unordered_map></p>
<p>unordered_map的行为(无序)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map &lt;T1, T2&gt; m; <span class="hljs-comment">// 创建T1到T2的映射</span><br><span class="hljs-comment">// 其中T1称为键key，T2称为值value</span><br><br>m.<span class="hljs-built_in">insert</span>(&#123;a,b&#125;);<span class="hljs-comment">// 创建映射a-&gt;b</span><br>m.<span class="hljs-built_in">erase</span>(a); <span class="hljs-comment">// 删除key为a的映射</span><br>m.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的映射</span><br>m.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>m.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 寻找键x；若不存在则返回m.end()</span><br>m.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>m.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回映射数目</span><br>m[a] = b; <span class="hljs-comment">// 修改a映射为b；若不存在则创建</span><br></code></pre></td></tr></table></figure>

<p>无序映射需要头文件<map></p>
<p>map的行为(有序)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;T1, T2&gt; m; <span class="hljs-comment">// 创建一个T1到T2的映射</span><br><span class="hljs-comment">// 其中T1称为键key，T2称为值value</span><br>m.<span class="hljs-built_in">insert</span>(&#123;a,b&#125;);<span class="hljs-comment">// 创建映射a-&gt;b</span><br>m.<span class="hljs-built_in">erase</span>(a); <span class="hljs-comment">// 删除key为a的映射</span><br>m.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的映射</span><br>m.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>m.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 寻找键x；若不存在则返回m.end()</span><br>m.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>m.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回映射数目</span><br>m[a] = b; <span class="hljs-comment">// 修改a映射为b；若不存在则创建</span><br>m.<span class="hljs-built_in">upper_bound</span>(x); <span class="hljs-comment">// 查询大于x的最小键</span><br>m.<span class="hljs-built_in">lower_bound</span>(x); <span class="hljs-comment">// 查询不小于x的最小键</span><br><span class="hljs-comment">// 使用方法与二分查找一章所介绍的一致</span><br></code></pre></td></tr></table></figure>

<h6 id="4-集合应用实例"><a href="#4-集合应用实例" class="headerlink" title="4.集合应用实例"></a>4.集合应用实例</h6><p>例1：木材仓库<br>仓库里面可存储各种长度的木材，但保证所有长度均不同。<br>作为仓库负责人，你有时候会进货，有时候会出货，因此需要维 护这个库存。有不超过 100000 条的操作：</p>
<ol>
<li>进货，格式 1 Length：在仓库中放入一根长度为 Length（不超7过 10<sup>9</sup>) 的木材。如果已有相同长度的木材输出Already Exist。</li>
<li>出货，格式 2 Length：从仓库中取出长度为 Length 的木材。若 无刚好长度的木材，取出在库的和要求长度最接近的木材。<br>如有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的输出Empty。</li>
</ol>
<p>分析：可以将这个问题抽象为：维护一个集合，可以插入一个元素x，同时判断x是否已经存在；查询x的前驱后继，x的前驱定义为小于x的最大的数，x的后继定义为大于x的最小的数；可以删除指定元素。</p>
<p>可以使用平衡树或Trie来维护集合，也可以通过调用STL里面的set解决问题，set的本质是红黑树（一种比较优秀的平衡二叉树）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">set集合需要头文件&lt;set&gt;<br><span class="hljs-number">1.</span>set&lt;<span class="hljs-type">int</span>&gt;ds:<br>建立一个名为ds的，元素类型为<span class="hljs-type">int</span>的集合<br><span class="hljs-number">2.</span>ds.<span class="hljs-built_in">insert</span>(x):<br>在集合中插入一个元素，如果这个元素已经存在，则没有操作<br><span class="hljs-number">3.</span>ds.<span class="hljs-built_in">erase</span>(x):<br>在集合中删除元素x，如果这个元素不存在，则没有操作<br><span class="hljs-number">4.</span>ds.<span class="hljs-built_in">erase</span>(it):<br>删除集合中地址为it的元素<br><span class="hljs-number">5.</span>ds.<span class="hljs-built_in">end</span>():<br>返回集合中最后一个元素的下一个元素的地址。很少直接使用，而是配合其他方法进行比较，以确定某个元素是否存在。<br><span class="hljs-number">6.</span>ds.<span class="hljs-built_in">find</span>(x):<br>查询x在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">7.</span>ds.<span class="hljs-built_in">lower_bound</span>(x):<br>查询不小于x的最小的数在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">8.</span>ds.<span class="hljs-built_in">upper_bound</span>(x):<br>查询大于x的最小的数在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">9.</span>ds.<span class="hljs-built_in">empty</span>():<br>如果集合是空的，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br><span class="hljs-number">10.</span>ds.<span class="hljs-built_in">size</span>():<br>返回集合中元素的个数<br></code></pre></td></tr></table></figure>

<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sas">进货操作可以直接在集合中用<span class="hljs-keyword">insert</span>(),查询操作用lower_bound()操作实现，出货删除操作用erase()实现。lower_bound给出的是仓库中大于或等于要求长度的最短木棍，所以还需要和比这根还短一点的木根比较一下，看看哪根木根离要求的木棍长度更接近。<br>#include&lt;iostream&gt;<br>#include&lt;<span class="hljs-keyword">set</span>&gt;<br>using namespace std;<br>int n,opt,<span class="hljs-keyword">length</span>;<br><span class="hljs-keyword">set</span>&lt;int&gt;ds;<br>int mai<span class="hljs-meta">n</span>()&#123;<br>	cin&gt;&gt;n;<br>	<span class="hljs-keyword">while</span>(n--)&#123;<br>		cin&gt;&gt;opt&gt;&gt;<span class="hljs-keyword">length</span>;<br>		<span class="hljs-keyword">if</span>(opt==1)&#123;<br>			<span class="hljs-keyword">if</span>(ds.find(<span class="hljs-keyword">length</span>)!=ds.<span class="hljs-keyword">end</span>())<br>				cout&lt;&lt;<span class="hljs-string">&quot;Already Exist&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">else</span> ds.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">length</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ds.empty())&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;Empty&quot;</span>&lt;&lt;endl;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">set</span>&lt;int&gt;::itreator i=ds.lower_bound(<span class="hljs-keyword">length</span>),j=i;<br>			<span class="hljs-keyword">if</span>(j!=ds.begi<span class="hljs-meta">n</span>())	--j;<br>			//如果j是ds.begi<span class="hljs-meta">n</span>()，则不能--<br>			<span class="hljs-keyword">if</span>(i!=ds.<span class="hljs-keyword">end</span>() <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-keyword">length</span>-(<span class="hljs-comment">*j)&gt;(*i)-length)	j=i;</span><br>			//如果i是ds.<span class="hljs-keyword">end</span>()，则不能对i解引用<br>			cout&lt;&lt;(<span class="hljs-comment">*j)&lt;&lt;endl,ds.erase(j);</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> 0;<br>&#125;<br>地址实际上对应元素的迭代器。lower_bound()返回的迭代器，可以对其++找到后继元素的迭代器，也可以--找到前驱元素的迭代器。需要注意指向元素的迭代器，如果已经是begi<span class="hljs-meta">n</span>()，则不能--，如果已经是<span class="hljs-keyword">end</span>().则不能++<br></code></pre></td></tr></table></figure>

<p>题意：维护一个集合，支持插入、删除最接近元素。</p>
<p>最接近，即前驱、自身(若存在)或后继，应当使用偏序集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">使用lower_bound即可找自身或后继；其prev即为所求前驱。<br>set &lt;<span class="hljs-type">int</span>&gt; ::iterator p, q;<br>q = s.<span class="hljs-built_in">lower_bound</span>(length);<br>p = <span class="hljs-built_in">prev</span>(q); <span class="hljs-comment">// 方法1 </span><br>p = q; p--; <span class="hljs-comment">// 方法2；本质等价</span><br>iterator 是指集合元素的迭代器<br><br>set &lt;<span class="hljs-type">int</span>&gt; ds;<br>set &lt;<span class="hljs-type">int</span>&gt; ::iterator i, j;<br>i = ds.<span class="hljs-built_in">lower_bound</span>(lenth);<br>j = i;<br><span class="hljs-keyword">if</span> (j != ds.<span class="hljs-built_in">begin</span>()) --j;<br><span class="hljs-comment">// 需注意如果j是ds.begin()的话是不能--的</span><br><span class="hljs-keyword">if</span> (i != ds.<span class="hljs-built_in">end</span>() &amp;&amp; lenth - (*j) &gt; (*i)-lenth) <br>    j = i;<br><span class="hljs-comment">//若i是end()则不能对i解引用</span><br>cout &lt;&lt; (* j) &lt;&lt; endl, ds.<span class="hljs-built_in">erase</span>(j);<br>j 为前驱地址，i 为本身/后继地址，选择二者中与 length 接近者。<br>如果 i 是 s.<span class="hljs-built_in">begin</span>()，则 <span class="hljs-built_in">prev</span>() 或 -- 会得到错误的值，需特判。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++">C++STL函数<br><span class="hljs-number">1.</span><span class="hljs-built_in">advance</span>()函数<br>advance函数移动的是源迭代器<br><span class="hljs-comment">//创建一个 vector 容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; myvector&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-comment">//it为随机访问迭代器，其指向 myvector 容器中第一个元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = myvector.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//输出 it 迭代器指向的数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;移动前的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><span class="hljs-comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span><br><span class="hljs-built_in">advance</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;移动后的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br>Output:<br>移动前的*it=<span class="hljs-number">1</span><br>移动后的*it=<span class="hljs-number">3</span><br>    <br><span class="hljs-built_in">advance</span>() 函数没有任何返回值，其移动的是 it 迭代器本身。<br>    <br><span class="hljs-number">2.</span><span class="hljs-built_in">prev</span>()函数<br>prev 原意为“上一个”，但 <span class="hljs-built_in">prev</span>() 的功能远比它的本意大得多，该函数可用来获取一个距离指定迭代器 n 个元素的迭代器。<br>其中，it 为源迭代器，其类型只能为双向迭代器或者随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 <span class="hljs-number">1</span>。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。<br>注意，当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。<br><br><span class="hljs-comment">//创建并初始化一个 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = mylist.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span><br><span class="hljs-keyword">auto</span> newit = <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;<br> <br><span class="hljs-comment">//n为负数，newit 位于 it 右侧</span><br>it = mylist.<span class="hljs-built_in">begin</span>();<br>newit = <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">-2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;<br><br>Output:<br><span class="hljs-built_in">prev</span>(it,<span class="hljs-number">2</span>)=<span class="hljs-number">4</span><br><span class="hljs-built_in">prev</span>(it,<span class="hljs-number">-2</span>)=<span class="hljs-number">3</span><br>    <br>当 it 指向 mylist 容器最后一个元素之后的位置时，通过 <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">2</span>) 可以获得一个新迭代器 newit，其指向的是距离 it 左侧 <span class="hljs-number">2</span> 个元素的位置（其存储的是元素 <span class="hljs-number">4</span>）；当 it 指向 mylist 容器中首个元素时，通过 <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">-2</span>) 可以获得一个指向距离 it 右侧 <span class="hljs-number">2</span> 个位置处的新迭代器。<br>注意，<span class="hljs-built_in">prev</span>() 函数自身不会检验新迭代器的指向是否合理，需要我们自己来保证其合理性。<br><br><span class="hljs-number">3.</span><span class="hljs-built_in">next</span>()函数<br>和 prev 相反，next 原意为“下一个”，但其功能和 <span class="hljs-built_in">prev</span>() 函数类似，即用来获取一个距离指定迭代器 n 个元素的迭代器。<br>其中 it 为源迭代器，其类似可以为前向迭代器、双向迭代器以及随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 <span class="hljs-number">1</span>。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。<br>需要注意的是，当 it 为前向迭代器时，n 只能为正数，该函数最终得到的新迭代器位于 it 右侧；当 it 为双向迭代器或者随机访问迭代器时，若 n 为正数，则得到的新迭代器位于 it 右侧，反之位于 it 左侧。<br><br><span class="hljs-comment">//创建并初始化一个 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = mylist.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 右侧</span><br><span class="hljs-keyword">auto</span> newit = <span class="hljs-built_in">next</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;next(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;<br> <br><span class="hljs-comment">//n为负数，newit 位于 it 左侧</span><br>it = mylist.<span class="hljs-built_in">end</span>();<br>newit = <span class="hljs-built_in">next</span>(it, <span class="hljs-number">-2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;next(it, -2) = &quot;</span> &lt;&lt; *newit;<br><br>Output:<br><span class="hljs-built_in">next</span>(it,<span class="hljs-number">2</span>)=<span class="hljs-number">3</span><br><span class="hljs-built_in">next</span>(it,<span class="hljs-number">-2</span>)=<span class="hljs-number">4</span><br><br>和 <span class="hljs-built_in">prev</span>() 函数恰好相反，当 n 值为 <span class="hljs-number">2</span> 时，<span class="hljs-built_in">next</span>(it, <span class="hljs-number">2</span>) 函数获得的新迭代器位于 it 迭代器的右侧，距离 <span class="hljs-number">2</span> 个元素；反之，当 n 值为 <span class="hljs-number">-2</span> 时，新迭代器位于 it 迭代器的左侧，距离 <span class="hljs-number">2</span> 个元素。<br>注意，和 <span class="hljs-built_in">prev</span>() 函数一样，<span class="hljs-built_in">next</span>() 函数自身也不会检查新迭代器指向的有效性，需要我们自己来保证。<br></code></pre></td></tr></table></figure>

<p>例2：学籍管理</p>
<p>设计一个学籍管理系统，最开始数据为空，支持如下操作：</p>
<ol>
<li><p>插入与修改，格式 1 NAME SCORE：</p>
<p>插入姓名为 NAME，分数为 SCORE 的学生。若已经有同名学生则更新他的成绩为 SCORE。如果成功插入或者修改输出OK。</p>
</li>
<li><p>查询，格式 2 NAME：在系统中查询姓名为 NAME 的学生的成绩。若未找到这名学生则输出 Not found，否则输出该生成绩。</p>
</li>
<li><p>删除，格式 3 NAME：在系统中删除姓名为 NAME 的学生信息。若未找到则输出Not found，否则输出 Deleted successfully。 </p>
</li>
<li><p>汇总，格式 4：输出系统中学生数量。</p>
</li>
</ol>
<p>分析：这样的学籍管理系统也是一个集合，但是功能更加复杂——需要根据索引找到对应的元素，并对这些元素进行操作。可以通过调用STL里面的map来解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">map关联集合的本质也是一棵红黑树，可以看作一个下标可以是任意类型的数组。其头文件是&lt;map&gt;，可以调用map实现如下几个基础功能。<br><span class="hljs-number">1.</span>map&lt;A,B&gt;ds:<br>建立一个名字为ds，下标类型为A，元素类型为B的映射表，例如map&lt;string,<span class="hljs-type">int</span>&gt;就是一个将string映射到<span class="hljs-type">int</span>的映射表<br><span class="hljs-number">2.</span>ds[A]=B:<br>把这个“数组”中下标为A的位置的值变成B<br>下标可以是任意类型。不一定限定为大于<span class="hljs-number">0</span>的整数，比如map&lt;string,string&gt;ds可以进行ds[<span class="hljs-string">&quot;steam&quot;</span>]=csgo的操作；<br><span class="hljs-number">3.</span>ds[A]:<br>访问这个“数组”中下标为A的元素，比如可以进行cout&lt;&lt;ds[<span class="hljs-string">&quot;steam&quot;</span>]&lt;&lt;endl;的操作<br><span class="hljs-number">4.</span>ds.<span class="hljs-built_in">end</span>():<br>返回映射表中最后一个元素的下一个元素的地址。很少直接使用，通常配合其他方法进行比较，以确定某个元素是否存在<br><span class="hljs-number">5.</span>ds.<span class="hljs-built_in">find</span>(x):<br>查询x在映射表中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">6.</span>ds.<span class="hljs-built_in">empty</span>():<br>如果映射表是空的，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br><span class="hljs-number">7.</span>ds.<span class="hljs-built_in">size</span>():<br>返回映射表中元素的个数<br><span class="hljs-number">8.</span>ds.<span class="hljs-built_in">erase</span>(A):<br>删除这个“数组”中下标为A的元素。<br>注意：在使用ds[A]访问“数组”下标为A的元素时，如果这个下标对应的元素不存在，则会自动创建下标为A，值为默认值(例如，所有数值类型的默认值都是<span class="hljs-number">0</span>，string字符串是空字符串)的元素。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,opt,num,ans;<br>string name;<br>map&lt;string,<span class="hljs-type">int</span>&gt; ds;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;opt;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<br>            cin&gt;&gt;name&gt;&gt;num;<br>            ds[name]=num;		<span class="hljs-comment">//对映射表name所对应的值修改为num</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<br>        &#125;	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>)&#123;<br>            cin&gt;&gt;name;<br>            <span class="hljs-keyword">if</span>(ds.<span class="hljs-built_in">find</span>(name)!=ds.<span class="hljs-built_in">end</span>())&#123;<br>                cout&lt;&lt;ds[name]&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Not found&quot;</span>&lt;&lt;endl;<br>        &#125;	<span class="hljs-keyword">else</span><br>            	cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要支持名字到分数的映射。使用 map；不需取前驱后继，也可用 unordered_map。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map &lt;string, <span class="hljs-type">int</span>&gt; ds;<br>string name;<br></code></pre></td></tr></table></figure>

<p>系统自带字符串 string 类型 Hash 函数，无需自定义 Hash。需求1-4 分别是 unordered_map 提供的 []、find、erase、size 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>	cin &gt;&gt; name &gt;&gt; num; ds[name] = num;<br>	cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;<br>	cin &gt;&gt; name;<br>	<span class="hljs-keyword">if</span> (ds.<span class="hljs-built_in">find</span>(name) != ds.<span class="hljs-built_in">end</span>())<br>		cout &lt;&lt; ds[name] &lt;&lt; endl;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) &#123;<br>	cin &gt;&gt; name;<br>	<span class="hljs-keyword">if</span> (ds.<span class="hljs-built_in">find</span>(name) != ds.<span class="hljs-built_in">end</span>()) &#123;<br>		ds.<span class="hljs-built_in">erase</span>(ds.<span class="hljs-built_in">find</span>(name));<br>		cout &lt;&lt; <span class="hljs-string">&quot;Deleted successfully&quot;</span> &lt;&lt; endl; <br>    &#125;<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span><br>	cout &lt;&lt; ds.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>在查找时如果直接用 m[a]，当 m[a] 不存在时，会自动创建为默认值（例如数值类型默认值是 <span class="hljs-number">0</span>），不能“判断是否存在”。<br>必须要先使用 m.<span class="hljs-built_in">find</span>(a) 确认不为 m.<span class="hljs-built_in">end</span>() 后，方能返回结果。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">本题中由于分数不为<span class="hljs-number">0</span>，可以直接用 <span class="hljs-keyword">if</span> (m[a]) 判断。此时由于<span class="hljs-number">0</span>项的存在，直接size是无法获得学生人数的，只能另开变量储存。<br>cin &gt;&gt; opt;<br><span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>	cin &gt;&gt; name &gt;&gt; num;<br>	<span class="hljs-keyword">if</span> (!ds[name]) ans++; <span class="hljs-comment">// ans是当前学生个数</span><br>		ds[name] = num; <span class="hljs-comment">// 这里对映射表name所对应的值修改为num</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span> &lt;&lt; endl; <br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;<br>		cin &gt;&gt; name;<br>		<span class="hljs-keyword">if</span> (ds[name]) cout &lt;&lt; ds[name] &lt;&lt; endl;<br>		<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) &#123;<br>		cin &gt;&gt; name;<br>		<span class="hljs-keyword">if</span> (ds[name]) &#123;<br>			ans--;ds[name] = <span class="hljs-number">0</span>;<br>			cout &lt;&lt; <span class="hljs-string">&quot;Deleted successfully&quot;</span> &lt;&lt; endl; <br>        &#125;<br>		<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span><br>	cout &lt;&lt; ans &lt;&lt; endl;<br>答案正确但不推荐<br></code></pre></td></tr></table></figure>

<p>例3：A-B数对，给出一个数列以及一个数字C，要求计算出所有A-B&#x3D;C的数对的个数。(不同位置的数字一样的数算不同的数对)。数字个数不超过200000，数列值域和C的值域不超过2<sup>32</sup>-1。</p>
<p>分析：可以使用map。枚举每一个数A，判断有多少个B满足A-B&#x3D;C，即有多少个B&#x3D;A-C。可以建立一个很大的数组，下标就是这些数字，这样直接就可以查询到这个数字是否存在。但是由于值域非常大，会造成内存超限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 200010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;ds;<br><span class="hljs-type">int</span> a[MAXN],n,c;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i],ds[a[i]]++;	<span class="hljs-comment">//把每个元素加入map中，如果原先不存在默认初始值为0</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ans+=ds[a[i]-c];		<span class="hljs-comment">//对于每个A，查询有多少B满足条件</span><br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="小贴士：关于STL"><a href="#小贴士：关于STL" class="headerlink" title="小贴士：关于STL"></a>小贴士：关于STL</h6><p>使用STL可以方便快捷地解决问题。</p>
<p><strong>在有需要的情况下，尽量优先使用STL！</strong></p>
<ol>
<li>STL经过验证，避免手写出错；</li>
<li>STL经过优化，一般性能更好； </li>
<li>STL使用方便，可以快速过题</li>
</ol>
<p><strong>不过STL的问题是：常数大所以慢！开启 O2 优化可提升。</strong></p>
<h4 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5.总结"></a>5.总结</h4><p><strong>并查集</strong></p>
<pre><code class="hljs">    解决集合的合并问题，判断两个元素是否在同一个集合中别忘了记得初始化 
</code></pre>
<p><strong>Hash（哈希）</strong></p>
<pre><code class="hljs">    将很大的数组或者字符串等元素，映射为较小整数

    哈希冲突的解决：设计哈希函数、多维模数、十字链表
</code></pre>
<p><strong>set &#x2F; map</strong></p>
<pre><code class="hljs">    维护偏序集，排序，快速查找前驱后继

    集合、映射之间的区别和关系
</code></pre>
<p><strong>unordered_set &#x2F; unordered_map</strong></p>
<pre><code class="hljs">    维护无序集，快速查找、修改元素
</code></pre>
<h3 id="4-图的基本应用"><a href="#4-图的基本应用" class="headerlink" title="4.图的基本应用"></a>4.图的基本应用</h3><h4 id="1-图的概念与建立"><a href="#1-图的概念与建立" class="headerlink" title="1.图的概念与建立"></a>1.图的概念与建立</h4><p>图的存储：</p>
<p>每个点都是顶点，每条直接连通的道路称作边，图是顶点和边构成的集合。顶点连边的数量就是顶点的度数。</p>
<p>每一条道路都可以双向通行的的图被称为无向图，道路是单向通行的被称为有向图。</p>
<p>无向图中，一个结点连边的条数称作这个结点的度数。</p>
<p>两个顶点中间有多条边称为重边，一条边的起点和终点一样称为自环，针对每一条边的属性值被称为边权，顶点的属性值称为点权。</p>
<p>右下图中每条道路只能单向通行，即边是单向的，被称为单向图。左下图则为无向图，可以双向通行。</p>
<p>对于有向图：</p>
<ul>
<li>一个结点向别的结点连边的条数称作这个结点的出度</li>
<li>别的结点连边到一个结点的条数称作这个结点的入度</li>
</ul>
<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320141800652.png" srcset="/img/loading.gif" lazyload alt="image-20220320141800652"></p>
<p>可以使用邻接矩阵存储一张图：记v[i][j]表示从i到j的边权也就是路线长度。如果不通可以设置成0或者inf(一个很大的数字)。</p>
<p>无向图的邻接矩阵右上和左下是对称的，有向图的邻接矩阵是不对称的。</p>
<p>也是就v[i][j]和v[j][i]是相同的。因为点i和点j双向连通，边权相等。如果忽略掉边权，只判断两点直接是否有边直接连接，那么可以把边权视为1，如果v[i][j]是0，说明点i和点j之间没有边直接连接。</p>
<p>对于有向图来说，邻接矩阵不一定对称。每一条从i到j的单向道路的数据都会被记录在v[i][j]。同理，如果v[i][j]是0，说明点i到点j没有直接连接的单向道路。</p>
<table>
<thead>
<tr>
<th align="center">i\j</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">i\j</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>对于一个n个点m条边的图，在使用邻接矩阵时，需要开一个n×n的数组，即空间复杂度O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        cin&gt;&gt;v[i][j]	<span class="hljs-comment">//存入每一对点之间的边权，读入邻接矩阵</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//找到与点i有直线连接的每一个点以及那条边的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(v[i][j]&gt;<span class="hljs-number">0</span>)<br>            cout&lt;&lt;<span class="hljs-string">&quot;edge from point&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;to point&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;with length&quot;</span>&lt;&lt;v[i][j]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br>如需要得到图上所有边，就需要遍历整个n×n数组，即遍历边时间复杂度<span class="hljs-built_in">O</span>(n²).<br></code></pre></td></tr></table></figure>

<p>对于一个有n个点m条边的图，在使用邻接矩阵时，虽然可以直接得到每两个点之间的边权，但是为了存储这些边权，需要开一个n×n数组，即有O(n²)的空间复杂度，如需要得到图上所有边，就需要遍历整个n×n数组，即遍历边时有O(n²)的时间复杂度。</p>
<p>优化：开一个二维数组p[i][j]，第一维i表示起点，第二维j表示i的第j条边，p[i][j]表示这条边的终点。</p>
<p>可采用 vector 代替二维数组，使用 vector 存储第二维，从而减少空间占用。这种做法被称为邻接表。</p>
<p>为了同时存储边的终点与边权，可以采用结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">邻接表的思想：只需要一个点能到达的顶点和相应边的边长的集合，为了存下这个集合，需要开一个二维数组，第一维i表示起点，第二维j表示是点i的第j条边。可以使用vector来实现，首先定义一个edge结构体，里面有两个变量to和cost，表示一条边的终点和边权。每当读入一条边&lt;u,v,l&gt;，用p[u].<span class="hljs-built_in">push_back</span>((edge)&#123;v,l&#125;)来表示为点u增加一条终点为v、边权为l的边。如果想知道点u有多少条边，可以使用p[u].<span class="hljs-built_in">size</span>()。如果想清楚点u的所有边，可以使用p[u].<span class="hljs-built_in">clear</span>()<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-comment">//记录边的终点，边权的结构体</span><br>    <span class="hljs-type">int</span> to,cost;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m;	<span class="hljs-comment">//图有n个点，m条边</span><br><br>vector&lt;edge&gt;p[MAXN];	<span class="hljs-comment">//邻接表</span><br><br><span class="hljs-type">int</span> v[MAXN][MAXN]		<span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,l;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;l;<br>        p[u].<span class="hljs-built_in">push_back</span>((edge)&#123;v,l&#125;);<br>      <span class="hljs-comment">//p[v].push_back((edge)&#123;u,l&#125;);</span><br>      <span class="hljs-comment">//无向图邻接表需要加一条反方向的边</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//遍历邻接表，把邻接表转换为邻接矩阵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].<span class="hljs-built_in">size</span>();j++)<br>         v[i][p[i][j].to]=p[i][j].cost;<br>&#125;<br><span class="hljs-comment">//输出邻接矩阵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        cout&lt;&lt;v[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>可以发现，对于每条边，只会被插入一个vector里面，且只插入一次，而总的边数是<span class="hljs-built_in">O</span>(m)的，总的空间复杂度是<span class="hljs-built_in">O</span>(m)，当m比n²小很多的时候，更具空间优势。但是，如果需要指定查询或修改边&lt;i,j&gt;的边权，因为并不知道这条边的具体存放位置，所以需要通过遍历以i为起点的所有边来找到这条边，需要的时间复杂度是<span class="hljs-built_in">O</span>(n)。在这一点上，邻接表的复杂度不如邻接矩阵的<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure>

<p>邻接表优点：总的空间复杂度是O(m)的，且遍历某个点相邻的节点的时间复杂度为O(p)，其中 p 为该点的出度。</p>
<p>邻接表缺点：如果需要指定查询或修改边&lt;i,j&gt;的边权，需要的时间复杂度是O(p)，不如邻接矩阵的O(1)。</p>
<p>邻接矩阵：适用于点较少（几百）、边较多（稠密图）的情况；</p>
<p>邻接表：适用于点较多(边数远没有达到点数的二次方)、或者可能出现重边的情况。 </p>
<h4 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2.图的遍历"></a>2.图的遍历</h4><p>为了不重复地遍历一个图，定义一个vis数组，表示每个结点是否被遍历过，在遍历时经过每个结点时，马上将这个结点的vis设为1，然后在经过每个结点之前，判断这个结点的vis是否为0，即没被访问过，如果vis不是0，则不再经过这个结点，这样就做到了不重复地遍历一张图。</p>
<h6 id="深度优先遍历："><a href="#深度优先遍历：" class="headerlink" title="深度优先遍历："></a>深度优先遍历：</h6><p>特点是优先遍历最先被发现的点，直到终点就退回去，需要使用栈维护遍历的层级(一般用递归来实现)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">bool</span> u[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;	<span class="hljs-comment">//此时输出遍历顺序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=p[x].<span class="hljs-built_in">size</span>();i&lt;sz;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">solve</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        p[x].<span class="hljs-built_in">push_back</span>(y);	<span class="hljs-comment">//用邻接表记录图</span><br>    &#125;<br>    u[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>   	<span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">solve</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="广度优先遍历："><a href="#广度优先遍历：" class="headerlink" title="广度优先遍历："></a>广度优先遍历：</h6><p>特点是优先遍历离原点距离更近的点。需要使用队列来维护待遍历的点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-type">bool</span> u[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        p[x].<span class="hljs-built_in">push_back</span>(y);<br>    &#125;<br>   	u[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=p[x].<span class="hljs-built_in">size</span>();i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>                u[p[x][i]]=<span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(p[x][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例：给出N个点，M条边的有向图，对于每个点v，求A(v)表示从点v出发，能到达的编号最大的点。<img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320163345154.png" srcset="/img/loading.gif" lazyload alt="image-20220320163345154"></p>
<table>
<thead>
<tr>
<th align="left">v</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A(v)</td>
<td align="center">7</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>思路：让最大的点去告诉哪些点能到达它，用反向边建图。</p>
<p>枚举点时从n枚举到1。然后从当前枚举的点u出发，让能遍历到的且没有被更新过的点v的A(v)&#x3D;u。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">solve</span>(p[x][i],v);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">solve</span>(i,i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析：如果想对每个点做一次深度优先遍历，对于一次遍历的复杂度是O(N+M)，所以总复杂度是O(N(N+M))</p>
<p>优化：在做深度优先遍历时，当需要求A(u)时，设A(u)为自己的点标号u，然后求出它能直接到达的点v的A(v)，然后让当前的A(u)与A(v)取最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;isotream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">solve</span>(p[x][i],v);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        p[v].<span class="hljs-built_in">push_back</span>(u);		<span class="hljs-comment">//反向建边</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">solve</span>(i,i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pass</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">pass</span>(p[x][i],v);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        p[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">pass</span>(i,i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-DAG与拓扑排序"><a href="#3-DAG与拓扑排序" class="headerlink" title="3.DAG与拓扑排序"></a>3.DAG与拓扑排序</h4><p>有向无环图：对于一张有向图，如果它没有环，则称为有向无环图，简称DAG。下图即为DAG.</p>
<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320173241340.png" srcset="/img/loading.gif" lazyload alt="image-20220320173241340"></p>
<p>例：有n项杂务要完成，完成第i项杂务需要一定的时间len[i].</p>
<p>有的杂务需要另一些杂务完成后才能做，互相没有关系的杂务可以同时进行。求出完成所有杂务的最短时间</p>
<p>思路：对每个任务用vis数组记下来完成这个任务所需要的最短时间，然后考虑在DFS的过程中算出完成每个任务所需要的最短时间，也就是每个结点的vis的取值。由于每个任务必须在所有准备任务完成后才能完成，所以完成每个任务所需要的最短时间就是其所有准备任务里面最晚完成的时间加上完成这个任务需要的时间，可以用DFS来实现，唯一的区别就是把vis数组的值从1改成完成的最短时间。</p>
<p>如果x是y的准备工作，那么在x和y之间连一条有向边。</p>
<p>对于每个任务，使用 vis 数组记下来完成这个任务所需要的最短时间，可以在 dfs 的过程中完成。</p>
<p>完成每个任务所需要的最短时间就是其所有准备任务里面最晚完成的时间加上完成这个任务需要的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">使用记忆化搜索，优化效率完成本题<br>实际上建图的时候，是后面的任务指向前面的任务，然后去溯源。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 10010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,y,t,ans,len[MAXN],vis[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt;linker[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">return</span> vis[x];	<span class="hljs-comment">//如果这个结点被访问过，返回访问这个结点的最短时间</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; linker[x].<span class="hljs-built_in">size</span>(); i++)<br>		vis[x] = <span class="hljs-built_in">max</span>(vis[x], <span class="hljs-built_in">dfs</span>(linker[x][i]));<br>    	<span class="hljs-comment">//找到所有连向这个结点的边里面距离最长的一个</span><br>	vis[x] += len[x];	<span class="hljs-comment">//加上这个结点的时间</span><br>	<span class="hljs-keyword">return</span> vis[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		cin &gt;&gt; x &gt;&gt; len[i];<br>		<span class="hljs-keyword">while</span> (cin &gt;&gt; y)<br>			<span class="hljs-keyword">if</span> (!y) <span class="hljs-keyword">break</span>; <br>    		<span class="hljs-keyword">else</span> linker[y].<span class="hljs-built_in">push_back</span>(x);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i));		<span class="hljs-comment">//对每个结点到达时间求max,得到答案</span><br>	cout&lt;&lt;ans&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>拓扑排序：对于 DAG，在有的时候，对于一个节点的信息的计算，需要确保与之相连的点的信息全部被计算。这时就需要用到拓扑排序。</p>
<p>本质是确保 DAG 上的点的计算顺序而非对数列排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">STEP <span class="hljs-number">1</span>：将入度为 <span class="hljs-number">0</span> 的点插入队列。<br>STEP <span class="hljs-number">2</span>：取出队头 x，遍历所有x能到达的点y。<br>STEP <span class="hljs-number">3</span>：对于每一个点 y，维护其节点信息，<br>同时使它入度 <span class="hljs-number">-1</span> 以完成删边操作。<br>STEP <span class="hljs-number">4</span>：当 y 入度为 <span class="hljs-number">0</span> 时，插入队列。<br>STEP <span class="hljs-number">5</span>：跳转到 STEP <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320221845913.png" srcset="/img/loading.gif" lazyload alt="image-20220320221845913"></p>
<p>例：<strong>最大食物链计数</strong></p>
<p>给你一个食物网，你要求出这个食物网中最大食物链的数量。对80112002 取模。不超过 5000 个点，500000 条边。（食物链开头是不会捕食其他生物的生产者，结尾是不会被其他生物捕食的消费者。）</p>
<p>图中食物网就是一个 DAG，五边形点入度为 0，八边形点出度为 0。</p>
<p>图中 1→3→7→9 是一条最大食物链；而 2→6, 3→7→9 和 1→3→7 都不是。</p>
<p>思路：食物网中的关系是单向且无环的，因而可以抽象为 DAG。</p>
<p>题意自然转化为从入度为 0 的点到出度为 0 的点的链的条数。</p>
<p>用 f[x] 表示从任意一个入度为 0 的点到点 x 的链的条数之和，那么对于任意一个入度为0的点y，它的f[y]&#x3D;1。对于一个入度非0的点z，则f[z] 为能到达 z 的所有点 u 的 f[u] 之和。</p>
<p>在计算f[x]的过程中，需要保证点x的所有能到达点x的点y的f[y]已经被计算过了，这样就需要确定一个合适的计算顺序。拓扑排序并不是对一个数列进行排序，而是在DAG上对点进行排序，使得在搜到点x时所有能到达点x的点y已经被搜过了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">流程如下：<br><span class="hljs-number">1.</span>将所有入度为<span class="hljs-number">0</span>的点加入处理队列<br><span class="hljs-number">2.</span>将处于队头的点x取出，遍历点x能到达的所有点y.<br><span class="hljs-number">3.</span>对于每一个y，删去从点x到点y的边。在具体的实现中，只需要让y的入度减<span class="hljs-number">1</span>即可。可以顺便对点y的数据进行维护，此题中是f[x]=(f[x]+f[y])%MOD.<br><span class="hljs-number">4.</span>如果点y的入度减到<span class="hljs-number">0</span>了，说明所有能到y的点都被计算过了，这时将点y加入处理队列。<br><span class="hljs-number">5.</span>重复步骤<span class="hljs-number">2</span>直到队列为空<br>这样就保证了食物链计数中求f[x]的顺序正确<br></code></pre></td></tr></table></figure>

<p>对于入度为 0 的点，f[x]&#x3D;1，满足需要确保与之相连的点的信息全部被计算。</p>
<p>使用拓扑排序。只需 STEP 3 中的维护， 变成 f[y] &#x3D; (f[x] + f[y]) % 80112002 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">最大食物链计数：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXM 500005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD 80112002</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,ans;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-type">int</span> f[MAXN],ind[MAXN],outd[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//预处理：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        outd[x]++; <span class="hljs-comment">// 点x的出度加1</span><br>        ind[y]++; <span class="hljs-comment">// 点y的入度加1</span><br>        p[x].<span class="hljs-built_in">push_back</span>(y);	<span class="hljs-comment">//用邻接表记录下食物链的关系</span><br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (ind[i] == <span class="hljs-number">0</span>) &#123; <br>            q.<span class="hljs-built_in">push</span>(i);	<span class="hljs-comment">//将入度为0的点加入队列</span><br>            f[i] = <span class="hljs-number">1</span>; <br>        &#125;<br>    <span class="hljs-comment">//拓扑排序：</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;p[x].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> y = p[x][i];<br>            f[y] = (f[x] + f[y]) % MOD;<br>            ind[y]--;<br>            <span class="hljs-keyword">if</span> (ind[y] == <span class="hljs-number">0</span>) 	<span class="hljs-comment">//此时点y已经没有入度，将点y加入队列</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>            &#125; <br>    &#125;<br>    <span class="hljs-comment">//答案统计：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (outd[i] == <span class="hljs-number">0</span>)<br>            ans = (ans + f[i]) % MOD;	<span class="hljs-comment">//在出度为0的点中统计答案</span><br>    cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>小提示：何处取模：</strong>本题，对于 f[x] 的计算，以及最后答案的统计，需要一边运算一边取模，防止运算的中途数据超过了数据类型从而答案错误。答案需要对80112002取模时，在计算f[x]时一边加一边取模，以及在出度为0的点的食物链计数求和时一边加一边取模。如果只在输出答案时取模，那么可能在累加的过程中答案就超出了数据类型存储的范围而导致答案的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">(a + b + c + d) % MOD = a % MOD + b % MOD + c % MOD + d % MOD;<br>(a * b * c * d) % MOD = a % MOD * b % MOD * c % MOD * d % MOD;<br></code></pre></td></tr></table></figure>

<h4 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h4><p><strong>图的定义</strong></p>
<pre><code class="hljs">    由顶点与边组成的集合。

    分类：有向图、无向图

    存储：邻接矩阵、邻接表
</code></pre>
<p><strong>图的遍历</strong></p>
<pre><code class="hljs">    深度优先遍历与广度优先遍历
</code></pre>
<p><strong>有向无环图</strong></p>
<pre><code class="hljs">    拓扑排序确保 DAG 上的点的计算顺序
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" class="category-chain-item">算法竞赛</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>3.数据结构</div>
      <div>http://kingsprite.github.io/2022/06/28/3-简单数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Harrison</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月28日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/29/html%E6%95%99%E7%A8%8B/" title="HTML教程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML教程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/09/2-%E5%88%9D%E6%B6%89%E7%AE%97%E6%B3%95/" title="2.初涉算法初">
                        <span class="hidden-mobile">2.初涉算法初</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"GRMqsFtMvmUycsrBujRlpTHD-gzGzoHsz","appKey":"jt128fDRPNbUz7ARHmgATnPM","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        计划已经被看过 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        有 
        <span id="leancloud-site-uv"></span>
         人发现计划了
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
