<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTML教程</title>
    <link href="/2022/07/29/html%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/29/html%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HTML简介"><a href="#1-HTML简介" class="headerlink" title="1.HTML简介"></a>1.HTML简介</h2><p>HTML(Hyper Text Markup Language)超文本标记语言</p><h4 id="1-web标准的构成"><a href="#1-web标准的构成" class="headerlink" title="1.web标准的构成"></a>1.web标准的构成</h4><p>结构html，表现css，行为javascript</p><h2 id="2-HTML标签"><a href="#2-HTML标签" class="headerlink" title="2.HTML标签"></a>2.HTML标签</h2><h4 id="1-HTML语法规范"><a href="#1-HTML语法规范" class="headerlink" title="1.HTML语法规范"></a>1.HTML语法规范</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">双标签<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br> 开始标签 结束标签<br>单标签<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>标签关系：包含关系和并列关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">包含关系：<br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">titel</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">titel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>并列关系：<br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-HTML基本结构标签"><a href="#2-HTML基本结构标签" class="headerlink" title="2.HTML基本结构标签"></a>2.HTML基本结构标签</h4><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>&lt;html&gt;&lt;&#x2F;html&gt;</td><td>HTML标签</td><td>页面中最大的标签，称为根标签</td></tr><tr><td>&lt;head&gt;&lt;&#x2F;head&gt;</td><td>文档的头部</td><td>注：head标签中必须设置的标签是title</td></tr><tr><td>&lt;title&gt;&lt;&#x2F;title&gt;</td><td>文档的标题</td><td>让网页拥有一个属于自己的网页标题</td></tr><tr><td>&lt;body&gt;&lt;&#x2F;body&gt;</td><td>文档的主体</td><td>元素包含文档的所有内容，页面内容都放在body中</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE&gt;</span>文档类型声明标签，不是HTML标签，属于文档声明标签<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&#x27;en&#x27;</span>&gt;</span>用来定义当前文档显示的语言<br>en英语，zh-CN中文<br>在<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>标签内，通过<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>&gt;</span>标签的charset属性规定HTML文档使用哪种字符编码<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>charset常用值：GB2312、BIG5、GBK、UTF-8，UTF-8称为万国码。<br></code></pre></td></tr></table></figure><h4 id="3-语义标签"><a href="#3-语义标签" class="headerlink" title="3.语义标签"></a>3.语义标签</h4><h5 id="1-标题标签"><a href="#1-标题标签" class="headerlink" title="1.标题标签"></a>1.标题标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">标题标签<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>标签语义：作为标题使用<br></code></pre></td></tr></table></figure><h5 id="2-段落和换行标签"><a href="#2-段落和换行标签" class="headerlink" title="2.段落和换行标签"></a>2.段落和换行标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用于定义段落<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是段落标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>标签语义：可以把HTML文档分割为若干段落<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>换行标签<br></code></pre></td></tr></table></figure><h5 id="3-文本格式化标签"><a href="#3-文本格式化标签" class="headerlink" title="3.文本格式化标签"></a>3.文本格式化标签</h5><p>标签语义：突出重要性</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td>&lt;strong&gt;&lt;&#x2F;strong&gt;或&lt;b&gt;&lt;&#x2F;b&gt;</td><td>更推荐使用&lt;strong&gt;标签，语义更强烈</td></tr><tr><td>倾斜</td><td>&lt;em&gt;&lt;&#x2F;em&gt;或&lt;i&gt;&lt;&#x2F;i&gt;</td><td>更推荐使用&lt;em&gt;标签，语义更强烈emphasize&#x2F;italic</td></tr><tr><td>删除线</td><td>&lt;del&gt;&lt;&#x2F;del&gt;或&lt;s&gt;&lt;&#x2F;s&gt;</td><td>更推荐使用&lt;del&gt;标签，语义更强烈delete</td></tr><tr><td>下划线</td><td>&lt;ins&gt;&lt;&#x2F;ins&gt;或&lt;u&gt;&lt;&#x2F;u&gt;</td><td>更推荐使用&lt;ins&gt;标签，语义更强烈inserted&#x2F;underline</td></tr></tbody></table><h5 id="4-div和span标签"><a href="#4-div和span标签" class="headerlink" title="4.div和span标签"></a>4.div和span标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>没有语义<br>div是division的缩写，表示分割、分区<br>span表示跨度、跨距<br>div标签独占一行<br>span标签一行可以放多个span标签<br></code></pre></td></tr></table></figure><h5 id="5-图像标签与路径"><a href="#5-图像标签与路径" class="headerlink" title="5.图像标签与路径"></a>5.图像标签与路径</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>标签用于定义HTML页面中的图像，为单标签<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像url&quot;</span>/&gt;</span><br>src为<span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>标签的必须属性，用于指定图像文件的路径和文件名<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>必须属性</td></tr><tr><td>alt</td><td>文本</td><td>替换文本，图像不能显示的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本，鼠标放到图像上显示的文字</td></tr><tr><td>width</td><td>像素</td><td>设置图像的宽度</td></tr><tr><td>height</td><td>像素</td><td>设置图像的高度</td></tr><tr><td>border</td><td>像素</td><td>设置图像的边框粗细</td></tr></tbody></table><p>属性采用键值对的格式，即key&#x3D;”value”，属性&#x3D;”属性值”</p><p>相对路径：</p><table><thead><tr><th>相对路径分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同一级路径</td><td>.&#x2F;</td><td>图像文件位于HTML文件同一级，如&lt;img src&#x3D;”img.jpg”&#x2F;&gt;</td></tr><tr><td>下一级路径</td><td>&#x2F;</td><td>图像文件位于HTML文件下一级，如&lt;img src&#x3D;”images&#x2F;img.jpg” &#x2F;&gt;</td></tr><tr><td>上一级路径</td><td>..&#x2F;</td><td>图像文件位于HTML文件上一级，如&lt;img src&#x3D;”..&#x2F;image.gif”&#x2F;&gt;</td></tr></tbody></table><h5 id="6-超链接标签"><a href="#6-超链接标签" class="headerlink" title="6.超链接标签"></a>6.超链接标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>标签用于定义超链接，作用是从一个页面链接到另一个页面<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>href用于指定链接目标的url地址，为必须属性，当标签应用href属性时，就具有了超链接的功能<br>target用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口的打开方式<br></code></pre></td></tr></table></figure><p>链接分类：</p><p>1.外部链接：<code>&lt;a href=&quot;www.baidu.com&quot;&gt;打开百度&lt;/a&gt;</code></p><p>2.内部链接：<code>&lt;a href=&quot;index.html&quot;&gt;打开内部链接&lt;/a&gt;</code></p><p>3.空链接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></p><p>4.下载链接：<code>&lt;a href=&quot;xxx.zip&quot;&gt;&lt;/a&gt;</code></p><p>5.网页元素链接：网页中元素添加超链接</p><p>6.锚点链接：在链接文本的href属性中设置属性值为<code>#名字</code>的格式，例如<code>&lt;a href=&quot;#名字&quot;&gt;&lt;/a&gt;</code></p><p>在目标位置标签中添加id属性&#x3D;名字，例如<code>&lt;h3 id=&quot;名字&quot;&gt;&lt;/h3&gt;</code></p><h5 id="7-注释标签"><a href="#7-注释标签" class="headerlink" title="7.注释标签"></a>7.注释标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">注释<span class="hljs-comment">&lt;!-- --&gt;</span><br></code></pre></td></tr></table></figure><p>特殊字符详情：<a href="https://tool.chinaz.com/Tools/HtmlChar.aspx">HTML特殊符号对照表 - 站长工具 (chinaz.com)</a></p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td></td><td>空格符</td><td><code>&amp;nbsp;</code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;amp;</code></td></tr><tr><td>￥</td><td>人民币</td><td><code>&amp;yen;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg;</code></td></tr><tr><td>°</td><td>摄氏度</td><td><code>&amp;deg;</code></td></tr><tr><td>±</td><td>正负号</td><td><code>&amp;plusmn;</code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times;</code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide;</code></td></tr><tr><td>²</td><td>平方2</td><td><code>&amp;sup2;</code></td></tr><tr><td>³</td><td>立方3</td><td><code>&amp;sup3;</code></td></tr></tbody></table><h5 id="8-表格标签"><a href="#8-表格标签" class="headerlink" title="8.表格标签"></a>8.表格标签</h5><p>表格主要用于显示、展示数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内的文字<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>用于定义表格的标签<br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>标签用于定义表格中的行，必须嵌套在<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>标签中<br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>用于定义表格中的单元格，必须嵌套在<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>标签中<br>字母td指(table data)，即数据单元格的内容<br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>标签表示HTML表格的表头部分(table head)会加粗并居中显示。<br></code></pre></td></tr></table></figure><p>表格的属性</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>left、center、right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td>border</td><td>1或””</td><td>规定表格单元是否拥有边框，默认为””，表示没有边框</td></tr><tr><td>cellpadding</td><td>像素值</td><td>规定单元边沿与其内容之间的空白，默认为1像素</td></tr><tr><td>cellspacing</td><td>像素值</td><td>规定单元格之间的空白，默认2像素</td></tr><tr><td>width</td><td>像素值或百分比</td><td>规定表格的宽度</td></tr></tbody></table><p>表格结构标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>标签表示表格的头部区域<br><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>标签表示表格的主体区域<br></code></pre></td></tr></table></figure><p>合并单元格：</p><p>合并单元格方式：跨行合并、跨列合并</p><p>跨行合并：rowspan&#x3D;”合并单元格的个数”，目标单元格为上</p><p>跨列合并：colspan&#x3D;”合并单元格的个数”，目标单元格为左（顺时针转动）</p><h5 id="9-列表标签"><a href="#9-列表标签" class="headerlink" title="9.列表标签"></a>9.列表标签</h5><p>列表用于布局，分为无序列表、有序列表、自定义列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">无序列表<br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>标签表示HTML页面中项目的无序列表，一般以项目符号呈现列表项，而列表使用<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>标签定义<br>无序列表语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>无序列表的各个列表项没有顺序级别，并列分布<br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>标签中只能嵌套<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>标签中可以存放其他元素<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">有序列表<br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>标签用于定义有序列表，列表排序以数字显示，使用<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>标签定义列表项<br>有序列表语法:<br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>标签中只能嵌套<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>标签中可以存放其他元素<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">自定义列表<br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span>标签用于定义描述列表、定义列表，与<span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>(定义项目、名字)和<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>(描述每一个项目、名字)一起使用<br>自定义列表语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span>中只能包含<span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>没有个数限制<br>dldefinition list<br>dtdefinition term<br>dddefinition describe<br></code></pre></td></tr></table></figure><h5 id="10-表单标签"><a href="#10-表单标签" class="headerlink" title="10.表单标签"></a>10.表单标签</h5><p>表单由表单域、表单控件（表单元素）和提示信息组成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">表单域<br>表单域是包含表单元素的区域<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>标签用于定义表单域，以实现用户信息的收集和传递，<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>会把表单元素信息提交给服务器<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;表单域名称&quot;</span>&gt;</span><br>    各种表单元素控件<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址</td></tr><tr><td>method</td><td>get&#x2F;post</td><td>用于设置表单数据的提交方式，其值为get&#x2F;post</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单的名称，区分同一个页面中的多个表单域</td></tr></tbody></table><p>表单控件（表单元素）</p><p>1.input输入表单元素</p><p>2.select下拉表单元素</p><p>3.textarea文本域元素</p><h6 id="1-input输入表单元素"><a href="#1-input输入表单元素" class="headerlink" title="1.input输入表单元素"></a>1.input输入表单元素</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>表单元素，用于收集用户信息<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>标签包含type属性，根据不同type值，输入字段有很多形式(文本、字段、复选框、掩码后的文本控件、单选按钮、按钮)<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;属性值&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>为单标签<br>type属性的不同属性值用来指定不同的控件类型<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下通过javascript启动脚本）</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义输入字段和”浏览”按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>password</td><td>定义密码字段，该字段中的字符被掩码</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本，默认宽度为20个字符</td></tr></tbody></table><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>由用户自定义</td><td>定义Input元素的名称</td></tr><tr><td>value</td><td>由用户自定义</td><td>规定input元素的值</td></tr><tr><td>placeholder</td><td>由用户自定义</td><td>提示input元素的值</td></tr><tr><td>checked</td><td>checked</td><td>规定此input元素首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字段中字符的最大长度</td></tr></tbody></table><p>name和value为每个表单元素都有的属性值，name为表单元素的名字，单选按钮和复选框要有相同的name值</p><p>checked属性主要针对于单选按钮和复选框，作用为默认选中某个表单元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>标签为input元素定义标注(标签)<br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>标签用于绑定表单元素，当点击<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>标签内文本时，浏览器会自动将光标转到或者选择对应的表单元素上，能够增加用户体验<br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>标签语法：<br>隐性：<br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--for对应id属性值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>标签的for属性应当与相关元素的id属性相同<br>显性：<br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="2-select下拉表单元素"><a href="#2-select下拉表单元素" class="headerlink" title="2.select下拉表单元素"></a>2.select下拉表单元素</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>标签用于定义下拉列表<br>语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>标签中应至少包含一对<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>在<span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>中定义selected=&quot;selected&quot;时，当前项即为默认选中项<br></code></pre></td></tr></table></figure><h6 id="3-textarea文本域元素"><a href="#3-textarea文本域元素" class="headerlink" title="3.textarea文本域元素"></a>3.textarea文本域元素</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>标签用于输入内容较多的文本框，定义多行文本输入<br>语法：<br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span><br>    文本内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br>cols=&quot;每行中的字符数&quot;，rows=&quot;显示的行数&quot;，实际开发中利用css来改变大小<br></code></pre></td></tr></table></figure><h2 id="3-查阅文档"><a href="#3-查阅文档" class="headerlink" title="3.查阅文档"></a>3.查阅文档</h2><h5 id="1-W3C"><a href="#1-W3C" class="headerlink" title="1.W3C"></a>1.W3C</h5><p><a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a></p><h5 id="2-MDN"><a href="#2-MDN" class="headerlink" title="2.MDN"></a>2.MDN</h5><p><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h2 id="00-易错点"><a href="#00-易错点" class="headerlink" title="00.易错点"></a>00.易错点</h2><h5 id="1-id、name、value的区别："><a href="#1-id、name、value的区别：" class="headerlink" title="1.id、name、value的区别："></a>1.id、name、value的区别：</h5><p>name可重复，id不可重复</p><p>id对任何元素都有效，name只对有name属性的元素有效</p><p>id一般在javascript中应用，value一般用于获取数据</p><p>name一般为控件名称，value为控件的值</p>]]></content>
    
    
    <categories>
      
      <category>学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.数据结构</title>
    <link href="/2022/06/28/3-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/28/3-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="简单数据结构"><a href="#简单数据结构" class="headerlink" title="简单数据结构"></a>简单数据结构</h1><h3 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h3><h4 id="1-数组vector"><a href="#1-数组vector" class="headerlink" title="1.数组vector"></a>1.数组vector</h4><p>STL容器中的可变长度数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span><span class="hljs-comment">//头文件</span></span><br><span class="hljs-number">1.</span>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v</span>(N,i):<br>建立一个可变长度数组v，内部元素类型为<span class="hljs-type">int</span>；该可变数组最开始有N个元素，每个元素初始化为i。可以省略<span class="hljs-built_in">i</span>(默认值为<span class="hljs-number">0</span>)，也可以把(N,i)同时省略，此时这个数组的长度就是<span class="hljs-number">0.</span>内部元素类型可以换成其他的类型，如<span class="hljs-type">double</span>;<br><span class="hljs-number">2.</span>v.<span class="hljs-built_in">push_back</span>(a):<br>将元素a插入到数组v的末尾，并增加数组长度<br><span class="hljs-number">3.</span>v.<span class="hljs-built_in">size</span>():<br>返回数组v的长度<br><span class="hljs-number">4.</span>v.<span class="hljs-built_in">resize</span>(n,m):<br>重新调整数组大小为n，如果n比原来的小，则删除多余的信息；如果n比原来大，则新增的部分都初始化为m，其中m是可以省略的。<br></code></pre></td></tr></table></figure><p>头文件<vector></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>vector&lt;<span class="hljs-type">int</span>&gt;: :iterator it:<br>定义一个名字叫作it的迭代器<br><span class="hljs-number">2.</span>v.<span class="hljs-built_in">begin</span>():<br>返回数组v首元素(也就是v[<span class="hljs-number">0</span>])的指针(迭代器)<br><span class="hljs-number">3.</span>v.<span class="hljs-built_in">end</span>():<br>返回数组v最后元素末尾的下一个元素的指针(迭代器)。类似于空指针，不指向任何元素。<br><span class="hljs-number">4.</span>v.<span class="hljs-built_in">rbegin</span>():<br>返回数组v的最后一个元素的反向迭代器<br><span class="hljs-number">5.</span>v.<span class="hljs-built_in">rend</span>():<br>返回数组v的第一个元素之前的一个位置的反向迭代器<br></code></pre></td></tr></table></figure><p>除了使用数组下标，还能通过“迭代器”来访问数组中的元素。迭代器类似指针，这里的it可以认为是一个指向vector中的元素的指针。it可以++或者–变成前一个或后一个元素的指针，也能和指针一样用*it取该指针中的元素。</p><p>由于迭代器和指针在表现方式上很接近，所以v[i]和*(v.begin()+i)是一样的，都是取对应的元素的值。其他STL容器的迭代器也有类似的性质。在算法竞赛中经常只把vector当作普通的可变数组来使用，比较少用到迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;q;<span class="hljs-comment">//寄包柜个数和询问次数</span><br>    vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;<span class="hljs-built_in">locker</span>(n+<span class="hljs-number">1</span>);<span class="hljs-comment">//初始化，一共0到n号寄包柜</span><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        cin&gt;&gt;opt;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//存包操作</span><br>            cin&gt;&gt;i&gt;&gt;j&gt;&gt;k;<br>            <span class="hljs-keyword">if</span>(locker[i].<span class="hljs-built_in">size</span>()&lt;j+<span class="hljs-number">1</span>)<span class="hljs-comment">//如果这个寄包柜不够大</span><br>                locker[i].<span class="hljs-built_in">resize</span>(j+<span class="hljs-number">1</span>);<span class="hljs-comment">//就扩大新的寄包柜，直到能装下</span><br>locker[i][j]=k;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            cin&gt;&gt;i&gt;&gt;j;<br>            cout&lt;&lt;locker[i][j]&lt;&lt;endl;<span class="hljs-comment">//像数组一样输出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要定义由10个可变数组组成的一个二维数组，可以写成vector<int>v[10]。甚至可变数组还能够嵌套，定义一个二维都不定长的二维数组，就像vector&lt; vector<int> &gt;v (注意尖括号里的空格，以免会被认为是移位运算符而编译错误)。</p><p>数组作为数据结构可以高效地存储与查询给定索引(下标)的数据，其复杂度都是O(1)，因为这个性质，数组可以用来模拟其他很多数据结构。但是如果要将整个数组的一段数据进行移位操作(在中间插入、删除数据)或者搜索指定元素(如果没有排序)，则时间复杂度可达O(n)，效率很低。</p><p>数组的特点和局限性：</p><ul><li>存储查询给定索引（下标）的数据：效率很高，复杂度 O(1)</li><li>将整个数组的一段数据进行插入或删除操作，或者搜索指定元素（如果没有排序）：效率很低，时间复杂度 O(n)</li></ul><h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h4><p>栈是一种”后进先出(Last in First Out,LIFO)“的线性表，其限制是仅允许在表的一端进行插入和删除运算。</p><p>一个栈可以提供以下几个功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">将x压入栈</span><br><span class="hljs-function"><span class="hljs-number">2.</span>void pop():</span><br><span class="hljs-function">弹出栈顶的元素</span><br><span class="hljs-function"><span class="hljs-number">3.</span>int top():</span><br><span class="hljs-function">查询栈顶的元素</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数的实现：<br><span class="hljs-type">int</span> stack[MAXN];<span class="hljs-comment">//开辟栈需要的数组空间，其中MAXN是栈的最大支持的大小</span><br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-comment">//栈顶指针，指向下一个待插入的数组位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//压栈，需要判断栈是否溢出</span><br>    <span class="hljs-keyword">if</span>(p&gt;=MAXN)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack overflow&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        stack[p]=x;p+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//弹出栈顶元素，需要判断是否栈为空</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack is empty&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        p-=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//查询栈顶元素，需要判断是否栈为空</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack is empty&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> stack[p<span class="hljs-number">-1</span>];<span class="hljs-comment">//注意按照定义方式，p-1才是栈顶</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般使用数组来存储栈的数据，同时需要一个栈顶指针记录栈顶的位置。这个栈的栈底是stack[0]，栈顶是stack[p-1]。查询栈元素的数量，可以直接查询p。为了保证不会出现非法操作(栈溢出或者空栈弹出)，需要在程序中加入判断栈是否溢出或者是否为空，如果保证程序运行过程中不会出现非法操作时，可以省略判断部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以使用STL提供的stack容器，但是如果使用STL时不打开-O2优化，会变慢。在非常需要追求运行速度的情况下，往往需要自己手写栈。<br>栈的头文件是&lt;stack&gt;<br><span class="hljs-number">1.</span>stack&lt;<span class="hljs-type">int</span>&gt;s:<br>建立一个栈s，其内部元素类型是<span class="hljs-type">int</span><br><span class="hljs-number">2.</span>s.<span class="hljs-built_in">push</span>(a):<br>将元素a压进栈s<br><span class="hljs-number">3.</span>s.<span class="hljs-built_in">pop</span>():<br>将s的栈顶元素弹出<br><span class="hljs-number">4.</span>s.<span class="hljs-built_in">top</span>():<br>查询s的栈顶元素<br><span class="hljs-number">5.</span>s.<span class="hljs-built_in">size</span>():<br>查询s的元素个数<br><span class="hljs-number">6.</span>s.<span class="hljs-built_in">empty</span>():<br>查询s是否为空<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">char</span>&gt; s;<br><span class="hljs-type">int</span> num;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;<span class="hljs-comment">//根据后面的括号找到前面对应的括号</span><br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;num;<br>    string p;<br>    <span class="hljs-built_in">getline</span>(cin,p);<span class="hljs-comment">//假装换行符</span><br>    <span class="hljs-keyword">while</span>(num--)&#123;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//清除</span><br>        <span class="hljs-built_in">getline</span>(cin,p);<span class="hljs-comment">//读入一行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//如果栈为空，直接放入栈中</span><br>                s.<span class="hljs-built_in">push</span>(p[i]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">trans</span>(p[i])==s.<span class="hljs-built_in">top</span>())<br>                s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">push</span>(p[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>使用cin读入一个独占的数字后，其读入指针在这一行的末尾，如果再使用getline读入一行字符串是，只会读到空串(第一行)。如果希望读到第二行，则必须要假装读入这一行，可以使用getline，也可以使用getchar等。<br></code></pre></td></tr></table></figure><p>判断一个过程能否使用栈来模拟，需要看能否满足“后进先出”或者”先进后出“</p><h4 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h4><p>队列是一种“先进先出(First in First Out,FIFO)”的线性表，其限制是允许在表的一端进行删除运算，另外一端进行插入运算。</p><p>一个队列可以提供以下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">将x压入队列</span><br><span class="hljs-function"><span class="hljs-number">2.</span>void pop():</span><br><span class="hljs-function">弹出队首的元素</span><br><span class="hljs-function"><span class="hljs-number">3.</span>int front()：</span><br><span class="hljs-function">查询队首的元素</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数的实现:<br><span class="hljs-type">int</span> queue[MAXN];<br><span class="hljs-type">int</span> head=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tail&gt;=MAXN)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue overflow&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        queue[tail]=x;tail+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==tail)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    <span class="hljs-keyword">else</span> head+=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==tail)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> queue[head];<br>&#125;<br></code></pre></td></tr></table></figure><p>队列和栈的程序实现很类似。队列和栈不同的地方就是：栈只有一个端口出入；而队列是后端入，前端出，所以需要头尾两个指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">和栈一样，同样可以使用STL来操作队列。<br>队列的头文件是&lt;queue&gt;<br><span class="hljs-number">1.</span>queue&lt;<span class="hljs-type">int</span>&gt;q:<br>建立一个队列q，其内部的元素类型是<span class="hljs-type">int</span><br><span class="hljs-number">2.</span>q.<span class="hljs-built_in">push</span>(a):<br>将元素a插入到队列q的末尾<br><span class="hljs-number">3.</span>q.<span class="hljs-built_in">pop</span>():<br>删除队列q的队首元素<br><span class="hljs-number">4.</span>q.<span class="hljs-built_in">front</span>():<br>查询q的队首元素<br><span class="hljs-number">5.</span>q.<span class="hljs-built_in">back</span>():<br>查询q的队尾元素<br><span class="hljs-number">6.</span>q.<span class="hljs-built_in">size</span>():<br>查询q的元素个数<br><span class="hljs-number">7.</span>q.<span class="hljs-built_in">empty</span>():<br>查询q是否为空<br></code></pre></td></tr></table></figure><p>如果数据有先进先出的性质，那么可以考虑使用队列；队列常常使用在各类广度优先搜索算法上。</p><h4 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h4><p>知道每个元素之前&#x2F;之后的元素，利用这种方式来存储元素排列顺序的表，成为链表。</p><p>插入链表：y插到x的后面：x后面变成了y，y后面变成了原本在x后面的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>    next[y]=next[x];<br>    next[x]=y;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除元素：next[x]退出，相当于x后面的元素变成了next[x]后面的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    next[x]=next[next[x]];<br>&#125;<br></code></pre></td></tr></table></figure><p>每次插入，删除元素只需要修改两个Next的值，是O(1)的复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">链表的种类：<br><span class="hljs-number">1.</span>单链表:每个结点记录自己的后继<br><span class="hljs-number">2.</span>双链表:每个结点记录自己的前驱和后继。与单链表只能往后走相比，好处是可以向前、向后走<br><span class="hljs-number">3.</span>循环单链表:本身是一个单链表，但最后一个结点的后继为第一个结点，从而连成了环形结构<br><span class="hljs-number">4.</span>循环双链表:本身是一个双链表，连成环形<br><span class="hljs-number">5.</span>块状链表:一种特殊的链表。基本思想是将若干元素压缩成一块，将这些块串联起来<br><span class="hljs-number">6.</span>跳表:相当于平衡树。每个结点拥有自己的右指针和下指针，通过分层的方式来加速查询，而每个元素的层数由概率决定<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">排队模拟，实现一个数据结构，维护一张表。<br><span class="hljs-number">1.</span><span class="hljs-built_in">ins_back</span>(x,y):<br>将元素y插入到x后面<br><span class="hljs-number">2.</span><span class="hljs-built_in">ins_front</span>(x,y):<br>将元素y插入到x前面<br><span class="hljs-number">3.</span><span class="hljs-built_in">ask_back</span>(x):<br>询问x后面的元素<br><span class="hljs-number">4.</span><span class="hljs-built_in">ans_front</span>(x):<br>询问x前面的元素<br><span class="hljs-number">5.</span><span class="hljs-built_in">del</span>(x):<br>从表中删除元素x，不改变其他元素的先后顺序<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以利用双向链表维护，通过以下函数实现:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> pre,nxt;<span class="hljs-comment">//分别记录前驱和后继结点在数组s中的下标</span><br>    <span class="hljs-type">int</span> key;<span class="hljs-comment">//结点的值</span><br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _key=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _pre=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _nxt=<span class="hljs-number">0</span>)<span class="hljs-comment">//结构体初始化</span><br>    &#123;pre=_pre;nxt=_nxt;key=_key;&#125;<br>&#125;;<br><br>node s[<span class="hljs-number">1005</span>];<br><span class="hljs-comment">//一个池。以后想要新建一个结点，就从s数组里面拿出一个位置给新结点。也可以采用指针，用new、delete来动态分配空间。</span><br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//记录s数组目前使用了多少个位置，下一个可用的位置是s[tot+1];</span><br><span class="hljs-comment">//代码技巧:令s[1]恒为起点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//查找x的结点编号，需要遍历整个链表</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(now &amp;&amp; s[now].key!=x)now=s[now].nxt;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//y插在x的后面</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,now,s[now].nxt);<span class="hljs-comment">//结点y的前驱是now,后驱是s[now].nxt</span><br>    s[s[now].nxt].pre=tot;<span class="hljs-comment">//更新原先now的后继的pre值</span><br>    s[now].nxt=tot;<span class="hljs-comment">//更新now的后继</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//y插在x的前面</span><br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,s[now].pre,now);<span class="hljs-comment">//结点y的前驱是s[now].pre,后驱是now</span><br>    s[s[now].pre].nxt=tot;<span class="hljs-comment">//更新原先now的前驱的nxt的值</span><br>    s[now].pre=tot;<span class="hljs-comment">//更新now的前驱</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">return</span> s[s[now].nxt].key;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">return</span> s[s[now].pre].key;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=<span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> le=s[now].pre,rt=s[now].nxt;<br>    s[le].nxt=rt;<br>    s[rt].pre=le;<br>&#125;<br>以上代码实现了链表的各项基本操作，但是效率不高。因为每次操作时都要调用find函数以查找x所在的结点编号，这个过程的时间复杂度是<span class="hljs-built_in">O</span>(n)。改进方法:创建一个数组，用于存放每个数字对应的结点编号来代替find函数。如果数字的范围非常大，无法创建这么大的数组，也可以使用Hash算法或者map容器来记录结点编号。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++">队列安排:N个同学排成一列，同学被编号为<span class="hljs-number">1</span>~N:<br><span class="hljs-number">1.</span>先将<span class="hljs-number">1</span>号同学安排进队列，这时队列中只有他一个人。<br><span class="hljs-number">2.2</span>~N号同学依次入列，编号为i的同学的入列方式为:指定编号为i的同学站在编号为<span class="hljs-number">1</span>~i<span class="hljs-number">-1</span>中某位同学(即之前已经入列的同学)的左边或右边。<br><span class="hljs-number">3.</span>从队列中去掉<span class="hljs-built_in">M</span>(M&lt;N)同学，其他同学的位置顺序不变<br>在所有同学按照上述方法排队完毕后，老师想知道从左到右所有同学的编号。<br>分析:利用一个双向链表维护这个队伍，每个同学记录自己左边和右边的同学。这样各种操作都是<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)的时间复杂度。可以使用链表模板，使用数组index定位某位同学的结点编号，在插入和删除时直接找到这位同学的结点编号，在插入时记录下这名同学的结点编号。这样就不需要每次都要遍历整个链表。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> pre,nxt,key;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> _key=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _pre=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _nxt=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//结构体初始化</span><br>        pre=_pre;nxt=_nxt;key=_key;<br>    &#125;<br>&#125;;<br>node s[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> n,m,tot=<span class="hljs-number">0</span>,index[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//记录每个位置的结点编号</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];<span class="hljs-comment">//查找索引</span><br>    s[++tot]=node&#123;y,now,s[now].nxt&#125;;<br>    s[s[now].nxt].pre=tot;<br>    s[now].nxt=tot;<br>    index[y]=tot;<span class="hljs-comment">//记录索引</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];<br>    s[++tot]=<span class="hljs-built_in">node</span>(y,s[now].pre,now);<br>    s[s[now].pre].nxt=tot;<br>    s[now].pre=tot;<br>    index[y]=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> now=index[x];<br>    in le=s[now].pre,rt=s[now].nxt;<br>    s[le].nxt=rt;<br>    s[rt].pre=le;<br>    index[x]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x,k,p,now;<br>    cin&gt;&gt;n;<br>    s[<span class="hljs-number">0</span>]=<span class="hljs-built_in">node</span>();<span class="hljs-comment">//代码技巧:令0恒为最左边的结点，有利于之后处理问题</span><br>    <span class="hljs-built_in">ins_back</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;k&gt;&gt;p;<br>        p?<span class="hljs-built_in">ins_back</span>(k,i):<span class="hljs-built_in">ins_front</span>(k,i);<br>    &#125;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(index[x])<span class="hljs-built_in">del</span>(x);<br>    &#125;<br>    now=s[<span class="hljs-number">0</span>].nxt;<br>    <span class="hljs-keyword">while</span>(now)&#123;<br>        cout&lt;&lt;s[now].key&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        now=s[now].nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">链表一样可以使用STL来简化操作，链表需要使用list的头文件<br><span class="hljs-number">1.l</span>ist&lt;<span class="hljs-type">int</span>&gt;a;<br>定义一个<span class="hljs-type">int</span>类型的链表a<br><span class="hljs-number">2.</span><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(arr,arr+<span class="hljs-number">3</span>);<br>从数组arr中的前<span class="hljs-number">3</span>个元素作为链表a得到初始值<br><span class="hljs-number">3.</span>a.<span class="hljs-built_in">size</span>():<br>返回链表的结点数量<br><span class="hljs-number">4.l</span>ist&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>定义一个名为it的迭代器(指针)<br><span class="hljs-number">5.</span>a.<span class="hljs-built_in">begin</span>();a.<span class="hljs-built_in">end</span>():<br>链表开始和末尾的迭代器指针<br><span class="hljs-number">6.</span>it++;it--;<br>迭代器指向前一个和后一个元素<br><span class="hljs-number">7.</span>a.<span class="hljs-built_in">push_front</span>(x);a.<span class="hljs-built_in">push_back</span>(x);<br>在链表开头或者末尾插入元素x<br><span class="hljs-number">8.</span>a.<span class="hljs-built_in">insert</span>(it,x);<br>在迭代器it的前插入元素x<br><span class="hljs-number">9.</span>a.<span class="hljs-built_in">pop_front</span>();a.<span class="hljs-built_in">pop_back</span>():<br>删除链表开头或者结尾<br><span class="hljs-number">10.</span>a.<span class="hljs-built_in">erase</span>(it):<br>删除迭代器it所在的元素<br><span class="hljs-number">11.f</span><span class="hljs-keyword">or</span>(it=a.<span class="hljs-built_in">begin</span>();it!=a.<span class="hljs-built_in">end</span>();it++):<br>遍历链表<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>list&lt;<span class="hljs-type">int</span>&gt;a;<br><span class="hljs-comment">//list&lt;int&gt;::iterator index[105];</span><br><span class="hljs-comment">//可以用于快速定位每个元素的位置，插入后用a.rbegin()可以记录最后一个元素的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,cnt=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//将同学插入到链表中</span><br>    &#125;<br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it,now;<br>    it=a.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//从头开始</span><br>    <span class="hljs-keyword">while</span>(!a.<span class="hljs-built_in">empty</span>())&#123;<br>        cnt++;<br>        now=it;<span class="hljs-comment">//备份一个待删除元素的指针</span><br>        <span class="hljs-keyword">if</span>(++it==a.<span class="hljs-built_in">end</span>())<br>            it=a.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//遍历下一个，循环链表</span><br>        <span class="hljs-keyword">if</span>(cnt==m)&#123;<span class="hljs-comment">//数到了m</span><br>            cout&lt;&lt;*now&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            a.<span class="hljs-built_in">erase</span>(now);<span class="hljs-comment">//删除结点</span><br>            cnt=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>注意:遍历的时候如果要删除元素，一定要备份出来一个迭代器;否则it原来指向的结点删除后就不复存在，导致询问下一个结点时会访问无效内存。<br></code></pre></td></tr></table></figure><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>**数组（vector）：给定下标，直接根据下标定位 **</p><p><strong>栈（stack）：元素满足 后进先出 或者 先进后出，类似于洗盘子。</strong></p><p>应用：后缀表达式、匹配括号等</p><p><strong>队列（queue）：元素满足 先进先出 的性质，类似排队。</strong></p><p>应用：广度优先搜索、秒杀商品等 </p><p><strong>链表（list）：知道每个元素前面一个和后面一个；中间插入删除效率高</strong></p><h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h3><p>二叉树的性质:</p><ol><li><p>二叉树中，第 i 层最多有 2<sup>i</sup>-1个结点</p></li><li><p>如果二叉树的深度为k，那么此二叉树最多有2<sup>k</sup>-1个结点</p></li><li><p>二叉树中，终端结点数(叶子结点数)为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>个，则n<sub>0</sub>&#x3D;n<sub>2</sub>+1</p><p>证明:：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n<sub>1</sub>），那么总结点 n&#x3D;n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n&#x3D;B+1。而分枝数是可以通过 n<sub>1</sub> 和 n<sub>2</sub> 表示的，即 B&#x3D;n<sub>1</sub>+2<em>n<sub>2</sub>。所以，n 用另外一种方式表示为 n&#x3D;n<sub>1</sub>+2</em>n<sub>2</sub>+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</p></li></ol><h4 id="1-二叉树的概念和建立"><a href="#1-二叉树的概念和建立" class="headerlink" title="1.二叉树的概念和建立"></a>1.二叉树的概念和建立</h4><p>二叉树是一种特殊的树，每次分叉不超过两部分。二叉堆、平衡树、线段树都是以二叉树为基础。</p><p>二叉树要么为空，要么由根结点、左子树、右子树构成，而左右子树分别还是一棵二叉树。如果一个结点没有任何子树，就称为叶子结点。</p><p>如果一个二叉树的高度为h，从第二层开始每一层的结点数都是上一层的两倍，一共有1&lt;&lt;k-1个结点的二叉树称为完美二叉树。</p><p>对于i号非叶子结点，它的左子树编号为2<em>i,右子树编号为2</em>i+1。可以创建若干足够大的数组将各个结点的信息记录进去，通过计算编号来访问左右子树，并使用递归的方式得到各个子树的统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> value[<span class="hljs-number">260</span>],winnner[<span class="hljs-number">260</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-comment">//如果是叶子结点就不用继续遍历下去</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>*x);<span class="hljs-comment">//遍历左子树</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>);<span class="hljs-comment">//遍历右子树</span><br>        <span class="hljs-type">int</span> lvalue=value[<span class="hljs-number">2</span>*x],rvalue=value[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(lvalue&gt;rvalue)&#123;<span class="hljs-comment">//左节点获胜</span><br>            value[x]=lvalue;<span class="hljs-comment">//记录下获胜方的能力值</span><br>            winner[x]=winner[<span class="hljs-number">2</span>*x];<span class="hljs-comment">//获胜方的编号</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//右节点获胜</span><br>            value[x]=rvalue;<br>            winner[x]=winner[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>        cin&gt;&gt;value[i+(<span class="hljs-number">1</span>&lt;&lt;n)];<span class="hljs-comment">//读入各个结点的能力值</span><br>        winner[i+(<span class="hljs-number">1</span>&lt;&lt;n)]=i+<span class="hljs-number">1</span>;<span class="hljs-comment">//叶子结点的获胜方就是自己国家的编号</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//从根结点开始遍历</span><br>    cout&lt;&lt;value[<span class="hljs-number">2</span>]&gt;value[<span class="hljs-number">3</span>]?winner[<span class="hljs-number">3</span>]:winner[<span class="hljs-number">2</span>];<span class="hljs-comment">//找亚军</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>这是一个完美二叉树，<span class="hljs-number">1</span>到(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>都是非叶子结点，不小于(<span class="hljs-number">1</span>&lt;&lt;n)的都是叶子结点。使用value[i]来记录叶子结点的能力值，或者非叶子结点的该子树最大值;使用winner[i]来记录该子树的获胜者。当所有比赛模拟完毕，winner[<span class="hljs-number">1</span>]记录了整场比赛的冠军，value[i]记录了冠军的能力值。<br>    由于需要维护和子树相关的两个值--value和winner,所以建立了两个数组存储子树的信息。可以用STL中的pair容器让函数返回两个(多个)返回值。也可以将dfs函数定义为具有返回值的函数，然后在递归函数中处理这个值。<br></code></pre></td></tr></table></figure><p>如果一个结点除了最后一层以外，其他层结点都是满的，而且最后一层的结点时从左到右的一排连续的，那么这样的二叉树称其为完全二叉树。</p><p>二叉树的深度是指从根结点到叶子结点时，最多经历的层数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> left,right;<br>&#125;t[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;t[i].left,&amp;t[i].right);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!x)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(t[x].left),<span class="hljs-built_in">dfs</span>(t[x].right))+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">build</span>();<br>    cout&lt;&lt;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2.二叉树的遍历"></a>2.二叉树的遍历</h4><p>二叉树的遍历是将一棵二叉树从根结点开始，按照指定顺序，不重复、不遗漏地访问每一个结点。</p><p><strong>二叉树层次遍历:</strong></p><p>遍历是指沿着某条搜索路径，依次对树中的每个节点均做一次且仅做一次访问。直接对二叉树进行广度优先搜索，将根结点放入初始队列中，取出每次出队的结点，即可得到层序遍历。</p><p><strong>二叉树的深度优先遍历:</strong></p><p>对于任意给定结点，可以访问该结点本身、遍历左子树、遍历右子树。根据在某个节点中遍历的顺序不同，有以下3种遍历方式。</p><ol><li>前序遍历:首先访问根结点，然后遍历左子树，最后遍历右子树。</li><li>中序遍历:首先遍历左子树，然后访问根结点，最后遍历右子树。</li><li>后序遍历:首先遍历左子树，然后遍历右子树，最后访问根结点。</li></ol><p>无论哪种遍历方式，本质上都是深度优先遍历，只是递归的顺序不同。虽然这3种遍历方式都是深度优先搜索，但是处理子树的顺序是不一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">pre_order</span>(t[x].left);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">pre_order</span>(t[x].right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">in_order</span>(t[x].left);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">in_order</span>(t[x].right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">post_order</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">if</span>(t[x].left)<span class="hljs-built_in">post_order</span>(t[x].left);<br>    <span class="hljs-keyword">if</span>(t[x].right)<span class="hljs-built_in">post_order</span>(t[x].right);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220306211405118.png" alt="image-20220306211405118"></p><p>如图中的树，得到的遍历结果如下:</p><ul><li>前序遍历：1234567</li><li>中序遍历：4 352617</li><li>后序遍历：4536271</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//已知前序遍历和中序遍历求后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulid</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<span class="hljs-comment">//前序遍历的起点l1，终点r1;中序遍历的起点l2，终点r2;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l2;i&lt;=r2;i++)&#123;<br>        <span class="hljs-keyword">if</span>(b[i]==a[l1])&#123;<span class="hljs-comment">//找到当前树的根;</span><br>            <span class="hljs-built_in">build</span>(l1+<span class="hljs-number">1</span>,l1+i-l2,l2,i<span class="hljs-number">-1</span>);<span class="hljs-comment">//</span><br>            <span class="hljs-built_in">build</span>(l1+i-l2+<span class="hljs-number">1</span>,r1,i+<span class="hljs-number">1</span>,r2);<span class="hljs-comment">//</span><br>            cout&lt;&lt;a[l1]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-二叉树的综合应用"><a href="#3-二叉树的综合应用" class="headerlink" title="3.二叉树的综合应用"></a>3.二叉树的综合应用</h4><h6 id="例1-二叉搜索树-二叉查找树"><a href="#例1-二叉搜索树-二叉查找树" class="headerlink" title="例1.二叉搜索树(二叉查找树):"></a>例1.二叉搜索树(二叉查找树):</h6><p>需要写一种数据结构来维护一些数的集合，开始时集合是空的，需要提供以下操作:</p><ol><li>查询x数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，应输出最小的排名)</li><li>查询排名为x的数</li><li>求x的前驱(前驱定义为小于x，且最大的数)</li><li>求x的后继(后继定义为大于x，且最小的数)</li><li>插入一个数x</li></ol><p>二叉搜索树具有以下的性质:</p><ol><li>若结点x的左子树不空，则x左子树中所有结点的值均小于结点x的值</li><li>若结点x的右子树不空，则x右子树中所有结点的值均大于结点x的值</li><li>任意结点的左、右子树也分别是二叉搜索树</li><li>没有键值相等的结点</li></ol><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220309214514238.png" alt="image-20220309214514238"></p><p>如上图所示为一棵二叉搜索树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">可以对每个结点定义<span class="hljs-number">5</span>个变量，用left表示左儿子，用right表示右儿子，用value表示该结点的权值，size表示以该结点为根结点的子树的结点个数，num表示该结点权值出现的次数。<br><span class="hljs-number">1.</span>查询x数的排名。每次将x和根结点root的权值比较。如果x小于根结点root的权值，那么root的右子树里面的所有权值都比x要大，所以递归下去查询左子树。如果x大于根结点root的权值，那么root的左子树里面的所有权值都比x要小，所以递归下去查询右子树，并且把左子树的大小加入到答案里面。如果x等于根结点root的权值，那么我们已经找到了x，返回答案即可<br><span class="hljs-number">2.</span>查询排名为x的数。当查询root子树中第x小的值时:如果x小于或等于root左子树的大小，则排名为x的数一定在root的左子树中，递归下去查询root的左子树中排名为x的数;如果x等于root左子树的大小+<span class="hljs-number">1</span>，由于左子树里面的权值都小于根结点root的权值，右子树里面的权值都大于根结点root的权值，所以排名为x的数一定是根结点root的权值，将其返回即可;如果x大于root左子树的大小+<span class="hljs-number">1</span>，则排名为x的数一定在root的右子树中，递归下去查询root的右子树中排名为x-左子树大小<span class="hljs-number">-1</span>的数<br><span class="hljs-number">3.</span>求x的前驱后继。可以先查询x的排名rank,然后查询排名为rank<span class="hljs-number">-1</span>的数与排名为rank+<span class="hljs-number">1</span>的数，这两个查询结果即分别为x的前驱和后继<br><span class="hljs-number">4.</span>插入一个数x。每次将x和根结点root的权值比较。如果x小于根结点root的权值，那么把x插入root的左儿子里面;如果x大于根结点root的权值，那么把x插入root的右儿子里面，这样操作之后这个二叉搜索树仍然保持了其性质。如果此时将x插入的那个位置的结点并不存在，比如要将x插入root的左子树中，但是root的左儿子是空的，则新建一个结点，权值为x，来替代那个不存在的结点，然后回溯的时候更新该结点的size值<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,root,cnt,opt,x;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> left,right,size,value,num;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> v)<br>        :<span class="hljs-built_in">left</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">right</span>(r),<span class="hljs-built_in">size</span>(s),<span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-comment">//冒号后面赋值是C++的特性</span><br><span class="hljs-comment">//相当于</span><br><span class="hljs-comment">//Node(int l,int r,int s,int v)&#123;</span><br><span class="hljs-comment">//left=l;</span><br><span class="hljs-comment">//right=r;</span><br><span class="hljs-comment">//size=s;</span><br><span class="hljs-comment">//value=v;</span><br><span class="hljs-comment">//num=1;</span><br><span class="hljs-comment">//&#125;</span><br>    <span class="hljs-built_in">Node</span>()&#123;&#125;<br>&#125;t[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123;<br>    t[root].size=t[t[root].left].size+t[t[root].right].size+t[root].num;<br>    <span class="hljs-comment">//更新结点信息</span><br>&#125;<br><span class="hljs-comment">//inline内联函数，牺牲内存空间省去调用时间，提高速度，适合在函数代码较少时使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span></span>&#123;<span class="hljs-comment">//查找数的排名</span><br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;t[root].value)<span class="hljs-comment">//右子树所有数都比x小，故进入左子树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">rank</span>(x,t[root].left);<br>        <span class="hljs-keyword">if</span>(x&gt;t[root].value)<br>            <span class="hljs-comment">//左子树所有数都比x小，故进入右子树并且加上左子树的size</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">rank</span>(x,t[root].right)+t[t[root].left].size+t[root].num;<br>        <span class="hljs-keyword">return</span> t[t[root].left].size+t[root].num;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span></span>&#123;<span class="hljs-comment">//查询排名为x的数</span><br>    <span class="hljs-keyword">if</span>(x&lt;=t[t[root].left].size)<br>        <span class="hljs-comment">//排名为x的数在左子树，故进入左子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x,t[root].left);<br>    <span class="hljs-keyword">if</span>(x&lt;=t[t[root].left].size+t[root].num)<br>        <span class="hljs-comment">//当前根结点就是排名为x的数，返回当前根结点的值</span><br>        <span class="hljs-keyword">return</span> t[root].value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(x-t[t[root].left].size-t[root].num,t[root].right);<br>    <span class="hljs-comment">//排名为x的数在右子树，故进入右子树，并把x减去左子树size+t[root].num(根结点);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> &amp;root)</span></span>&#123;<span class="hljs-comment">//插入值为x的数</span><br>    <span class="hljs-keyword">if</span>(x&lt;t[root].value)<span class="hljs-comment">//插入到左子树中</span><br>        <span class="hljs-keyword">if</span>(!t[root].left)<br>            <span class="hljs-comment">//左儿子不存在，则新建一个权值为x的结点作为左儿子</span><br>            t[t[root].left=++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,x&#125;;<br>    <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">insert</span>(x,t[root].left);<span class="hljs-comment">//左儿子存在，则递归插入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;t[root].value)<span class="hljs-comment">//插入到右子树中</span><br>        <span class="hljs-keyword">if</span>(!t[root].right)<br>            <span class="hljs-comment">//右儿子不存在，则新建一个权值为x的结点作为右儿子</span><br>            t[t[root].right=++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,x&#125;;<br>    <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">insert</span>(x,t[root].right);<span class="hljs-comment">//右儿子存在，则递归插入</span><br>    <span class="hljs-keyword">else</span> t[root].num++;<span class="hljs-comment">//x的结点已经存在，把结点大小+1</span><br><span class="hljs-built_in">update</span>(root);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    t[root==++cnt]=Node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2147486847</span>&#125;;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;opt&gt;&gt;x;<br>        num++;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)cout&lt;&lt;<span class="hljs-built_in">rank</span>(x,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-built_in">kth</span>(x,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">3</span>)cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-built_in">rank</span>(x,root)<span class="hljs-number">-1</span>,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">4</span>)cout&lt;&lt;<span class="hljs-built_in">kth</span>(<span class="hljs-built_in">rank</span>(x,root)+<span class="hljs-number">1</span>,root)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> num--,<span class="hljs-built_in">insert</span>(x,root);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>当搜索树退化成一条链时，深度会达到<span class="hljs-built_in">O</span>(n)查询复杂度可能会退化到单词<span class="hljs-built_in">O</span>(n).<br>可以改良二叉搜索树，将其变成平衡二叉搜索树，简称平衡树。平衡树可以通过特有的平衡策略来保证其深度。<br></code></pre></td></tr></table></figure><h6 id="例2-表达式树"><a href="#例2-表达式树" class="headerlink" title="例2.表达式树"></a>例2.表达式树</h6><p>表达式树的叶结点是操作数，非叶子结点是操作符，假设所有的运算符都是双目运算符，那么表达式树就是一棵二叉树。可以通过递归计算左子树和右子树的值，得到根结点的值，从而可以得到整个表达式的值。</p><p><img src="C:\Users\Harrison\Desktop\Notebook\C++\深入浅出程序设计竞赛\表达式树.png" alt="表达式树"></p><p>表达式树的性质:</p><p>表达式树的前序遍历也叫做这个表达式的前缀表达式，上图所示的前缀表达式即为++a*bc*de。</p><p>表达式树的中序遍历也叫做这个表达式的中缀表达式，上图所示的中缀表达式即为a+b*c+d*e。中序表达式是平常最常见的表达式。</p><p>表达式树的后序遍历也叫做这个表达式的后缀表达式，上图所示的后缀表达式即为abc*+de*+。后缀表达式是计算机最常用的表达式，因为便于计算机计算，使用线性表来计算后缀表达式。</p><h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h3><h6 id="集合：无序集"><a href="#集合：无序集" class="headerlink" title="集合：无序集"></a>集合：无序集</h6><p>集合，数学中默认指无序集，用于表达元素的聚合关系。两个元素只有属于同一个集合与不属于同一集合两种关系。</p><p>常见应用场景： </p><ul><li>两个元素是否属于同一个集合？</li><li>一个元素是否在集合中存在？</li></ul><p>常见实现方式：</p><ul><li>std::unordered_set、std::unordered_map</li><li>并查集、哈希表</li><li>启发式可并堆</li></ul><h6 id="集合：偏序集"><a href="#集合：偏序集" class="headerlink" title="集合：偏序集"></a>集合：偏序集</h6><p>在实际应用中，可能需要关心集合元素顺序。</p><p>集合上定义偏序关系（即≤号），可构成一个偏序集。有序性作为重要规律，可引入算法（如二分法）提升运行效率。</p><p>常见应用场景： </p><ul><li>某个元素在的前驱&#x2F;后继是什么？</li><li>插入&#x2F;删除若干元素，使集合仍然有序？</li><li>某个元素是第几名？第几名是哪个元素？</li></ul><p>常见实现方式：</p><ul><li>std::set、std::map</li><li>二叉排序树(平衡二叉树)</li></ul><h4 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1.并查集"></a>1.并查集</h4><p><strong>两个元素是否属于同一个集合？</strong></p><p>例：如果x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x和y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p><p>将家族视为集合，若两人是亲戚，等价两个元素属于同一集合。初始时，我们不知道任何人的亲属关系。可以认为每一个人单独属于一个集合，其代表为自己。每添加一组亲属关系，则等将于合并两者所属的集合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">样例输入:样例输出:<br><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>Yes<br><span class="hljs-number">1</span> <span class="hljs-number">2</span>Yes<br><span class="hljs-number">1</span> <span class="hljs-number">5</span>No<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">将家族视为集合，若两人是亲戚，等价两个元素属于同一集合。<br>初始时，我们不知道任何人的亲属关系。可以认为每一个人单独属于一个集合，其代表为自己。每添加一组亲属关系，则等将于合并两者所属的集合。<br>考察第一组亲属关系&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&gt;。将<span class="hljs-number">1</span>所属的集合&#123;<span class="hljs-number">1</span>&#125;与<span class="hljs-number">2</span>所属的集合&#123;<span class="hljs-number">2</span>&#125;合并为&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;。<br>此处，我们假定以左侧元素<span class="hljs-number">1</span>作为这个集合的代表。那么<span class="hljs-number">1</span>的代表仍是<span class="hljs-number">1</span>，<span class="hljs-number">2</span>的代表变为<span class="hljs-number">1</span>。<br>考察第四组亲属关系 &lt;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&gt;。查询<span class="hljs-number">25</span>的代表，发现代表均为<span class="hljs-number">1</span>，意味他们已属于同一个集合。因此，这一条关系并没有增加任何的信息，可以忽略。<br>考察第五组关系&lt;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&gt;。此时<span class="hljs-number">1</span>、<span class="hljs-number">3</span>属于不同的集合&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;和&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;，代表分别为<span class="hljs-number">1</span>、<span class="hljs-number">3</span>。我们设置<span class="hljs-number">3</span>的代表为<span class="hljs-number">1</span>。图中可以看到，代表关系具有传递性；<span class="hljs-number">4</span>的代表也随着<span class="hljs-number">3</span>变为了<span class="hljs-number">1</span>。这样一来，&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125; 也并入了集合 &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;<br><br>我们期望的结果是 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 均有亲属关系。但若直接修改 <span class="hljs-number">4</span> 的代表为 <span class="hljs-number">2</span>，则丢失<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 之间的关联。<br>代表关系具有传递性。我们不需要直接修改<span class="hljs-number">2</span>、<span class="hljs-number">4</span>的代表，而是修改<span class="hljs-number">2</span>和<span class="hljs-number">4</span>的代表的代表，那么<span class="hljs-number">2</span>、<span class="hljs-number">4</span>的关系也会改变，同时所属集合中其他所有元素也随代表被更改！<br>因此，先查找<span class="hljs-number">2</span>的代表为<span class="hljs-number">1</span>，<span class="hljs-number">4</span>的代表为<span class="hljs-number">3</span>。然后合并，将<span class="hljs-number">3</span>的代表设置为<span class="hljs-number">1</span>。此时，<span class="hljs-number">4</span>的代表也随着<span class="hljs-number">3</span>变成了<span class="hljs-number">1</span>。这样，集合的合并与查询就都实现了，“并查集”因此得名。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">实现时，用数组fa来存储“代表”，代表具有传递性。当查找代表时，需要向上递归，直至代表为自身<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==fa[x])<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br>当合并两个元素时，需先判断两者是否属于同一集合。若否，则将其中一个集合的代表设置为另一方的代表。<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1,<span class="hljs-type">int</span> c2)</span></span>&#123;<br>    <span class="hljs-type">int</span> f1=<span class="hljs-built_in">find</span>(c1),f2=<span class="hljs-built_in">find</span>(c2);<span class="hljs-comment">//f1为c1的代表，f2为c2的代表</span><br>    <span class="hljs-keyword">if</span>(f1!=f2)fa[f1]=f2;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    fa[i]=i;<br>&#125;<br><span class="hljs-comment">//合并亲属关系</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    <span class="hljs-built_in">join</span>(X,y);<br>&#125;<br><span class="hljs-comment">// 根据代表是否相同，查询亲属关系</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)&#123;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(X)==<span class="hljs-built_in">find</span>(y))<br>        cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化并查集</p><p>寻找代表的过程可能需要多次溯源。随着集合合并的深度增加，溯源的次数会越来越多，严重影响效率。</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220318171000453.png" alt="image-20220318171000453"></p><p>两种优化方式：</p><ul><li>路径压缩(左图)</li></ul><p>在查询完成后，将路径每一个元素的fa值直接更新为代表，使得下一次递归时，只需要一步即可找到代表。</p><ul><li>启发式合并(右图)</li></ul><p>当合并两个集合时，选择较大的集合代表作为代表，即更改元素较少的集合的代表，可以减少路径压缩的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">经过优化后的并查集实现(可以用作模板)其查询的时间复杂度接近常数。<br><span class="hljs-comment">//初始化，每个元素单独属于一个集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        fa[i]=i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 查询集合的&quot;代表&quot;</span><br>    <span class="hljs-keyword">if</span>(f[x]==x)<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<span class="hljs-comment">//路径压缩</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1,<span class="hljs-type">int</span> c2)</span></span>&#123;<span class="hljs-comment">//合并两个集合</span><br>    <span class="hljs-comment">//f1为c1的代表，f2为c2的代表</span><br>    <span class="hljs-type">int</span> f1=<span class="hljs-built_in">find</span>(c1),f2=<span class="hljs-built_in">find</span>(c2);<br>    <span class="hljs-keyword">if</span>(f1!=f2)&#123;<br>        <span class="hljs-keyword">if</span>(size[f1]&lt;size[f2])<span class="hljs-comment">//取较大者为代表</span><br>            <span class="hljs-built_in">swap</span>(f1,f2);<br>        <span class="hljs-comment">//f1元素多,f2元素少</span><br>        fa[f2]=f1;<br>        size[f1]+=size[f2];<span class="hljs-comment">//将代表的size延长</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//路径压缩可以使查询时间复杂度降低至O(logn)，按秩合并优化(输的深度小的一方指向深度大的一方)，可以将查询复杂度优化到接近常数。</span><br></code></pre></td></tr></table></figure><p><strong>带路径长度的并查集</strong>：</p><p>并查集除了可以维护元素之间的聚类关系外，还可以维护距离。只需要额外添加一个距离记录项即可；路径压缩时动态更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 查询集合的“代表”</span><br><span class="hljs-keyword">if</span> (x == fa[x])<span class="hljs-keyword">return</span> x;<br>fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>dist[x] += dist[fa[x]];<br><span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> c1, <span class="hljs-type">int</span> c2, <span class="hljs-type">int</span> d)</span> </span>&#123; <span class="hljs-comment">// 合并两个集合</span><br><span class="hljs-comment">// f1为c1的代表，f2为c2的代表</span><br><span class="hljs-type">int</span> f1 = <span class="hljs-built_in">find</span>(c1), f2 = <span class="hljs-built_in">find</span>(c2);<br><span class="hljs-keyword">if</span> (f1 != f2)<br>&#123;<br><span class="hljs-keyword">if</span> (size[f1] &lt; size[f2]) <span class="hljs-comment">// 取较大者作为代表</span><br><span class="hljs-built_in">swap</span>(f1, f2);<br>fa[f2] = f1;<br>dist[f2] = d;<br>size[f1] += size[f2]; <span class="hljs-comment">// 只有“代表”的size是有效的</span><br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h4><p><strong>一个元素是否在集合中存在？</strong></p><p>字符串哈希：</p><p>给定N(N≤10000)个字符串（第i个字符串长度为M<sub>i</sub>(M<sub>i</sub>≤1500)，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">样例输入:样例输出:<br><span class="hljs-number">5</span><span class="hljs-number">4</span><br>abc<br>aaaa<br>abc<br>abcc<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p>任意两个字符串两两比较时间上必然是不可取的，时间只允许处理每一个字符串仅一次。</p><p>联想<strong>计数排序</strong>的思想，我们可以将每一个字符串装入一个投票箱， 使得相同的投票箱里只有同一类字符串。 </p><table><thead><tr><th>票箱#1</th><th>票箱#2</th><th>票箱#3</th><th>票箱#4</th><th>票箱#5</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><p>至于如何将字符串变为数字，就取决于Hash函数如何构造。 </p><p>先考虑一个简单的问题：</p><p>给定N个自然数，值域是 [0, 10<sup>18</sup>]，求出这 N 个自然数中共有多少个不同的自然数。</p><p>将整数映射到较小的整数，不难想到一个经典的运算：取模。</p><table><thead><tr><th>原数</th><th>1</th><th>14</th><th>514</th><th>1919810</th><th>1145141919810</th></tr></thead><tbody><tr><td>模11</td><td>1</td><td>3</td><td>8</td><td>2</td><td>9</td></tr></tbody></table><p>余与模的区别：<br>$$<br>余数由除法定义：r&#x3D;q-\left [\frac{a}{q} \right ] \times q所得，符号与被除数相同<br>\<br>模数由数轴划分：m&#x3D;q-k\left [\frac{a}{q} \right ]所得，符号永远为正<br>$$</p><table><thead><tr><th>a</th><th>-9</th><th>-8</th><th>-7</th><th>-6</th><th>-5</th><th>-4</th><th>-3</th><th>-2</th><th>-1</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>余</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>模</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>**可以注意到余数在正负方向表现不一致。所以我们一般使用模数。 **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 233333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,ans,a[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;x;<br>        x%=mod;<br>        <span class="hljs-keyword">if</span>(!a[x])a[x]=<span class="hljs-number">1</span>,ans++;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优势：有效地减少了空间的利用，只需要定义一个大小为mod的数组。</p><p>劣势：如果有两个不同的数恰好对mod取模之后得到了相同的结果，算法会认为这两个数是同一个数，产生了冲突。</p><p>把int数组改成一个vector&lt;int&gt;的数组或者一个链表，然后将取模后为同一个数的所有制都存在其对应的vector或者链表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 233333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; linker[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;linker[x%mod].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(linker[x%mod][i]==x)<br>            <span class="hljs-keyword">return</span>;<br>        linker[x%mod].<span class="hljs-built_in">push_back</span>(x);<br>        ans++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，当需要存储的数字为1 2 3 4 5 6，模数为4时，这个vector数组就是这样的：模4为0的数只有4，模4为1的数有1和5，模4为2的数有2和6，模4为3的数只有3。当加入一个新的数233时，先算出233mod4&#x3D;1，然后遍历1的vector，发现没有233这个元素，于是答案++，然后将233这个元素push_back到1所对应的vector后面。这样的数据结构被称为哈希表或者Hash表。</p><p>原来的哈希表：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center"></td><td align="center">5</td><td align="center">6</td><td align="center"></td></tr></tbody></table><p>插入数据后的哈希表：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center"></td><td align="center">5</td><td align="center">6</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">233</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>如何将一个字符串当作一个数字？</p><p>用ASCII码将单个字符映射成一个数字，例如字符串abAB01可以映射成[97,98,65,66,48,49]。</p><p>把这串序列映射成0到mod-1中的一个数字，称为字符串的Hash值。转换的方式和k进制转换成十进制一样，不断地进行迭代运算hash&#x3D;(hash*k+s[i])%mod即可。</p><p>基数k可以任选，但一般来说不少于128(ASCII字符集的数量)。求Hash值方法不唯一，例如如果字符集局限于a到z的小写字母，也可以把每个字母映射为0到25，此时基数是26。</p><p>这里的模数mod会取一个比较大的质数以减少冲突的可能性，而且在空间足够的情况下越大越好，常见的模数有10007,999983等，可以根据实际情况选择合适的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">由于可能有多个不同字符串对应同一个Hash值，对每个Hash值建立一个<span class="hljs-built_in">vector</span>(或者链表)，用来存储对应于每个Hash值的所有字符串。这样每次只需要将这个插入的字符串和其Hash值相同的所有字符串比较，判断是否相等，就可以知道这个字符串有没有出现过了。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1510</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> base 261</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 23333</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">char</span> s[MAXN];<br>vector&lt;string&gt;linker[mod+<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> hash=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>        hash=(hash*<span class="hljs-number">1ll</span>*base+s[i])%mod;<span class="hljs-comment">//计算出字符串的Hash值</span><br>    &#125;<br>    string t=s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;linker[hash].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-comment">//遍历Hash值为当前字符串Hash值的Hash链表，以检查这个字符串是否已经存在</span><br>        <span class="hljs-keyword">if</span>(linker[hash][i]==t)<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果找到了一个同样的字符串，那么新的这个字符串不计入答案</span><br>        linker[hash].<span class="hljs-built_in">push_back</span>(t);<span class="hljs-comment">//否则把这个字符串计入答案</span><br>        ans++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;s,<span class="hljs-built_in">insert</span>();<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="哈希函数："><a href="#哈希函数：" class="headerlink" title="哈希函数："></a>哈希函数：</h6><p>理论表明，并不是任意选择 Hash 函数都能取得同样的效果。</p><ol><li><p>使用较大的质数作为模数</p><p>模数越大，空间越多，越难以冲突。</p><p>同时，由于质数除了1和自身外没有其他因子，包含乘除运算的 Hash 函数不会因为有公因子而导致不必要的 Hash 冲突。</p></li><li><p>使用复杂的 Hash 函数</p><p>直接取模是最简单的方式。</p><p>但复杂的 Hash 函数可使值域分布更均匀，降低冲突的可能。</p></li></ol><p><strong>Hash函数的输入应只与对象本身有关，而与随机数等任何外界环境无关。</strong></p><p>折叠之后，不同的数可能映射到同一个区域，这一现象称为 Hash 冲突。例如4，-1，9模5均为4</p><p>三种解决方法：</p><ol><li>使用稳健的 Hash 函数，效率最高，冲突率最高</li><li>使用十字链表，完全解决冲突，效率较低</li><li>使用 Multi-Hash，折中的方法</li></ol><h6 id="1-十字链表"><a href="#1-十字链表" class="headerlink" title="1.十字链表"></a>1.十字链表</h6><p>使用链表（或 std::vector 等结构）将 Hash 冲突的元素保存起来。这样，查找一个元素时只需要与 Hash 冲突的较少元素进行比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;hash[MAXN]<br><span class="hljs-comment">//以下是插入集合的方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(x)</span></span>&#123;<br>    <span class="hljs-type">int</span> h=<span class="hljs-built_in">f</span>(x);<span class="hljs-comment">//计算哈希值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=hash[h].size;i&lt;sz;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x==hash[h][i])<span class="hljs-comment">//从数组中找到了这一项</span><br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//什么都不做，直接退出</span><br>    hash[h].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//插入这个元素</span><br>    &#125;<br>&#125;<br>用这种方式可以完全解决 Hash 冲突问题。 但是查找元素的复杂度会有所上升（取决于 Hash 冲突的次数）。<br></code></pre></td></tr></table></figure><h6 id="2-Multi-Hash-多哈希"><a href="#2-Multi-Hash-多哈希" class="headerlink" title="2.Multi Hash(多哈希)"></a>2.Multi Hash(多哈希)</h6><p>将映射f调整为高维，例如同时使用两个模数</p><table><thead><tr><th>原数</th><th>1</th><th>14</th><th>514</th><th>114514</th><th>1145141919810</th></tr></thead><tbody><tr><td>模5</td><td>1</td><td>4</td><td>4</td><td>0</td><td>0</td></tr><tr><td>模7</td><td>1</td><td>0</td><td>3</td><td>4</td><td>0</td></tr></tbody></table><p>只有当多个Hash函数值同时相等才会导致Hash冲突。冲突概率大幅降低。 </p><p>注意Multi Hash对空间的开销较大，因为需要使用二维数组。</p><h6 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h6><p>字符在计算机中是以ASCII码（8位整数）的形式存储的。所以可进行整数运算，把字符串视作超长的256进制高精度整数。</p><table><thead><tr><th>字符</th><th>L</th><th>u</th><th>o</th><th>g</th><th>u</th><th>4</th><th>!</th></tr></thead><tbody><tr><td>ASCII</td><td>76</td><td>117</td><td>111</td><td>103</td><td>117</td><td>52</td><td>33</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">由于取模运算具有关于乘法的结合律和关于加法的分配率，可以构造出最简单的Hash函数：将字符串视作整数取模。<br>string s;<br><span class="hljs-type">int</span> hash=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>    <span class="hljs-comment">// 计算base进制下模mod的值作为hash值</span><br>    hash=((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)hash*base+s[i])%mod;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算哈希函数的 base 和 mod 根据经验选取。 </p><ul><li>base 应当选择不小于字符集数的质数。例如，a-z 字符串为 26，任意 ASCII 字符串为 256。 </li><li>mod应该选取允许范围内尽可能大的质数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, ans;<br><span class="hljs-type">char</span> s[MAXN];<br>vector &lt;string&gt; linker[mod + <span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cin &gt;&gt; s, <span class="hljs-built_in">insert</span>();<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> hash = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; i++)<br>hash = (hash * <span class="hljs-number">1ll</span> * base + s[i]) % mod;<br><span class="hljs-comment">//计算出字符串的hash值</span><br>string t = s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; linker[hash].<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-comment">//遍历hash值为该字符串hash值的链表，检查字符串是否存在</span><br><span class="hljs-keyword">if</span> (linker[hash][i] == t)<br><span class="hljs-keyword">return</span>; <span class="hljs-comment">//如果找到同样的字符串，这个字符串不计答案</span><br>linker[hash].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">//否则计入答案</span><br>ans++;<br>&#125;<br>这里取 base=<span class="hljs-number">261</span>，mod=<span class="hljs-number">23333</span>。<br></code></pre></td></tr></table></figure><h4 id="3-STL中的集合"><a href="#3-STL中的集合" class="headerlink" title="3.STL中的集合"></a>3.STL中的集合</h4><p><strong>某个元素在偏序关系上的后继（或前驱）是什么？可以使用 STL 简化编程的过程吗？</strong></p><h6 id="STL中的集合与映射"><a href="#STL中的集合与映射" class="headerlink" title="STL中的集合与映射"></a>STL中的集合与映射</h6><p>STL中也有集合的实现，分为无序集和偏序集</p><p>其中分为集合(set)和映射(map)</p><ul><li><p>无序集在STL中是unordered_set和unordered_map</p><p>其本质为Hash表，因此增删改查均为O(1)，对于复杂数据类型，需要手动实现Hash函数</p></li><li><p>偏序集在STL中是set和map</p><p>本质为排序树，增删改查均为O(logn)，对于复杂数据类型，需要手动实现偏序关系，即&lt;运算符。</p></li></ul><p>集合在STL中有两种，分别是有序集合和无序集合</p><p>无序集合需要头文件<unordered_set></p><p>unordered_set的行为(无序)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;Type&gt; s;<span class="hljs-comment">//创建Type类型的集合</span><br><br>s.<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 插入元素x s.erase(x); // 删除值为x的元素</span><br>s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的元素</span><br>s.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>s.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查询x；不存在则返回s.end()</span><br>s.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回集合的大小</span><br></code></pre></td></tr></table></figure><p>有序集合需要头文件<set></p><p>set的行为(有序)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;Type&gt; s; <span class="hljs-comment">// 创建一个Type类型的集合</span><br>s.<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 插入元素x s.erase(x); // 删除值为x的元素</span><br>s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的元素</span><br>s.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>s.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查询x；不存在则返回s.end()</span><br>s.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回集合的大小</span><br>s.<span class="hljs-built_in">upper_bound</span>(x); <span class="hljs-comment">// 查询大于x的最小元素</span><br>s.<span class="hljs-built_in">lower_bound</span>(y); <span class="hljs-comment">// 查询不小于x的最小元素</span><br><span class="hljs-comment">// 使用方法与二分查找一章所介绍的一致</span><br>lower_bound会找出序列中第一个大于等于x的数<br><br>upper_bound会找出序列中第一个大于x的数<br></code></pre></td></tr></table></figure><p>功能上有序集与无序集类似，但有序集可以查找前驱后继。</p><p>映射在STL中也有两种，分别是有序映射和无序映射</p><p>有序映射需要头文件<unordered_map></p><p>unordered_map的行为(无序)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map &lt;T1, T2&gt; m; <span class="hljs-comment">// 创建T1到T2的映射</span><br><span class="hljs-comment">// 其中T1称为键key，T2称为值value</span><br><br>m.<span class="hljs-built_in">insert</span>(&#123;a,b&#125;);<span class="hljs-comment">// 创建映射a-&gt;b</span><br>m.<span class="hljs-built_in">erase</span>(a); <span class="hljs-comment">// 删除key为a的映射</span><br>m.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的映射</span><br>m.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>m.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 寻找键x；若不存在则返回m.end()</span><br>m.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>m.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回映射数目</span><br>m[a] = b; <span class="hljs-comment">// 修改a映射为b；若不存在则创建</span><br></code></pre></td></tr></table></figure><p>无序映射需要头文件<map></p><p>map的行为(有序)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;T1, T2&gt; m; <span class="hljs-comment">// 创建一个T1到T2的映射</span><br><span class="hljs-comment">// 其中T1称为键key，T2称为值value</span><br>m.<span class="hljs-built_in">insert</span>(&#123;a,b&#125;);<span class="hljs-comment">// 创建映射a-&gt;b</span><br>m.<span class="hljs-built_in">erase</span>(a); <span class="hljs-comment">// 删除key为a的映射</span><br>m.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除it所指的映射</span><br>m.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 返回末位哨兵的迭代器</span><br>m.<span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 寻找键x；若不存在则返回m.end()</span><br>m.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 判断是否为空</span><br>m.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回映射数目</span><br>m[a] = b; <span class="hljs-comment">// 修改a映射为b；若不存在则创建</span><br>m.<span class="hljs-built_in">upper_bound</span>(x); <span class="hljs-comment">// 查询大于x的最小键</span><br>m.<span class="hljs-built_in">lower_bound</span>(x); <span class="hljs-comment">// 查询不小于x的最小键</span><br><span class="hljs-comment">// 使用方法与二分查找一章所介绍的一致</span><br></code></pre></td></tr></table></figure><h6 id="4-集合应用实例"><a href="#4-集合应用实例" class="headerlink" title="4.集合应用实例"></a>4.集合应用实例</h6><p>例1：木材仓库<br>仓库里面可存储各种长度的木材，但保证所有长度均不同。<br>作为仓库负责人，你有时候会进货，有时候会出货，因此需要维 护这个库存。有不超过 100000 条的操作：</p><ol><li>进货，格式 1 Length：在仓库中放入一根长度为 Length（不超7过 10<sup>9</sup>) 的木材。如果已有相同长度的木材输出Already Exist。</li><li>出货，格式 2 Length：从仓库中取出长度为 Length 的木材。若 无刚好长度的木材，取出在库的和要求长度最接近的木材。<br>如有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的输出Empty。</li></ol><p>分析：可以将这个问题抽象为：维护一个集合，可以插入一个元素x，同时判断x是否已经存在；查询x的前驱后继，x的前驱定义为小于x的最大的数，x的后继定义为大于x的最小的数；可以删除指定元素。</p><p>可以使用平衡树或Trie来维护集合，也可以通过调用STL里面的set解决问题，set的本质是红黑树（一种比较优秀的平衡二叉树）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">set集合需要头文件&lt;set&gt;<br><span class="hljs-number">1.</span>set&lt;<span class="hljs-type">int</span>&gt;ds:<br>建立一个名为ds的，元素类型为<span class="hljs-type">int</span>的集合<br><span class="hljs-number">2.</span>ds.<span class="hljs-built_in">insert</span>(x):<br>在集合中插入一个元素，如果这个元素已经存在，则没有操作<br><span class="hljs-number">3.</span>ds.<span class="hljs-built_in">erase</span>(x):<br>在集合中删除元素x，如果这个元素不存在，则没有操作<br><span class="hljs-number">4.</span>ds.<span class="hljs-built_in">erase</span>(it):<br>删除集合中地址为it的元素<br><span class="hljs-number">5.</span>ds.<span class="hljs-built_in">end</span>():<br>返回集合中最后一个元素的下一个元素的地址。很少直接使用，而是配合其他方法进行比较，以确定某个元素是否存在。<br><span class="hljs-number">6.</span>ds.<span class="hljs-built_in">find</span>(x):<br>查询x在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">7.</span>ds.<span class="hljs-built_in">lower_bound</span>(x):<br>查询不小于x的最小的数在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">8.</span>ds.<span class="hljs-built_in">upper_bound</span>(x):<br>查询大于x的最小的数在集合中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">9.</span>ds.<span class="hljs-built_in">empty</span>():<br>如果集合是空的，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br><span class="hljs-number">10.</span>ds.<span class="hljs-built_in">size</span>():<br>返回集合中元素的个数<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sas">进货操作可以直接在集合中用<span class="hljs-keyword">insert</span>(),查询操作用lower_bound()操作实现，出货删除操作用erase()实现。lower_bound给出的是仓库中大于或等于要求长度的最短木棍，所以还需要和比这根还短一点的木根比较一下，看看哪根木根离要求的木棍长度更接近。<br>#include&lt;iostream&gt;<br>#include&lt;<span class="hljs-keyword">set</span>&gt;<br>using namespace std;<br>int n,opt,<span class="hljs-keyword">length</span>;<br><span class="hljs-keyword">set</span>&lt;int&gt;ds;<br>int mai<span class="hljs-meta">n</span>()&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>cin&gt;&gt;opt&gt;&gt;<span class="hljs-keyword">length</span>;<br><span class="hljs-keyword">if</span>(opt==1)&#123;<br><span class="hljs-keyword">if</span>(ds.find(<span class="hljs-keyword">length</span>)!=ds.<span class="hljs-keyword">end</span>())<br>cout&lt;&lt;<span class="hljs-string">&quot;Already Exist&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> ds.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">length</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ds.empty())&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Empty&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">set</span>&lt;int&gt;::itreator i=ds.lower_bound(<span class="hljs-keyword">length</span>),j=i;<br><span class="hljs-keyword">if</span>(j!=ds.begi<span class="hljs-meta">n</span>())--j;<br>//如果j是ds.begi<span class="hljs-meta">n</span>()，则不能--<br><span class="hljs-keyword">if</span>(i!=ds.<span class="hljs-keyword">end</span>() <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-keyword">length</span>-(<span class="hljs-comment">*j)&gt;(*i)-length)j=i;</span><br>//如果i是ds.<span class="hljs-keyword">end</span>()，则不能对i解引用<br>cout&lt;&lt;(<span class="hljs-comment">*j)&lt;&lt;endl,ds.erase(j);</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> 0;<br>&#125;<br>地址实际上对应元素的迭代器。lower_bound()返回的迭代器，可以对其++找到后继元素的迭代器，也可以--找到前驱元素的迭代器。需要注意指向元素的迭代器，如果已经是begi<span class="hljs-meta">n</span>()，则不能--，如果已经是<span class="hljs-keyword">end</span>().则不能++<br></code></pre></td></tr></table></figure><p>题意：维护一个集合，支持插入、删除最接近元素。</p><p>最接近，即前驱、自身(若存在)或后继，应当使用偏序集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">使用lower_bound即可找自身或后继；其prev即为所求前驱。<br>set &lt;<span class="hljs-type">int</span>&gt; ::iterator p, q;<br>q = s.<span class="hljs-built_in">lower_bound</span>(length);<br>p = <span class="hljs-built_in">prev</span>(q); <span class="hljs-comment">// 方法1 </span><br>p = q; p--; <span class="hljs-comment">// 方法2；本质等价</span><br>iterator 是指集合元素的迭代器<br><br>set &lt;<span class="hljs-type">int</span>&gt; ds;<br>set &lt;<span class="hljs-type">int</span>&gt; ::iterator i, j;<br>i = ds.<span class="hljs-built_in">lower_bound</span>(lenth);<br>j = i;<br><span class="hljs-keyword">if</span> (j != ds.<span class="hljs-built_in">begin</span>()) --j;<br><span class="hljs-comment">// 需注意如果j是ds.begin()的话是不能--的</span><br><span class="hljs-keyword">if</span> (i != ds.<span class="hljs-built_in">end</span>() &amp;&amp; lenth - (*j) &gt; (*i)-lenth) <br>    j = i;<br><span class="hljs-comment">//若i是end()则不能对i解引用</span><br>cout &lt;&lt; (* j) &lt;&lt; endl, ds.<span class="hljs-built_in">erase</span>(j);<br>j 为前驱地址，i 为本身/后继地址，选择二者中与 length 接近者。<br>如果 i 是 s.<span class="hljs-built_in">begin</span>()，则 <span class="hljs-built_in">prev</span>() 或 -- 会得到错误的值，需特判。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++">C++STL函数<br><span class="hljs-number">1.</span><span class="hljs-built_in">advance</span>()函数<br>advance函数移动的是源迭代器<br><span class="hljs-comment">//创建一个 vector 容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; myvector&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-comment">//it为随机访问迭代器，其指向 myvector 容器中第一个元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = myvector.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//输出 it 迭代器指向的数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;移动前的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><span class="hljs-comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span><br><span class="hljs-built_in">advance</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;移动后的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br>Output:<br>移动前的*it=<span class="hljs-number">1</span><br>移动后的*it=<span class="hljs-number">3</span><br>    <br><span class="hljs-built_in">advance</span>() 函数没有任何返回值，其移动的是 it 迭代器本身。<br>    <br><span class="hljs-number">2.</span><span class="hljs-built_in">prev</span>()函数<br>prev 原意为“上一个”，但 <span class="hljs-built_in">prev</span>() 的功能远比它的本意大得多，该函数可用来获取一个距离指定迭代器 n 个元素的迭代器。<br>其中，it 为源迭代器，其类型只能为双向迭代器或者随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 <span class="hljs-number">1</span>。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。<br>注意，当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。<br><br><span class="hljs-comment">//创建并初始化一个 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = mylist.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span><br><span class="hljs-keyword">auto</span> newit = <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;<br> <br><span class="hljs-comment">//n为负数，newit 位于 it 右侧</span><br>it = mylist.<span class="hljs-built_in">begin</span>();<br>newit = <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">-2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;<br><br>Output:<br><span class="hljs-built_in">prev</span>(it,<span class="hljs-number">2</span>)=<span class="hljs-number">4</span><br><span class="hljs-built_in">prev</span>(it,<span class="hljs-number">-2</span>)=<span class="hljs-number">3</span><br>    <br>当 it 指向 mylist 容器最后一个元素之后的位置时，通过 <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">2</span>) 可以获得一个新迭代器 newit，其指向的是距离 it 左侧 <span class="hljs-number">2</span> 个元素的位置（其存储的是元素 <span class="hljs-number">4</span>）；当 it 指向 mylist 容器中首个元素时，通过 <span class="hljs-built_in">prev</span>(it, <span class="hljs-number">-2</span>) 可以获得一个指向距离 it 右侧 <span class="hljs-number">2</span> 个位置处的新迭代器。<br>注意，<span class="hljs-built_in">prev</span>() 函数自身不会检验新迭代器的指向是否合理，需要我们自己来保证其合理性。<br><br><span class="hljs-number">3.</span><span class="hljs-built_in">next</span>()函数<br>和 prev 相反，next 原意为“下一个”，但其功能和 <span class="hljs-built_in">prev</span>() 函数类似，即用来获取一个距离指定迭代器 n 个元素的迭代器。<br>其中 it 为源迭代器，其类似可以为前向迭代器、双向迭代器以及随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 <span class="hljs-number">1</span>。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。<br>需要注意的是，当 it 为前向迭代器时，n 只能为正数，该函数最终得到的新迭代器位于 it 右侧；当 it 为双向迭代器或者随机访问迭代器时，若 n 为正数，则得到的新迭代器位于 it 右侧，反之位于 it 左侧。<br><br><span class="hljs-comment">//创建并初始化一个 list 容器</span><br>list&lt;<span class="hljs-type">int</span>&gt; mylist&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = mylist.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 右侧</span><br><span class="hljs-keyword">auto</span> newit = <span class="hljs-built_in">next</span>(it, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;next(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;<br> <br><span class="hljs-comment">//n为负数，newit 位于 it 左侧</span><br>it = mylist.<span class="hljs-built_in">end</span>();<br>newit = <span class="hljs-built_in">next</span>(it, <span class="hljs-number">-2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;next(it, -2) = &quot;</span> &lt;&lt; *newit;<br><br>Output:<br><span class="hljs-built_in">next</span>(it,<span class="hljs-number">2</span>)=<span class="hljs-number">3</span><br><span class="hljs-built_in">next</span>(it,<span class="hljs-number">-2</span>)=<span class="hljs-number">4</span><br><br>和 <span class="hljs-built_in">prev</span>() 函数恰好相反，当 n 值为 <span class="hljs-number">2</span> 时，<span class="hljs-built_in">next</span>(it, <span class="hljs-number">2</span>) 函数获得的新迭代器位于 it 迭代器的右侧，距离 <span class="hljs-number">2</span> 个元素；反之，当 n 值为 <span class="hljs-number">-2</span> 时，新迭代器位于 it 迭代器的左侧，距离 <span class="hljs-number">2</span> 个元素。<br>注意，和 <span class="hljs-built_in">prev</span>() 函数一样，<span class="hljs-built_in">next</span>() 函数自身也不会检查新迭代器指向的有效性，需要我们自己来保证。<br></code></pre></td></tr></table></figure><p>例2：学籍管理</p><p>设计一个学籍管理系统，最开始数据为空，支持如下操作：</p><ol><li><p>插入与修改，格式 1 NAME SCORE：</p><p>插入姓名为 NAME，分数为 SCORE 的学生。若已经有同名学生则更新他的成绩为 SCORE。如果成功插入或者修改输出OK。</p></li><li><p>查询，格式 2 NAME：在系统中查询姓名为 NAME 的学生的成绩。若未找到这名学生则输出 Not found，否则输出该生成绩。</p></li><li><p>删除，格式 3 NAME：在系统中删除姓名为 NAME 的学生信息。若未找到则输出Not found，否则输出 Deleted successfully。 </p></li><li><p>汇总，格式 4：输出系统中学生数量。</p></li></ol><p>分析：这样的学籍管理系统也是一个集合，但是功能更加复杂——需要根据索引找到对应的元素，并对这些元素进行操作。可以通过调用STL里面的map来解决这个问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">map关联集合的本质也是一棵红黑树，可以看作一个下标可以是任意类型的数组。其头文件是&lt;map&gt;，可以调用map实现如下几个基础功能。<br><span class="hljs-number">1.</span>map&lt;A,B&gt;ds:<br>建立一个名字为ds，下标类型为A，元素类型为B的映射表，例如map&lt;string,<span class="hljs-type">int</span>&gt;就是一个将string映射到<span class="hljs-type">int</span>的映射表<br><span class="hljs-number">2.</span>ds[A]=B:<br>把这个“数组”中下标为A的位置的值变成B<br>下标可以是任意类型。不一定限定为大于<span class="hljs-number">0</span>的整数，比如map&lt;string,string&gt;ds可以进行ds[<span class="hljs-string">&quot;steam&quot;</span>]=csgo的操作；<br><span class="hljs-number">3.</span>ds[A]:<br>访问这个“数组”中下标为A的元素，比如可以进行cout&lt;&lt;ds[<span class="hljs-string">&quot;steam&quot;</span>]&lt;&lt;endl;的操作<br><span class="hljs-number">4.</span>ds.<span class="hljs-built_in">end</span>():<br>返回映射表中最后一个元素的下一个元素的地址。很少直接使用，通常配合其他方法进行比较，以确定某个元素是否存在<br><span class="hljs-number">5.</span>ds.<span class="hljs-built_in">find</span>(x):<br>查询x在映射表中的地址，如果这个数不存在，则返回ds.<span class="hljs-built_in">end</span>()<br><span class="hljs-number">6.</span>ds.<span class="hljs-built_in">empty</span>():<br>如果映射表是空的，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span><br><span class="hljs-number">7.</span>ds.<span class="hljs-built_in">size</span>():<br>返回映射表中元素的个数<br><span class="hljs-number">8.</span>ds.<span class="hljs-built_in">erase</span>(A):<br>删除这个“数组”中下标为A的元素。<br>注意：在使用ds[A]访问“数组”下标为A的元素时，如果这个下标对应的元素不存在，则会自动创建下标为A，值为默认值(例如，所有数值类型的默认值都是<span class="hljs-number">0</span>，string字符串是空字符串)的元素。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,opt,num,ans;<br>string name;<br>map&lt;string,<span class="hljs-type">int</span>&gt; ds;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;opt;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<br>            cin&gt;&gt;name&gt;&gt;num;<br>            ds[name]=num;<span class="hljs-comment">//对映射表name所对应的值修改为num</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>)&#123;<br>            cin&gt;&gt;name;<br>            <span class="hljs-keyword">if</span>(ds.<span class="hljs-built_in">find</span>(name)!=ds.<span class="hljs-built_in">end</span>())&#123;<br>                cout&lt;&lt;ds[name]&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Not found&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span><br>            cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要支持名字到分数的映射。使用 map；不需取前驱后继，也可用 unordered_map。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map &lt;string, <span class="hljs-type">int</span>&gt; ds;<br>string name;<br></code></pre></td></tr></table></figure><p>系统自带字符串 string 类型 Hash 函数，无需自定义 Hash。需求1-4 分别是 unordered_map 提供的 []、find、erase、size 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; name &gt;&gt; num; ds[name] = num;<br>cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;<br>cin &gt;&gt; name;<br><span class="hljs-keyword">if</span> (ds.<span class="hljs-built_in">find</span>(name) != ds.<span class="hljs-built_in">end</span>())<br>cout &lt;&lt; ds[name] &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) &#123;<br>cin &gt;&gt; name;<br><span class="hljs-keyword">if</span> (ds.<span class="hljs-built_in">find</span>(name) != ds.<span class="hljs-built_in">end</span>()) &#123;<br>ds.<span class="hljs-built_in">erase</span>(ds.<span class="hljs-built_in">find</span>(name));<br>cout &lt;&lt; <span class="hljs-string">&quot;Deleted successfully&quot;</span> &lt;&lt; endl; <br>    &#125;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span><br>cout &lt;&lt; ds.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>在查找时如果直接用 m[a]，当 m[a] 不存在时，会自动创建为默认值（例如数值类型默认值是 <span class="hljs-number">0</span>），不能“判断是否存在”。<br>必须要先使用 m.<span class="hljs-built_in">find</span>(a) 确认不为 m.<span class="hljs-built_in">end</span>() 后，方能返回结果。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">本题中由于分数不为<span class="hljs-number">0</span>，可以直接用 <span class="hljs-keyword">if</span> (m[a]) 判断。此时由于<span class="hljs-number">0</span>项的存在，直接size是无法获得学生人数的，只能另开变量储存。<br>cin &gt;&gt; opt;<br><span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; name &gt;&gt; num;<br><span class="hljs-keyword">if</span> (!ds[name]) ans++; <span class="hljs-comment">// ans是当前学生个数</span><br>ds[name] = num; <span class="hljs-comment">// 这里对映射表name所对应的值修改为num</span><br>cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;<br>cin &gt;&gt; name;<br><span class="hljs-keyword">if</span> (ds[name]) cout &lt;&lt; ds[name] &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) &#123;<br>cin &gt;&gt; name;<br><span class="hljs-keyword">if</span> (ds[name]) &#123;<br>ans--;ds[name] = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Deleted successfully&quot;</span> &lt;&lt; endl; <br>        &#125;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; endl; <br>&#125; <span class="hljs-keyword">else</span><br>cout &lt;&lt; ans &lt;&lt; endl;<br>答案正确但不推荐<br></code></pre></td></tr></table></figure><p>例3：A-B数对，给出一个数列以及一个数字C，要求计算出所有A-B&#x3D;C的数对的个数。(不同位置的数字一样的数算不同的数对)。数字个数不超过200000，数列值域和C的值域不超过2<sup>32</sup>-1。</p><p>分析：可以使用map。枚举每一个数A，判断有多少个B满足A-B&#x3D;C，即有多少个B&#x3D;A-C。可以建立一个很大的数组，下标就是这些数字，这样直接就可以查询到这个数字是否存在。但是由于值域非常大，会造成内存超限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 200010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;ds;<br><span class="hljs-type">int</span> a[MAXN],n,c;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i],ds[a[i]]++;<span class="hljs-comment">//把每个元素加入map中，如果原先不存在默认初始值为0</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ans+=ds[a[i]-c];<span class="hljs-comment">//对于每个A，查询有多少B满足条件</span><br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小贴士：关于STL"><a href="#小贴士：关于STL" class="headerlink" title="小贴士：关于STL"></a>小贴士：关于STL</h6><p>使用STL可以方便快捷地解决问题。</p><p><strong>在有需要的情况下，尽量优先使用STL！</strong></p><ol><li>STL经过验证，避免手写出错；</li><li>STL经过优化，一般性能更好； </li><li>STL使用方便，可以快速过题</li></ol><p><strong>不过STL的问题是：常数大所以慢！开启 O2 优化可提升。</strong></p><h4 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5.总结"></a>5.总结</h4><p><strong>并查集</strong></p><pre><code class="hljs">    解决集合的合并问题，判断两个元素是否在同一个集合中别忘了记得初始化 </code></pre><p><strong>Hash（哈希）</strong></p><pre><code class="hljs">    将很大的数组或者字符串等元素，映射为较小整数    哈希冲突的解决：设计哈希函数、多维模数、十字链表</code></pre><p><strong>set &#x2F; map</strong></p><pre><code class="hljs">    维护偏序集，排序，快速查找前驱后继    集合、映射之间的区别和关系</code></pre><p><strong>unordered_set &#x2F; unordered_map</strong></p><pre><code class="hljs">    维护无序集，快速查找、修改元素</code></pre><h3 id="4-图的基本应用"><a href="#4-图的基本应用" class="headerlink" title="4.图的基本应用"></a>4.图的基本应用</h3><h4 id="1-图的概念与建立"><a href="#1-图的概念与建立" class="headerlink" title="1.图的概念与建立"></a>1.图的概念与建立</h4><p>图的存储：</p><p>每个点都是顶点，每条直接连通的道路称作边，图是顶点和边构成的集合。顶点连边的数量就是顶点的度数。</p><p>每一条道路都可以双向通行的的图被称为无向图，道路是单向通行的被称为有向图。</p><p>无向图中，一个结点连边的条数称作这个结点的度数。</p><p>两个顶点中间有多条边称为重边，一条边的起点和终点一样称为自环，针对每一条边的属性值被称为边权，顶点的属性值称为点权。</p><p>右下图中每条道路只能单向通行，即边是单向的，被称为单向图。左下图则为无向图，可以双向通行。</p><p>对于有向图：</p><ul><li>一个结点向别的结点连边的条数称作这个结点的出度</li><li>别的结点连边到一个结点的条数称作这个结点的入度</li></ul><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320141800652.png" alt="image-20220320141800652"></p><p>可以使用邻接矩阵存储一张图：记v[i][j]表示从i到j的边权也就是路线长度。如果不通可以设置成0或者inf(一个很大的数字)。</p><p>无向图的邻接矩阵右上和左下是对称的，有向图的邻接矩阵是不对称的。</p><p>也是就v[i][j]和v[j][i]是相同的。因为点i和点j双向连通，边权相等。如果忽略掉边权，只判断两点直接是否有边直接连接，那么可以把边权视为1，如果v[i][j]是0，说明点i和点j之间没有边直接连接。</p><p>对于有向图来说，邻接矩阵不一定对称。每一条从i到j的单向道路的数据都会被记录在v[i][j]。同理，如果v[i][j]是0，说明点i到点j没有直接连接的单向道路。</p><table><thead><tr><th align="center">i\j</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">i\j</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">5</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">5</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">0</td><td align="center">4</td><td align="center">3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">4</td><td align="center">3</td><td align="center">1</td><td align="center">4</td><td align="center">0</td><td align="center">4</td><td align="center">4</td><td align="center">3</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>对于一个n个点m条边的图，在使用邻接矩阵时，需要开一个n×n的数组，即空间复杂度O(n<sup>2</sup>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        cin&gt;&gt;v[i][j]<span class="hljs-comment">//存入每一对点之间的边权，读入邻接矩阵</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//找到与点i有直线连接的每一个点以及那条边的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(v[i][j]&gt;<span class="hljs-number">0</span>)<br>            cout&lt;&lt;<span class="hljs-string">&quot;edge from point&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;to point&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;with length&quot;</span>&lt;&lt;v[i][j]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br>如需要得到图上所有边，就需要遍历整个n×n数组，即遍历边时间复杂度<span class="hljs-built_in">O</span>(n²).<br></code></pre></td></tr></table></figure><p>对于一个有n个点m条边的图，在使用邻接矩阵时，虽然可以直接得到每两个点之间的边权，但是为了存储这些边权，需要开一个n×n数组，即有O(n²)的空间复杂度，如需要得到图上所有边，就需要遍历整个n×n数组，即遍历边时有O(n²)的时间复杂度。</p><p>优化：开一个二维数组p[i][j]，第一维i表示起点，第二维j表示i的第j条边，p[i][j]表示这条边的终点。</p><p>可采用 vector 代替二维数组，使用 vector 存储第二维，从而减少空间占用。这种做法被称为邻接表。</p><p>为了同时存储边的终点与边权，可以采用结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">邻接表的思想：只需要一个点能到达的顶点和相应边的边长的集合，为了存下这个集合，需要开一个二维数组，第一维i表示起点，第二维j表示是点i的第j条边。可以使用vector来实现，首先定义一个edge结构体，里面有两个变量to和cost，表示一条边的终点和边权。每当读入一条边&lt;u,v,l&gt;，用p[u].<span class="hljs-built_in">push_back</span>((edge)&#123;v,l&#125;)来表示为点u增加一条终点为v、边权为l的边。如果想知道点u有多少条边，可以使用p[u].<span class="hljs-built_in">size</span>()。如果想清楚点u的所有边，可以使用p[u].<span class="hljs-built_in">clear</span>()<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-comment">//记录边的终点，边权的结构体</span><br>    <span class="hljs-type">int</span> to,cost;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m;<span class="hljs-comment">//图有n个点，m条边</span><br><br>vector&lt;edge&gt;p[MAXN];<span class="hljs-comment">//邻接表</span><br><br><span class="hljs-type">int</span> v[MAXN][MAXN]<span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v,l;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;l;<br>        p[u].<span class="hljs-built_in">push_back</span>((edge)&#123;v,l&#125;);<br>      <span class="hljs-comment">//p[v].push_back((edge)&#123;u,l&#125;);</span><br>      <span class="hljs-comment">//无向图邻接表需要加一条反方向的边</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//遍历邻接表，把邻接表转换为邻接矩阵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].<span class="hljs-built_in">size</span>();j++)<br>         v[i][p[i][j].to]=p[i][j].cost;<br>&#125;<br><span class="hljs-comment">//输出邻接矩阵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        cout&lt;&lt;v[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>可以发现，对于每条边，只会被插入一个vector里面，且只插入一次，而总的边数是<span class="hljs-built_in">O</span>(m)的，总的空间复杂度是<span class="hljs-built_in">O</span>(m)，当m比n²小很多的时候，更具空间优势。但是，如果需要指定查询或修改边&lt;i,j&gt;的边权，因为并不知道这条边的具体存放位置，所以需要通过遍历以i为起点的所有边来找到这条边，需要的时间复杂度是<span class="hljs-built_in">O</span>(n)。在这一点上，邻接表的复杂度不如邻接矩阵的<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><p>邻接表优点：总的空间复杂度是O(m)的，且遍历某个点相邻的节点的时间复杂度为O(p)，其中 p 为该点的出度。</p><p>邻接表缺点：如果需要指定查询或修改边&lt;i,j&gt;的边权，需要的时间复杂度是O(p)，不如邻接矩阵的O(1)。</p><p>邻接矩阵：适用于点较少（几百）、边较多（稠密图）的情况；</p><p>邻接表：适用于点较多(边数远没有达到点数的二次方)、或者可能出现重边的情况。 </p><h4 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2.图的遍历"></a>2.图的遍历</h4><p>为了不重复地遍历一个图，定义一个vis数组，表示每个结点是否被遍历过，在遍历时经过每个结点时，马上将这个结点的vis设为1，然后在经过每个结点之前，判断这个结点的vis是否为0，即没被访问过，如果vis不是0，则不再经过这个结点，这样就做到了不重复地遍历一张图。</p><h6 id="深度优先遍历："><a href="#深度优先遍历：" class="headerlink" title="深度优先遍历："></a>深度优先遍历：</h6><p>特点是优先遍历最先被发现的点，直到终点就退回去，需要使用栈维护遍历的层级(一般用递归来实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">bool</span> u[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//此时输出遍历顺序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=p[x].<span class="hljs-built_in">size</span>();i&lt;sz;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">solve</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        p[x].<span class="hljs-built_in">push_back</span>(y);<span class="hljs-comment">//用邻接表记录图</span><br>    &#125;<br>    u[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>   <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">solve</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="广度优先遍历："><a href="#广度优先遍历：" class="headerlink" title="广度优先遍历："></a>广度优先遍历：</h6><p>特点是优先遍历离原点距离更近的点。需要使用队列来维护待遍历的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-type">bool</span> u[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        p[x].<span class="hljs-built_in">push_back</span>(y);<br>    &#125;<br>   u[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sz=p[x].<span class="hljs-built_in">size</span>();i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>                u[p[x][i]]=<span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(p[x][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!u[p[x][i]])&#123;<br>            u[p[x][i]]=<span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(p[x][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：给出N个点，M条边的有向图，对于每个点v，求A(v)表示从点v出发，能到达的编号最大的点。<img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320163345154.png" alt="image-20220320163345154"></p><table><thead><tr><th align="left">v</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="left">A(v)</td><td align="center">7</td><td align="center">5</td><td align="center">5</td><td align="center">5</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr></tbody></table><p>思路：让最大的点去告诉哪些点能到达它，用反向边建图。</p><p>枚举点时从n枚举到1。然后从当前枚举的点u出发，让能遍历到的且没有被更新过的点v的A(v)&#x3D;u。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">solve</span>(p[x][i],v);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">solve</span>(i,i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：如果想对每个点做一次深度优先遍历，对于一次遍历的复杂度是O(N+M)，所以总复杂度是O(N(N+M))</p><p>优化：在做深度优先遍历时，当需要求A(u)时，设A(u)为自己的点标号u，然后求出它能直接到达的点v的A(v)，然后让当前的A(u)与A(v)取最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;isotream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">solve</span>(p[x][i],v);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        p[v].<span class="hljs-built_in">push_back</span>(u);<span class="hljs-comment">//反向建边</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">solve</span>(i,i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pass</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    a[x]=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[p[x][i]]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">pass</span>(p[x][i],v);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u,v;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        p[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">pass</span>(i,i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-DAG与拓扑排序"><a href="#3-DAG与拓扑排序" class="headerlink" title="3.DAG与拓扑排序"></a>3.DAG与拓扑排序</h4><p>有向无环图：对于一张有向图，如果它没有环，则称为有向无环图，简称DAG。下图即为DAG.</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320173241340.png" alt="image-20220320173241340"></p><p>例：有n项杂务要完成，完成第i项杂务需要一定的时间len[i].</p><p>有的杂务需要另一些杂务完成后才能做，互相没有关系的杂务可以同时进行。求出完成所有杂务的最短时间</p><p>思路：对每个任务用vis数组记下来完成这个任务所需要的最短时间，然后考虑在DFS的过程中算出完成每个任务所需要的最短时间，也就是每个结点的vis的取值。由于每个任务必须在所有准备任务完成后才能完成，所以完成每个任务所需要的最短时间就是其所有准备任务里面最晚完成的时间加上完成这个任务需要的时间，可以用DFS来实现，唯一的区别就是把vis数组的值从1改成完成的最短时间。</p><p>如果x是y的准备工作，那么在x和y之间连一条有向边。</p><p>对于每个任务，使用 vis 数组记下来完成这个任务所需要的最短时间，可以在 dfs 的过程中完成。</p><p>完成每个任务所需要的最短时间就是其所有准备任务里面最晚完成的时间加上完成这个任务需要的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">使用记忆化搜索，优化效率完成本题<br>实际上建图的时候，是后面的任务指向前面的任务，然后去溯源。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 10010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,x,y,t,ans,len[MAXN],vis[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt;linker[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">return</span> vis[x];<span class="hljs-comment">//如果这个结点被访问过，返回访问这个结点的最短时间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; linker[x].<span class="hljs-built_in">size</span>(); i++)<br>vis[x] = <span class="hljs-built_in">max</span>(vis[x], <span class="hljs-built_in">dfs</span>(linker[x][i]));<br>    <span class="hljs-comment">//找到所有连向这个结点的边里面距离最长的一个</span><br>vis[x] += len[x];<span class="hljs-comment">//加上这个结点的时间</span><br><span class="hljs-keyword">return</span> vis[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; x &gt;&gt; len[i];<br><span class="hljs-keyword">while</span> (cin &gt;&gt; y)<br><span class="hljs-keyword">if</span> (!y) <span class="hljs-keyword">break</span>; <br>    <span class="hljs-keyword">else</span> linker[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i));<span class="hljs-comment">//对每个结点到达时间求max,得到答案</span><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓扑排序：对于 DAG，在有的时候，对于一个节点的信息的计算，需要确保与之相连的点的信息全部被计算。这时就需要用到拓扑排序。</p><p>本质是确保 DAG 上的点的计算顺序而非对数列排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">STEP <span class="hljs-number">1</span>：将入度为 <span class="hljs-number">0</span> 的点插入队列。<br>STEP <span class="hljs-number">2</span>：取出队头 x，遍历所有x能到达的点y。<br>STEP <span class="hljs-number">3</span>：对于每一个点 y，维护其节点信息，<br>同时使它入度 <span class="hljs-number">-1</span> 以完成删边操作。<br>STEP <span class="hljs-number">4</span>：当 y 入度为 <span class="hljs-number">0</span> 时，插入队列。<br>STEP <span class="hljs-number">5</span>：跳转到 STEP <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220320221845913.png" alt="image-20220320221845913"></p><p>例：<strong>最大食物链计数</strong></p><p>给你一个食物网，你要求出这个食物网中最大食物链的数量。对80112002 取模。不超过 5000 个点，500000 条边。（食物链开头是不会捕食其他生物的生产者，结尾是不会被其他生物捕食的消费者。）</p><p>图中食物网就是一个 DAG，五边形点入度为 0，八边形点出度为 0。</p><p>图中 1→3→7→9 是一条最大食物链；而 2→6, 3→7→9 和 1→3→7 都不是。</p><p>思路：食物网中的关系是单向且无环的，因而可以抽象为 DAG。</p><p>题意自然转化为从入度为 0 的点到出度为 0 的点的链的条数。</p><p>用 f[x] 表示从任意一个入度为 0 的点到点 x 的链的条数之和，那么对于任意一个入度为0的点y，它的f[y]&#x3D;1。对于一个入度非0的点z，则f[z] 为能到达 z 的所有点 u 的 f[u] 之和。</p><p>在计算f[x]的过程中，需要保证点x的所有能到达点x的点y的f[y]已经被计算过了，这样就需要确定一个合适的计算顺序。拓扑排序并不是对一个数列进行排序，而是在DAG上对点进行排序，使得在搜到点x时所有能到达点x的点y已经被搜过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">流程如下：<br><span class="hljs-number">1.</span>将所有入度为<span class="hljs-number">0</span>的点加入处理队列<br><span class="hljs-number">2.</span>将处于队头的点x取出，遍历点x能到达的所有点y.<br><span class="hljs-number">3.</span>对于每一个y，删去从点x到点y的边。在具体的实现中，只需要让y的入度减<span class="hljs-number">1</span>即可。可以顺便对点y的数据进行维护，此题中是f[x]=(f[x]+f[y])%MOD.<br><span class="hljs-number">4.</span>如果点y的入度减到<span class="hljs-number">0</span>了，说明所有能到y的点都被计算过了，这时将点y加入处理队列。<br><span class="hljs-number">5.</span>重复步骤<span class="hljs-number">2</span>直到队列为空<br>这样就保证了食物链计数中求f[x]的顺序正确<br></code></pre></td></tr></table></figure><p>对于入度为 0 的点，f[x]&#x3D;1，满足需要确保与之相连的点的信息全部被计算。</p><p>使用拓扑排序。只需 STEP 3 中的维护， 变成 f[y] &#x3D; (f[x] + f[y]) % 80112002 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">最大食物链计数：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXM 500005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD 80112002</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,ans;<br>vector&lt;<span class="hljs-type">int</span>&gt;p[MAXN];<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-type">int</span> f[MAXN],ind[MAXN],outd[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//预处理：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        outd[x]++; <span class="hljs-comment">// 点x的出度加1</span><br>        ind[y]++; <span class="hljs-comment">// 点y的入度加1</span><br>        p[x].<span class="hljs-built_in">push_back</span>(y);<span class="hljs-comment">//用邻接表记录下食物链的关系</span><br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (ind[i] == <span class="hljs-number">0</span>) &#123; <br>            q.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//将入度为0的点加入队列</span><br>            f[i] = <span class="hljs-number">1</span>; <br>        &#125;<br>    <span class="hljs-comment">//拓扑排序：</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;p[x].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> y = p[x][i];<br>            f[y] = (f[x] + f[y]) % MOD;<br>            ind[y]--;<br>            <span class="hljs-keyword">if</span> (ind[y] == <span class="hljs-number">0</span>) <span class="hljs-comment">//此时点y已经没有入度，将点y加入队列</span><br>                q.<span class="hljs-built_in">push</span>(y);<br>            &#125; <br>    &#125;<br>    <span class="hljs-comment">//答案统计：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (outd[i] == <span class="hljs-number">0</span>)<br>            ans = (ans + f[i]) % MOD;<span class="hljs-comment">//在出度为0的点中统计答案</span><br>    cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小提示：何处取模：</strong>本题，对于 f[x] 的计算，以及最后答案的统计，需要一边运算一边取模，防止运算的中途数据超过了数据类型从而答案错误。答案需要对80112002取模时，在计算f[x]时一边加一边取模，以及在出度为0的点的食物链计数求和时一边加一边取模。如果只在输出答案时取模，那么可能在累加的过程中答案就超出了数据类型存储的范围而导致答案的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">(a + b + c + d) % MOD = a % MOD + b % MOD + c % MOD + d % MOD;<br>(a * b * c * d) % MOD = a % MOD * b % MOD * c % MOD * d % MOD;<br></code></pre></td></tr></table></figure><h4 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h4><p><strong>图的定义</strong></p><pre><code class="hljs">    由顶点与边组成的集合。    分类：有向图、无向图    存储：邻接矩阵、邻接表</code></pre><p><strong>图的遍历</strong></p><pre><code class="hljs">    深度优先遍历与广度优先遍历</code></pre><p><strong>有向无环图</strong></p><pre><code class="hljs">    拓扑排序确保 DAG 上的点的计算顺序</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.初涉算法初</title>
    <link href="/2022/05/09/2-%E5%88%9D%E6%B6%89%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/09/2-%E5%88%9D%E6%B6%89%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模拟和高精度"><a href="#1-模拟和高精度" class="headerlink" title="1.模拟和高精度"></a>1.模拟和高精度</h3><p>使用数组：每一个元素存储一个十</p><p>进制位。建议使用小端存储（个位放最前面）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">小端：<br><span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-type">int</span> A[] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>大端：<br><span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-type">int</span> A[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>大端存储虽然看似更直观，但是当处理进位时就会遇到问题：必须要将所有元素移位，为新位腾出空间！</p><p>实际上，如果将数组看做多项式10 &#x3D; ∑&#x2F;span&gt;!10!的系数，则小端 存储才是更“直观”的选择</p><h4 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">length</span>(),b.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,j=<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--,j++)&#123;<br>        A[j]=a[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,j=<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--,j++)&#123;<br>        B[j]=b[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        num[i]+=A[i]+B[i];<br>        num[i+<span class="hljs-number">1</span>]=num[i]/<span class="hljs-number">10</span>;<br>        num[i]%=<span class="hljs-number">10</span>;<br>    &#125;                <br>    <span class="hljs-keyword">if</span>(num[len+<span class="hljs-number">1</span>])&#123;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        cout&lt;&lt;num[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(string a,string b)</span><span class="hljs-comment">//大数比较设定a&gt;b返回1 a&lt;b返回-1 a=b返回0 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//如果字符串长度不同那么长度大的那个就是更大的大数 </span><br>&#123;<br><span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()&gt;b.<span class="hljs-built_in">size</span>())<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//如果字符串长度相同我们通过直接比较字符串的字典序来判断大小 </span><br>&#123;<br><span class="hljs-keyword">if</span>(a&gt;b)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==b)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function">string <span class="hljs-title">myAdd</span><span class="hljs-params">(string a,string b)</span><span class="hljs-comment">//高精度加法 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(),b.<span class="hljs-built_in">size</span>())+<span class="hljs-number">1</span>;    <br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n,<span class="hljs-number">0</span>);<span class="hljs-comment">//开辟一个足够存储结果的数组，结果的位数最多为 位数最多的那个数的位数加一(考虑进位)</span><br><span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,j=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//从个位开始通过模拟竖式进行大数加法 </span><br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>)<span class="hljs-comment">//当两数均未加完时 </span><br>&#123;<br>ans[k--]=(a[i--]-<span class="hljs-string">&#x27;0&#x27;</span>)+(b[j--]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//我们让我们的数组存储每一位相加的结果注意将字符串转为整型数字 </span><br>&#125;<br><span class="hljs-comment">//检测是否有某个数的高位未加完将其直接存入数组中 </span><br><span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>ans[k--]=(b[j--]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>ans[k--]=(a[i--]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>string c=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//创建一个字符串去存储答案 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//因为之前的竖式加每一位都没考虑进位所以我们从最后开始检查进位 </span><br>&#123;<span class="hljs-comment">//因为是加法如果有进位最多也就进一 </span><br><span class="hljs-keyword">if</span>(ans[i]&gt;=<span class="hljs-number">10</span>)<span class="hljs-comment">//如果大于10说明应该进位那么我们让此位减10它的高一位加1 </span><br>&#123;<br>ans[i]-=<span class="hljs-number">10</span>;<br>ans[i<span class="hljs-number">-1</span>]++;<br>&#125;<br>c.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ans[i]+<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//处理后的结果转化为字符插入结果字符的首位</span><br>&#125; <br><span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//检查最最高位是否大于0如果两数相加没有进位那么这一位就是0我们就不必存储它否则则放入字符串 </span><br>&#123;<br>c.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ans[<span class="hljs-number">0</span>]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> c;<span class="hljs-comment">//返回答案 </span><br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function">string <span class="hljs-title">mySubtract</span><span class="hljs-params">(string a,string b)</span><span class="hljs-comment">//高精度减法(整体思想同加法) </span></span><br><span class="hljs-function"></span>&#123;<br>string c=<span class="hljs-string">&quot;&quot;</span>;               <span class="hljs-comment">//创建一个字符串去存储答案 </span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">myCompare</span>(a,b)==<span class="hljs-number">0</span>)      <span class="hljs-comment">//先比较一下两数大小如果相等我们直接返回0即可 </span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">myCompare</span>(a,b)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果a&lt;b那么我们交换两数的值同时在答案字符串中先放入一个负号 </span><br>&#123;<br><span class="hljs-built_in">swap</span>(a,b);<br>c.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br><span class="hljs-type">int</span> n=a.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//开辟一个足够存储结果的数组  减法结果的位数最多为位数最多的那个数的位数我们保证了a为的大数所以就是a的位数 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,j=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//从个位开始模拟竖式减法 </span><br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示低位的借位情况  0:无借位   1:有借位 </span><br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)                         <span class="hljs-comment">//同加法一样模拟运算我们知道a是大数所以a遍历完竖式才完成 </span><br>&#123;<br>    <span class="hljs-type">char</span> nowb;<span class="hljs-comment">//被减数当前位有数就正常减 没有数说明就是0</span><br>    <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>) nowb=b[j];<br>    <span class="hljs-keyword">else</span> nowb=<span class="hljs-string">&#x27;0&#x27;</span>;<br>ans[k]=a[i]-nowb-t;<span class="hljs-comment">//对应位相减同时减去低位的借位</span><br><span class="hljs-keyword">if</span>(ans[k]&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果结果小于0 则向高位借一位</span><br>&#123;<br>t=<span class="hljs-number">1</span>;<br>ans[k]+=<span class="hljs-number">10</span>;<br>&#125; <br><span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;  <span class="hljs-comment">//否则向高位无借位</span><br>k--,i--,j--;  <span class="hljs-comment">//继续判断高一位</span><br>&#125;<br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<span class="hljs-comment">//这里与加法不同高位可能出现多个零开头的情况我们需要找到第一不是零的地方再存数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(flag&amp;&amp;ans[i]==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果当前数为0且未存数则不执行存数操作 </span><br><span class="hljs-keyword">continue</span>;<br>flag=<span class="hljs-literal">false</span>;        <span class="hljs-comment">//一旦存入数更改标志位 </span><br>c.<span class="hljs-built_in">push_back</span>(ans[i]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125; <br><span class="hljs-keyword">return</span> c;              <span class="hljs-comment">//返回结果 </span><br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function">string <span class="hljs-title">myMultiply</span><span class="hljs-params">(string a,string b)</span><span class="hljs-comment">//高精度乘法 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-string">&quot;0&quot;</span>||b==<span class="hljs-string">&quot;0&quot;</span>)   <span class="hljs-comment">//其中有一个为0时直接返回0 </span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;ans;      <span class="hljs-comment">//开辟一个足够存储结果的数组</span><br><span class="hljs-type">int</span> n=a.<span class="hljs-built_in">size</span>(),m=b.<span class="hljs-built_in">size</span>();<br>ans.<span class="hljs-built_in">resize</span>(n+m,<span class="hljs-number">0</span>);   <span class="hljs-comment">//乘法结果的位数最多为两数的位数之和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-comment">//这里从高位开始和从低位开始无所谓我们将两数相乘的结果不考虑放到对应位上最后去检测进位即可 </span><br>&#123;                    <span class="hljs-comment">//例如个位乘百位的结果 以及十位乘十位的结果 都放到百位上 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>&#123;<br>ans[i+j+<span class="hljs-number">1</span>]+=(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*(b[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n+m<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)      <span class="hljs-comment">//我们从低位开始检查进位 </span><br>&#123;<br><span class="hljs-keyword">if</span>(ans[i]&gt;=<span class="hljs-number">10</span>)            <span class="hljs-comment">//如果大于10说明有进位但乘法的进位不一定只进1 </span><br>&#123;<br>ans[i<span class="hljs-number">-1</span>]+=(ans[i]/<span class="hljs-number">10</span>);<span class="hljs-comment">//高位加地位的高于个位部分 </span><br>ans[i]%=<span class="hljs-number">10</span>;           <span class="hljs-comment">//低位对十求余 </span><br>&#125;<br>&#125; <br>string c =<span class="hljs-string">&quot;&quot;</span>;   <span class="hljs-comment">//创建字符串存储答案 </span><br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>; <span class="hljs-comment">//同减法一样找到第一个不是0的位置开始存数 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;n+m;t++)<br>&#123;<br><span class="hljs-keyword">if</span>(flag&amp;&amp;ans[t]==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>flag=<span class="hljs-literal">false</span>;<br>c.<span class="hljs-built_in">push_back</span>(ans[t]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125; <br><span class="hljs-keyword">return</span> c;      <span class="hljs-comment">//返回答案 </span><br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br>vector&lt;string&gt;<span class="hljs-built_in">myDivide</span>(string a,string b)<span class="hljs-comment">//高精度除法</span><br>&#123;<br>vector&lt;string&gt;<span class="hljs-built_in">ans</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//先创建两个字符串空间去存储答案一个存商ans[0]一个存余数 ans[1]</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">myCompare</span>(a,b)==<span class="hljs-number">-1</span>)   <span class="hljs-comment">//如果被除数比除数小商为0余数为a返回答案即可 </span><br>&#123;<br>ans[<span class="hljs-number">1</span>]=a;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">myCompare</span>(a,b)==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果被除数与除数相等商为1余数为0返回答案即可</span><br>&#123;<br>ans[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">else</span>              <span class="hljs-comment">//否则我们需要模拟除法的竖式来进行计算 </span><br>&#123;<br>string res=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//创建存储商的字符串 </span><br><span class="hljs-type">int</span> m1=a.<span class="hljs-built_in">size</span>(),m2=b.<span class="hljs-built_in">size</span>();<br>string a1=a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,m2<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m2<span class="hljs-number">-1</span>;i&lt;m1;i++)     <span class="hljs-comment">//模拟竖式从高位开始依次取数减去除数能减几个该位商的当前位就是几 </span><br>&#123;<br><span class="hljs-keyword">if</span>(a1==<span class="hljs-string">&quot;0&quot;</span>)     <span class="hljs-comment">//如果a1为0为了防止a1出现0开头的情况我们将它清空 </span><br>a1=<span class="hljs-string">&quot;&quot;</span>; <br>a1.<span class="hljs-built_in">push_back</span>(a[i]);      <span class="hljs-comment">//我们从被除数中取一个数放入a1继续减 </span><br><span class="hljs-type">int</span> e=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">myCompare</span>(a1,b)&gt;=<span class="hljs-number">0</span>)<span class="hljs-comment">//当a1大于等于除数时便一直减同时e累加 </span><br>&#123;<br>e++;<br>a1=<span class="hljs-built_in">mySubtract</span>(a1,b);<br>&#125;<br><span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()||e)        <span class="hljs-comment">//如果res不为空或者e不为0我们存储他 </span><br>res.<span class="hljs-built_in">push_back</span>(e+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>ans[<span class="hljs-number">0</span>]=res;   <span class="hljs-comment">//最后res就是商 </span><br>ans[<span class="hljs-number">1</span>]=a1;    <span class="hljs-comment">//a1就是余数 </span><br><span class="hljs-keyword">return</span> ans;   <span class="hljs-comment">//返回答案 </span><br>&#125;<br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function">string <span class="hljs-title">myFactorial</span><span class="hljs-params">(string a)</span><span class="hljs-comment">//高精度阶乘 </span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*我们还可以利用高精度减法和乘法实现大数的阶乘(最大可运行出10000左右的阶乘)*/</span><br><span class="hljs-keyword">if</span>(a==<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">myMultiply</span>(a,<span class="hljs-built_in">myFactorial</span>(<span class="hljs-built_in">mySubtract</span>(a,<span class="hljs-string">&quot;1&quot;</span>)));<br>&#125;<br><span class="hljs-comment">//......................................................................................</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string a,b;<br>string add_ans,subtract_ans,multiply_ans,factorial_ans;<br>vector&lt;string&gt;divide_ans;<br><span class="hljs-type">int</span> compare_ans;<br>cin&gt;&gt;a&gt;&gt;b;<br><br>compare_ans=<span class="hljs-built_in">myCompare</span>(a,b);<br>cout&lt;&lt;compare_ans&lt;&lt;endl;<br><br>add_ans=<span class="hljs-built_in">myAdd</span>(a,b);<br>cout&lt;&lt;add_ans&lt;&lt;endl;<br><br>subtract_ans=<span class="hljs-built_in">mySubtract</span>(a,b);<br>cout&lt;&lt;subtract_ans&lt;&lt;endl;<br><br>multiply_ans=<span class="hljs-built_in">myMultiply</span>(a,b);<br>cout&lt;&lt;multiply_ans&lt;&lt;endl;<br><br>divide_ans=<span class="hljs-built_in">myDivide</span>(a,b);<br>cout&lt;&lt;divide_ans[<span class="hljs-number">0</span>]&lt;&lt;endl&lt;&lt;divide_ans[<span class="hljs-number">1</span>]&lt;&lt;endl;<br><br><span class="hljs-comment">//factorial_ans=myFactorial(a);</span><br><span class="hljs-comment">//cout&lt;&lt;factorial_ans&lt;&lt;endl;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><h4 id="2-高精度加法："><a href="#2-高精度加法：" class="headerlink" title="2.高精度加法："></a>2.高精度加法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 520</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[MAXN],b[MAXN],c[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string A,B;<br>    cin&gt;&gt;A&gt;&gt;B;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">length</span>(),b.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,j=<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--,j++;)&#123;<br>        a[j]=A[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>,j=<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--,j++;)&#123;<br>        b[j]=B[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        c[i]+=a[i]+b[i];<br>        c[i+<span class="hljs-number">1</span>]=c[i]/<span class="hljs-number">10</span>;<br>        c[i]%=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(c[len+<span class="hljs-number">1</span>])&#123;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        cout&lt;&lt;c[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-高精度乘法："><a href="#3-高精度乘法：" class="headerlink" title="3.高精度乘法："></a>3.高精度乘法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 5010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[MAXN],b[MAXN],c[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string A,B;<br>    cin&gt;&gt;A&gt;&gt;B;<br>    <span class="hljs-type">int</span> lena=A.<span class="hljs-built_in">length</span>(),lenb=B.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lena<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        a[lena-i]=A[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lenb<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        b[lenb-i]=B[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lena;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=lenb;j++)&#123;<br>            c[i+j<span class="hljs-number">-1</span>]+=a[i]*b[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> len=lena+lenb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        c[i+<span class="hljs-number">1</span>]+=c[i]/<span class="hljs-number">10</span>;<br>        c[i]%=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!c[len])&#123;<br>        len--;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,len);i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        cout&lt;&lt;c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">1</span>,jw=<span class="hljs-number">0</span>;<span class="hljs-comment">//p代表位数，jw代表进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<span class="hljs-comment">//高精度*单精度</span><br>        a[j]=a[j]*num+jw;<span class="hljs-comment">//高精度*单精度+进位</span><br>        jw=a[j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//设置进位</span><br>        a[j]%=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(jw&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">////如果还有进位，处理进位</span><br>        a[j]=jw%<span class="hljs-number">10</span>;<br>        jw/=<span class="hljs-number">10</span>;<br>        j++;<br>    &#125;<br>    p=j<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>封装结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bigint</span>&#123;<br>    <span class="hljs-type">int</span> len,a[MAXN];<span class="hljs-comment">//为了兼顾效率与代码复杂度，用len记录位数，用a记录每个数位</span><br>    <span class="hljs-built_in">Bigint</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//通过初始化使得这个大整数能够表示整型x，默认为0</span><br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>        <span class="hljs-keyword">for</span>(len=<span class="hljs-number">1</span>;x;len++)<br>            a[len]=x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>;<br>        len--;<br>    &#125;<br>    <span class="hljs-type">int</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)&#123;<br>        <span class="hljs-keyword">return</span> a[i];<span class="hljs-comment">//重载[]，可以直接用x[i]代表x.a[i],编写时更加自然</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(<span class="hljs-type">int</span> L)</span> </span>&#123;<span class="hljs-comment">//处理1到L范围内的进位并重置长度，需要保证L不小于有效长度</span><br>        <span class="hljs-comment">//因为相当于把不是一位数的位都处理成一位数，故取名为“展平”</span><br>        len=L;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>            a[i+<span class="hljs-number">1</span>]+=a[i]/<span class="hljs-number">10</span>,a[i]%=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(;!a[len];)&#123;<span class="hljs-comment">//重置长度成为有效长度</span><br>            len--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(len,<span class="hljs-number">1</span>);i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br>Bigint <span class="hljs-keyword">operator</span>+(Bigint a,Bigint b)&#123;<span class="hljs-comment">//表示两个Bigint类相加，返回一个Bigint类</span><br>    Bigint c;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">max</span>(a.len,b.len);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        c[i]+=a[i]+b[i];<span class="hljs-comment">//计算贡献</span><br>    &#125;<br>    c.<span class="hljs-built_in">flatten</span>(len+<span class="hljs-number">1</span>);<span class="hljs-comment">//答案不超过len+1位，所以用len+1做一遍“展平”处理进位</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br>Bigint <span class="hljs-keyword">operator</span>*(Bigint a,<span class="hljs-type">int</span> b)&#123;<span class="hljs-comment">//表示Bigint类乘整型变量，返回一个Bigint类</span><br>    Bigint c;<br>    <span class="hljs-type">int</span> len=a.len;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        c[i]=a[i]*b;<span class="hljs-comment">//计算贡献</span><br>    &#125;<br>    c.<span class="hljs-built_in">flatten</span>(len+<span class="hljs-number">11</span>);<span class="hljs-comment">//int类型最长10位，所以可以这样做一遍“展平”处理进位</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Bigint <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>,<span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//分别用0和1初始化ans与fac,如果要将常数赋值给大整数，可以使用类似于ans=Bigint(233)的方法</span><br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        fac=fac*i;<span class="hljs-comment">//模拟题意</span><br>        ans=ans+fac;<br>    &#125;<br>    ans.<span class="hljs-built_in">print</span>();<span class="hljs-comment">//输出</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h4><p>模拟方法 深刻理解题意 转化为具体描述 翻译为程序</p><p>抽象的描述 无法执行，但可以定义目的，即“需要做什么”</p><p>具体的描述 可以直接翻译为程序，定义方案，即“怎么做” </p><p>高精度运算基本方法：数组模拟 竖式运算 位压缩</p><p>高精度加法、高精度乘法 </p><p>运算符</p><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><h4 id="1-计数排序"><a href="#1-计数排序" class="headerlink" title="1.计数排序"></a>1.计数排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;,n,m,tmp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;tmp;<br>        a[tmp]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a[i];j++)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br><span class="hljs-comment">//while(a[i]&gt;0)&#123;</span><br><span class="hljs-comment">//    cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">//    a[i]--;</span><br><span class="hljs-comment">//&#125;</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(m+n)空间复杂度O(n)</p><p>计数排序 顾名思义，即统计每一个元素出现的次数，再按照顺序 依次排列。数列中的元素就是“票”，而一个与元素取值范围相 符的数组就是“票箱”。 记n为数列长度， m为取值范围。 需要O(n)的时间统计每一数值出现次数。之后再用O(n + m)的时 间构造出结果数列，总时间O(n + m)。 另外，需要O(m)的额外空间作为票箱。 </p><p>优点：当m较小时，时间复杂度近似于O(n)，性能强大。</p><p>缺点：当m远大于n时，时空复杂度均取决于m，得不偿失。 取值范围为非整数时，无法实现。</p><h5 id="计数排序变种："><a href="#计数排序变种：" class="headerlink" title="计数排序变种："></a>计数排序变种：</h5><ol><li>离散化计数排序 若能将不可表示的数据范围（双向）映射到较小的整数集合上， 则可以在映射后使用计数排序。这一映射过程称为离散化。 </li><li>桶排序 将数列按数值区间（而非具体数值）划分为若干个桶。桶内采用 其他排序算法。 </li><li>基数排序 从低到高对每一个（X进制）位进行一次计数排序。这样，当高位 有序时，所有低位均已有序。可以保证只使用X个桶。</li></ol><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p><strong>思路：n次大循环，第i次大循环中，用小循环寻找数列中第i小的 元素。如果发现更小的数字，则交换至第i个位置。</strong></p><p>从第一张开始一直向后寻找更小的数，与当前位置交换，然后从第二张开始寻找，依次类推</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j]&lt;a[i])&#123;<br>                <span class="hljs-built_in">swap</span>(a[j],a[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n²)空间复杂度O(n)</p><p>事实上，由于前i-1项已经排序完毕，第i小的元素等价于第i至第n 项中的最小元素。 </p><p><strong>特点：思路简单，实现更简单。 每次迭代都能保证至少一个（最小）元素的位置被确定。 前i个元素有序，且为最小的i个元素。</strong></p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208003636731.png" alt="image-20220208003636731"></p><pre><code class="hljs">            ![选择排序](file:///C:/Users/Harrison/AppData/Local/Packages/oice_16_974fa576_32c1d314_eb/AC/Temp/msohtmlclip1/01/clip_image002.png)    </code></pre><p>​                                 </p><h4 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h4><p><strong>思路：不超过n次大循环；每次大循环，按照顺序比较相邻元素并 交换，直到序列有序。</strong></p><p>比较第一张和第二张，如果后面的比前面的小，就交换位置，比较到最后一张，最后一张即为最大值，然后开始第二轮比较，比较到倒数的第二张，倒数第二张即为倒数第二大值，n-1轮后，数列变为有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i<span class="hljs-number">-1</span>;j--)&#123;<br>        <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-built_in">swap</span>(a[j],a[j+<span class="hljs-number">1</span>]); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n²)空间复杂度O(n)</p><p><strong>特点： 总交换次数恰为逆序对数。 每次迭代都能保证至少一个（最大）元素的位置被确定。 后i个元素有序，且为最大的i个元素。</strong></p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208002143935.png" alt="冒泡排序"></p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208003558002.png" alt="image-20220208003558002"></p><h4 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4.插入排序"></a>4.插入排序</h4><p><strong>思路：n次大循环；第i次大循环将第i个元素向前交换，直至左侧元素不大于它，或抵达数列首部。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> now=a[i],j;<br>    <span class="hljs-keyword">if</span>(a[j]&lt;now)&#123;<br>        a[j+<span class="hljs-number">1</span>]=a[j];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    a[j+<span class="hljs-number">1</span>]=now;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n²)空间复杂度O(n)</p><p><strong>特点：前i个元素有序。但是直到排序完成，不能保证任何一个元 素的最终位置被确定（设想最小元素在数列尾部）。</strong></p><p>可以用来动态维护前k小元素，单次插入时间复杂度O (k) 。在此场景下，第k + 1小的元素将不会右移，而是被直接丢弃。</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208002257199.png" alt="插入排序"></p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208003654071.png" alt="image-20220208003654071"></p><h5 id="三种排序应用场景："><a href="#三种排序应用场景：" class="headerlink" title="三种排序应用场景："></a>三种排序应用场景：</h5><p>选择排序：k 很小时快速求解前 k 小&#x2F;大元素 </p><p>冒泡排序：模拟逆序对相关的问题 </p><p>插入排序：k 很小时动态维护前 k 小&#x2F;大元素</p><h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h4><p>选择排序，每一迭代确定一个元素的位置。 但是所有已确定元素均在左侧，对右侧没有指导意义。</p><p>插入排序，每一迭代只需要与大于自身的值比较，期望只需比较 一半的元素。 但是没有元素确定位置；新元素的插入导致所有更大的元素右移， 带来额外开销。</p><p>尝试随机选取一个元素确认位置，称为哨兵数。 将序列中所有比哨兵数小的数字都移动到哨兵数的左边，所有比 哨兵数大的数字都移动到哨兵数的右边。 显然哨兵数左右两侧的元素不再需要任何比较。因此，对两侧的 子数列分别采用相同的做法，直到数列不可再分（长度为0或1）。</p><p>在最优情况下，每次选择的哨兵数均将数列对半分开。则 O(logn)次划分后数列将不可再分。每次划分的复杂度为O(n)， 总复杂度O(nlogn )。 </p><p>在最坏情况下，每次选择的哨兵数均在数列一端。则退化为选择 排序算法，总复杂度O(n²)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-comment">// 引入数组的地址</span><br><span class="hljs-type">int</span> i = l, j = r, flag = a[(l + r) / <span class="hljs-number">2</span>], tmp; <span class="hljs-comment">// flag=哨兵</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">while</span> (a[i] &lt; flag) i++; <span class="hljs-comment">// 从左找比哨兵大的数</span><br><span class="hljs-keyword">while</span> (a[j] &gt; flag) j--; <span class="hljs-comment">// 从右找比哨兵小的数</span><br><span class="hljs-keyword">if</span> (i &lt;= j) &#123; <span class="hljs-comment">// 交换</span><br><span class="hljs-built_in">swap</span>(a[i], a[j]);<br>i++; j--;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (i &lt;= j);<br><span class="hljs-comment">// 习惯上，上面用于分段的过程一般称作partition</span><br><span class="hljs-keyword">if</span> (l &lt; j) <span class="hljs-built_in">qsort</span>(a, l, j);<br><span class="hljs-keyword">if</span> (i &lt; r) <span class="hljs-built_in">qsort</span>(a, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>快排是一种基于分治法的排序算法。 大多数基于分治法的算法均具有O(nlogn)的时间复杂度。</p><p>其余具有此复杂度的排序算法还有： </p><p>基数排序，基于按位处理 </p><p>归并排序，基于分治法 </p><p>堆排序，基于数据结构</p><h4 id="6-STL中的排序算法"><a href="#6-STL中的排序算法" class="headerlink" title="6.STL中的排序算法"></a>6.STL中的排序算法</h4><p>algorithm（算法）库包含很多常用的算法，包括排序。</p><p>包含头文件：<code>#include&lt;algorithm&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">排序：<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// O(nlogn)</span><br>  <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// O(nlogn)</span><br>begin、end分别表示需要排序位置的首末<br>cmp是一个可选参数，可以自定义排序的比较方法<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br>排序之后，可以使用以下算法：<br>去重：<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// O(n)</span><br><span class="hljs-built_in">unique</span>(a,a+n);<br>对a数组从a[<span class="hljs-number">0</span>]到a[n<span class="hljs-number">-1</span>]去重，要求a数组有序<br>这个函数会返回去重后的序列末尾地址（序列长度可能会变短）。<br>返回值-a则为去重后的元素个数<br>查找：<span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), val); <span class="hljs-comment">// O(logn)</span><br><span class="hljs-built_in">find</span>(a,a+n,x)<br>对a数组从a[<span class="hljs-number">0</span>]到a[n<span class="hljs-number">-1</span>]找x，返回x所在的地址<br>若元素存在则返回元素地址，否则返回末尾地址（end）。<br></code></pre></td></tr></table></figure><p>对于数组和 vector（暂时没教） 的数组坐标：</p><ul><li>a+0 &#x3D; begin</li><li>a+n &#x3D; end</li><li>a+(n-1) &#x3D; 最后一个元素</li><li>end-begin &#x3D; n</li><li>find(a[x])-a &#x3D; x</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 对一个 vector 进行排序</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), cmp);<br><span class="hljs-comment">// 对一个 vector 进行【自定义】排序</span><br><span class="hljs-built_in">sort</span>(a, a+n);<br><span class="hljs-comment">// 对一个长度为 n 的数组 a 排序</span><br><span class="hljs-built_in">sort</span>(a, a+n, cmp);<br><span class="hljs-comment">// 对长度为 n 的数组 a【自定义】排序</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208004458346.png" alt="sort"></p><h4 id="7-排序算法具体应用"><a href="#7-排序算法具体应用" class="headerlink" title="7.排序算法具体应用"></a>7.排序算法具体应用</h4><h4 id="8-常用复杂度与数据范围"><a href="#8-常用复杂度与数据范围" class="headerlink" title="8.常用复杂度与数据范围"></a>8.常用复杂度与数据范围</h4><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220208003907386.png" alt="常用复杂度与数据范围"></p><h4 id="9-总结："><a href="#9-总结：" class="headerlink" title="9.总结："></a>9.总结：</h4><p>排序 输入无序序列，处理后变成有序序列</p><p>O(m) 计数排序 </p><p>O(n²) 选择排序 冒泡排序 插入排序 </p><p>O(nlogn) 快速排序 基数排序 </p><p>对数函数 logab，近似为a进制表示下b的位数。 </p><p>STL中的函数 sort unique find 可以简化编程</p><h3 id="3-暴力枚举"><a href="#3-暴力枚举" class="headerlink" title="3.暴力枚举"></a>3.暴力枚举</h3><p><strong>一般而言，算法问题可以分为两类：</strong></p><ol><li>模拟问题：<ul><li>构造具体描述，使用计算机还原现实规则。 </li><li>每一步的行为大多是简单而确定的，只需按照既定指示行动。 </li><li>常基于数据结构，优化单步操作的复杂度。</li></ul></li><li>求解问题：<ul><li>在全部的可能性中，搜索可行解或最优解。 </li><li>解是不确定的，需要枚举&#x2F;遍历&#x2F;检索以尝试所有可能性。 </li><li>常使用迭代、搜索等算法求解，优化主要为记忆化、剪枝。</li></ul></li></ol><p>所谓枚举，即按照一定顺序，不重复、不遗漏地逐个尝试。 虽然需要消耗大量的时间，但是思路和编程都非常简单，保证可 以取得正确结果。因而往往也被称为暴力（Brute-Force）算法。</p><p>验证复杂的程序的正确性，可写功能一致的暴力对照程序，并构 造小规模输入数据，比较二者输出。 这一过程称作对拍，在赛场上是非常实用的查错技巧。</p><h4 id="1-循环枚举"><a href="#1-循环枚举" class="headerlink" title="1.循环枚举"></a>1.循环枚举</h4><pre><code class="hljs">循环是最简单的枚举方案。 </code></pre><p>几种优化： </p><pre><code class="hljs"> 1. 基于数学的优化 2. 基于剪枝的优化 3. 技巧：打表法</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)<span class="hljs-comment">//宏定义构造语句，简化编码</span></span><br>宏定义只能做简单的字符串替换<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prod(a,b) a*b</span><br><span class="hljs-built_in">prod</span>(a+b,c)编译器会编译为a+b*c而不是(a+b)*c<br>解决方法：定义宏时勤加括号 <span class="hljs-meta">#<span class="hljs-keyword">define</span> prod(a,b) (a)*(b)有效避免出现运算优先级的bug</span><br></code></pre></td></tr></table></figure><p>剪枝：限定每个变量的范围</p><h4 id="2-子集枚举"><a href="#2-子集枚举" class="headerlink" title="2.子集枚举"></a>2.子集枚举</h4><p>每一个元素只有两种状态。联想到二进制。</p><p>用第 i 个二进制位来表达第 i 个元素的取舍。习惯上，1表示选取， 0表示丢弃。那么一个 n 位二进制整数就可以表达 n 个元素的取舍，即：</p><p>25&#x3D;11001&#x3D;{0,3,4}</p><pre><code class="hljs">    取4取3舍2舍1取0</code></pre><p>可用 C++ 自带的位运算符，轻松实现集合的各项运算。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>交集</td><td>交</td><td>x &amp; y</td><td>{0,3,4} ∩ {1,2,3} &#x3D; {3}</td><td>25 &amp; 14 &#x3D; 8</td><td>11001 &amp; 01110 &#x3D; 01000</td></tr><tr><td>并集</td><td>并</td><td>x | y</td><td>{0,3,4} ∪ {1,2,3} &#x3D; {0,1,2,3,4}</td><td>25 |14 &#x3D; 31</td><td>11001 &amp; 01110 &#x3D; 11111</td></tr><tr><td>补集</td><td>对差</td><td>x ^ y</td><td>{0,3,4} ⊕ {1,2,3} &#x3D; {0,1,2,4}</td><td>25 ^ 14 &#x3D; 23</td><td>11001 ^ 01110 &#x3D; 10111</td></tr><tr><td></td><td>补</td><td>((1&lt;&lt;n) - 1) ^ x</td><td>{0,1,2,3,4} – {0,3,4} &#x3D; {1,2}</td><td>31 ^ 25 &#x3D; 6</td><td>11111 ^ 11001 &#x3D; 00110</td></tr><tr><td></td><td>差</td><td>x ^ (x &amp; y)</td><td>{0,3,4} – {1,2,3} &#x3D; {0,4}</td><td>25 ^ 8 &#x3D; 17</td><td>11001 ^ 01000 &#x3D; 10001</td></tr><tr><td>属于</td><td>判定</td><td>(1&lt;&lt;a) &amp; x</td><td>3 ∈ {0,3,4}</td><td>(1&lt;&lt;3)&amp;25 !&#x3D; 0</td><td>01000 &amp; 11001 &#x3D; 01000</td></tr></tbody></table><p>这种二进制表示法又称为“状态压缩”。</p><p>0000011111</p><pre><code class="hljs">    五个元素全 0，S=0五个元素全 1，S=31</code></pre><p>有了二进制表示后，就可以通过 for 循环遍历 0（全0，即空集） </p><p>到 2$ − 1（全 1，即全集）的所有整数，得到所有可能的子集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> U = <span class="hljs-number">1</span> &lt;&lt; n; <span class="hljs-comment">// U = 2^n, U-1即为全集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; U; S++) <span class="hljs-comment">// 枚举所有子集[0,U)</span><br><span class="hljs-keyword">if</span> (<span class="hljs-comment">/*满足题设条件*/</span>) &#123;<br><span class="hljs-comment">// 进行统计</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优点：非常简单方便，集合运算可以基于整数运算 1) 实现。</p><p>限制：元素个数不能太多。一般不超过 20 个。</p><p><code>S&amp;(1&lt;&lt;i)</code>判断第i个元素是否在S中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">举例：<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-keyword">if</span> (S &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) sum += a[i];<br><span class="hljs-comment">// 如果第i个元素在S中，求和</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">is_prime</span>(sum); <span class="hljs-comment">// 质数判定</span><br>&#125;<br><span class="hljs-type">int</span> U = <span class="hljs-number">1</span> &lt;&lt; n; <span class="hljs-comment">// U = 2^n, U-1即为全集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; U; S++) <span class="hljs-comment">// 枚举所有子集[0,U)</span><br><span class="hljs-comment">// 恰好包含k个1 通过质数判定</span><br><span class="hljs-keyword">if</span> (__builtin_popcount(S) == k &amp;&amp; <span class="hljs-built_in">eval</span>(S))<br>ans++; <span class="hljs-comment">// 统计</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">10110</span><br><span class="hljs-number">50320</span><br><span class="hljs-number">10101</span><br><span class="hljs-number">50301</span><br></code></pre></td></tr></table></figure><p>枚举子集的算法时间复杂度是O(1&lt;&lt;n),一般情况下1秒钟可以枚举包含20-30个元素的集合的子集</p><h4 id="3-排列枚举"><a href="#3-排列枚举" class="headerlink" title="3.排列枚举"></a>3.排列枚举</h4><p>排列枚举，顾名思义，就是要求枚举所有元素排列。如果想知道一些元素所有的排序方法，就需要枚举排列。</p><p>全排列问题:进位之后，高位仍然是可以保证不变的。而进位则需要将当前位p替换为后缀中大于p的最小值q。p是大于q的最小元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">next_permutation</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> p, q;<br><span class="hljs-keyword">for</span> (p = n<span class="hljs-number">-1</span>; p &gt;= <span class="hljs-number">1</span> &amp;&amp; a[p] &gt; a[p+<span class="hljs-number">1</span>]; p--); <span class="hljs-comment">// 寻找单减后缀</span><br><span class="hljs-keyword">if</span> (p &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 已经是最后一个排列了</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p+<span class="hljs-number">1</span>, j = n; i &lt;= j; i++, j--)<br><span class="hljs-built_in">swap</span>(a[i], a[j]); <span class="hljs-comment">// 翻转单减后缀为单增</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p+<span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span> (a[i] &gt; a[p]) &#123;q = i; <span class="hljs-keyword">break</span>; &#125; <span class="hljs-comment">// 找到最小大于p的值</span><br><span class="hljs-built_in">swap</span>(a[p], a[q]);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 生成了新的排列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>STL中生成 next_permutation全排列的头文件和函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">//头文件</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">next_permutation</span><span class="hljs-params">(begin, end)</span></span>; <span class="hljs-comment">//函数原型</span><br>和大多数 STL 函数一样，begin 指数组首地址，end 指末地址+<span class="hljs-number">1</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>, a[i]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>生成 next_permutation 的时间复杂度 O(n)。一共有 O(n!) 个可能的排列，总复杂度为O(n×n!)</p><p>枚举所有全排列的算法时间复杂度是O(n!)，一般情况下1秒钟很难枚举超过11个元素的全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">example1:<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)<br>a[i] = i;<br><span class="hljs-keyword">do</span> &#123; <br>x = a[<span class="hljs-number">1</span>] * <span class="hljs-number">100</span> + a[<span class="hljs-number">2</span>] * <span class="hljs-number">10</span> + a[<span class="hljs-number">3</span>];<br>y = a[<span class="hljs-number">4</span>] * <span class="hljs-number">100</span> + a[<span class="hljs-number">5</span>] * <span class="hljs-number">10</span> + a[<span class="hljs-number">6</span>];<br>z = a[<span class="hljs-number">7</span>] * <span class="hljs-number">100</span> + a[<span class="hljs-number">8</span>] * <span class="hljs-number">10</span> + a[<span class="hljs-number">9</span>];<br><span class="hljs-keyword">if</span> (x * B == y * A &amp;&amp; y * C == z * B)<br><span class="hljs-comment">//避免浮点误差和爆long long的小技巧</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, x, y, z), cnt++;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">10</span>));<br><span class="hljs-keyword">if</span> (!cnt)<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No!!!&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="4-builtin函数"><a href="#4-builtin函数" class="headerlink" title="4.builtin函数"></a>4.builtin函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC target (<span class="hljs-string">&quot;popcnt&quot;</span>)</span><br>可以让__builtin_popcount被编译器识别为一条指令，用于加速builtin函数<br></code></pre></td></tr></table></figure><ol><li>__builtin_ffs(x)<br> 返回x的最后一位1是从后向前第几位</li><li>__builtin_clz(x)<br> 返回x的二进制下前导的0的个数</li><li>__builtin_ctz(x)<br> 返回x的二进制下末尾的0的个数</li><li>__builtin_popcount(x)<br> 返回x的二进制下1的个数</li><li>__builtin_parity(x)<br> 返回x的二进制下1的个数的奇偶性</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">__builtin_ffs(x) 返回x的二进制下第一位<span class="hljs-number">1</span>的位置（从<span class="hljs-number">1</span>开始）__builtin_clz(x) 返回x二进制下最高有效位到最高位的<span class="hljs-number">1</span>上一位的长度（即最高位开始连续<span class="hljs-number">0</span>的个数）<br>__builtin_ctz(x) 与上一个函数相反，返回x的二进制下最低位开始连续<span class="hljs-number">0</span>的个数（即第一个函数 - <span class="hljs-number">1</span>）<br>__builtin_parity(x) 返回x二进制下<span class="hljs-number">1</span>的个数的奇偶性__builtin_popcount(x) 返回x二进制下<span class="hljs-number">1</span>的个数<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> __builtin_ffs (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<span class="hljs-comment">//Find the first bit set in x查找一个整数中的第一个置位值 (也就是bit为1的位)</span><br>返回x的最后一位<span class="hljs-number">1</span>的是从后向前第几位，比如<span class="hljs-number">7368</span>（<span class="hljs-number">1110011001000</span>）返回<span class="hljs-number">4</span>。<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-comment">//1</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">8</span>;<span class="hljs-comment">//1000</span><br>cout&lt;&lt;__builtin_ffs(n)&lt;&lt;endl;<span class="hljs-comment">//输出1</span><br>cout&lt;&lt;__builtin_ffs(m)&lt;&lt;endl;<span class="hljs-comment">//输出4</span><br>__builtin_ffs(x)：返回x中最后一个为<span class="hljs-number">1</span>的位是从后向前的第几位，如__builtin_ffs(<span class="hljs-number">0x789</span>)=<span class="hljs-number">1</span>, __builtin_ffs(<span class="hljs-number">0x78c</span>)=<span class="hljs-number">3</span>。于是，__builtin_ffs(x) - <span class="hljs-number">1</span>就是x中最后一个为<span class="hljs-number">1</span>的位的位置。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> __builtin_clz (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<span class="hljs-comment">//Count the number of Leading Zero用于计算最高符号位与第一个1之间的0的个数,返回操作数二进制编码中第一个1前0的个数。如果操作数为0，则指令返回32；如果操作数二进制编码第31位为1，指令返回0。x前导0的个数。x=0时结果未定义。</span><br>返回前导的<span class="hljs-number">0</span>的个数。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> __builtin_ctz (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<span class="hljs-comment">//Count the number of Trailing Zero,x末尾0的个数。x=0时结果未定义。</span><br>返回后面的<span class="hljs-number">0</span>个个数，和__builtin_clz相对。<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-comment">//1</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">8</span>;<span class="hljs-comment">//1000</span><br>cout&lt;&lt;__builtin_ctzll(n)&lt;&lt;endl;<span class="hljs-comment">//输出0</span><br>cout&lt;&lt;__builtin_ctz(m)&lt;&lt;endl;<span class="hljs-comment">//输出3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> __builtin_popcount (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<br>返回二进制表示中<span class="hljs-number">1</span>的个数。<br><span class="hljs-type">int</span> n = <span class="hljs-number">15</span>; <span class="hljs-comment">//二进制为1111</span><br>cout&lt;&lt;__builtin_popcount(n)&lt;&lt;endl;<span class="hljs-comment">//输出4</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> __ibuiltin_parity (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x)<span class="hljs-comment">//奇偶性</span><br>返回x的奇偶校验位，也就是x的<span class="hljs-number">1</span>的个数模<span class="hljs-number">2</span>的结果。x中<span class="hljs-number">1</span>的奇偶性<br><span class="hljs-type">int</span> n = <span class="hljs-number">15</span>;<span class="hljs-comment">//二进制为1111</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">7</span>;<span class="hljs-comment">//111</span><br>cout&lt;&lt;__builtin_parity(n)&lt;&lt;endl;<span class="hljs-comment">//偶数个，输出0</span><br>cout&lt;&lt;__builtin_parity(m)&lt;&lt;endl;<span class="hljs-comment">//奇数个，输出1</span><br></code></pre></td></tr></table></figure><p>此外，这些函数都有相应的<code>usigned long</code>和<code>usigned long long</code>版本，只需要在函数名后面加上l或ll就可以了，比如<code>int __builtin_clzll</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++">实验程序：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">uint32_t</span> g_arr[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, UINT_MAX<span class="hljs-number">-1</span>, UINT_MAX&#125;;<br> <br>string g_str_func[] = &#123;<br>    <span class="hljs-string">&quot;__builtin_ffs&quot;</span>,<br>    <span class="hljs-string">&quot;__builtin_clz&quot;</span>,<br>    <span class="hljs-string">&quot;__builtin_ctz&quot;</span>,<br>    <span class="hljs-string">&quot;__builtin_popcount&quot;</span>,<br>    <span class="hljs-string">&quot;__builtin_parity&quot;</span><br>&#125;;<br> <br><span class="hljs-comment">//typedef int (*fp_builtin_t)(unsigned int);</span><br> <br><span class="hljs-comment">//fp_builtin_t g_func[] = &#123;</span><br>    <span class="hljs-comment">//__builtin_ffs,</span><br>    <span class="hljs-comment">//__builtin_clz,</span><br>    <span class="hljs-comment">//__builtin_ctz,</span><br>    <span class="hljs-comment">//__builtin_popcount,</span><br>    <span class="hljs-comment">//__builtin_parity</span><br><span class="hljs-comment">//&#125;;</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*    for (int k = 0; k &lt; 5; k ++) &#123;</span><br><span class="hljs-comment">        printf(&quot;%s:\n&quot;, g_str_func[k].c_str());</span><br><span class="hljs-comment">        for (int i = 0; i &lt; 12; i ++) &#123;</span><br><span class="hljs-comment">            int t = g_arr[i];</span><br><span class="hljs-comment">            bitset&lt;32&gt; b(t);</span><br><span class="hljs-comment">            fp_builtin_t fp_func = g_func[k];</span><br><span class="hljs-comment">            printf(&quot;%u(%s): %d\n&quot;, t, b.to_string().c_str(), fp_func(t));</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">        puts(&quot;&quot;);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br> <br>        <span class="hljs-comment">// ffs</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:\n&quot;</span>, g_str_func[<span class="hljs-number">0</span>].<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> t = g_arr[i];<br>            <span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u(%s): %d\n&quot;</span>, t, b.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>(), __builtin_ffs(t));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br> <br>        <span class="hljs-comment">// clz</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:\n&quot;</span>, g_str_func[<span class="hljs-number">1</span>].<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> t = g_arr[i];<br>            <span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u(%s): %d\n&quot;</span>, t, b.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>(), __builtin_clz(t));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br> <br>        <span class="hljs-comment">// ctz</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:\n&quot;</span>, g_str_func[<span class="hljs-number">2</span>].<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> t = g_arr[i];<br>            <span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u(%s): %d\n&quot;</span>, t, b.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>(), __builtin_ctz(t));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br> <br>        <span class="hljs-comment">// popcount</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:\n&quot;</span>, g_str_func[<span class="hljs-number">3</span>].<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> t = g_arr[i];<br>            <span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u(%s): %d\n&quot;</span>, t, b.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>(), __builtin_popcount(t));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br> <br>        <span class="hljs-comment">// parity</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:\n&quot;</span>, g_str_func[<span class="hljs-number">4</span>].<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> t = g_arr[i];<br>            <span class="hljs-function">bitset&lt;32&gt; <span class="hljs-title">b</span><span class="hljs-params">(t)</span></span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u(%s): %d\n&quot;</span>, t, b.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>(), __builtin_parity(t));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++">输出样例：<br>__builtin_ffs:<br><span class="hljs-number">0</span>(<span class="hljs-number">00000000000000000000000000000000</span>): <span class="hljs-number">0</span><br><span class="hljs-number">1</span>(<span class="hljs-number">00000000000000000000000000000001</span>): <span class="hljs-number">1</span><br><span class="hljs-number">2</span>(<span class="hljs-number">00000000000000000000000000000010</span>): <span class="hljs-number">2</span><br><span class="hljs-number">3</span>(<span class="hljs-number">00000000000000000000000000000011</span>): <span class="hljs-number">1</span><br><span class="hljs-number">4</span>(<span class="hljs-number">00000000000000000000000000000100</span>): <span class="hljs-number">3</span><br><span class="hljs-number">5</span>(<span class="hljs-number">00000000000000000000000000000101</span>): <span class="hljs-number">1</span><br><span class="hljs-number">6</span>(<span class="hljs-number">00000000000000000000000000000110</span>): <span class="hljs-number">2</span><br><span class="hljs-number">7</span>(<span class="hljs-number">00000000000000000000000000000111</span>): <span class="hljs-number">1</span><br><span class="hljs-number">8</span>(<span class="hljs-number">00000000000000000000000000001000</span>): <span class="hljs-number">4</span><br><span class="hljs-number">9</span>(<span class="hljs-number">00000000000000000000000000001001</span>): <span class="hljs-number">1</span><br><span class="hljs-number">4294967294</span>(<span class="hljs-number">11111111111111111111111111111110</span>): <span class="hljs-number">2</span><br><span class="hljs-number">4294967295</span>(<span class="hljs-number">11111111111111111111111111111111</span>): <span class="hljs-number">1</span><br> <br>__builtin_clz:<br><span class="hljs-number">0</span>(<span class="hljs-number">00000000000000000000000000000000</span>): <span class="hljs-number">31</span><br><span class="hljs-number">1</span>(<span class="hljs-number">00000000000000000000000000000001</span>): <span class="hljs-number">31</span><br><span class="hljs-number">2</span>(<span class="hljs-number">00000000000000000000000000000010</span>): <span class="hljs-number">30</span><br><span class="hljs-number">3</span>(<span class="hljs-number">00000000000000000000000000000011</span>): <span class="hljs-number">30</span><br><span class="hljs-number">4</span>(<span class="hljs-number">00000000000000000000000000000100</span>): <span class="hljs-number">29</span><br><span class="hljs-number">5</span>(<span class="hljs-number">00000000000000000000000000000101</span>): <span class="hljs-number">29</span><br><span class="hljs-number">6</span>(<span class="hljs-number">00000000000000000000000000000110</span>): <span class="hljs-number">29</span><br><span class="hljs-number">7</span>(<span class="hljs-number">00000000000000000000000000000111</span>): <span class="hljs-number">29</span><br><span class="hljs-number">8</span>(<span class="hljs-number">00000000000000000000000000001000</span>): <span class="hljs-number">28</span><br><span class="hljs-number">9</span>(<span class="hljs-number">00000000000000000000000000001001</span>): <span class="hljs-number">28</span><br><span class="hljs-number">4294967294</span>(<span class="hljs-number">11111111111111111111111111111110</span>): <span class="hljs-number">0</span><br><span class="hljs-number">4294967295</span>(<span class="hljs-number">11111111111111111111111111111111</span>): <span class="hljs-number">0</span><br> <br>__builtin_ctz:<br><span class="hljs-number">0</span>(<span class="hljs-number">00000000000000000000000000000000</span>): <span class="hljs-number">0</span><br><span class="hljs-number">1</span>(<span class="hljs-number">00000000000000000000000000000001</span>): <span class="hljs-number">0</span><br><span class="hljs-number">2</span>(<span class="hljs-number">00000000000000000000000000000010</span>): <span class="hljs-number">1</span><br><span class="hljs-number">3</span>(<span class="hljs-number">00000000000000000000000000000011</span>): <span class="hljs-number">0</span><br><span class="hljs-number">4</span>(<span class="hljs-number">00000000000000000000000000000100</span>): <span class="hljs-number">2</span><br><span class="hljs-number">5</span>(<span class="hljs-number">00000000000000000000000000000101</span>): <span class="hljs-number">0</span><br><span class="hljs-number">6</span>(<span class="hljs-number">00000000000000000000000000000110</span>): <span class="hljs-number">1</span><br><span class="hljs-number">7</span>(<span class="hljs-number">00000000000000000000000000000111</span>): <span class="hljs-number">0</span><br><span class="hljs-number">8</span>(<span class="hljs-number">00000000000000000000000000001000</span>): <span class="hljs-number">3</span><br><span class="hljs-number">9</span>(<span class="hljs-number">00000000000000000000000000001001</span>): <span class="hljs-number">0</span><br><span class="hljs-number">4294967294</span>(<span class="hljs-number">11111111111111111111111111111110</span>): <span class="hljs-number">1</span><br><span class="hljs-number">4294967295</span>(<span class="hljs-number">11111111111111111111111111111111</span>): <span class="hljs-number">0</span><br> <br>__builtin_popcount:<br><span class="hljs-number">0</span>(<span class="hljs-number">00000000000000000000000000000000</span>): <span class="hljs-number">0</span><br><span class="hljs-number">1</span>(<span class="hljs-number">00000000000000000000000000000001</span>): <span class="hljs-number">1</span><br><span class="hljs-number">2</span>(<span class="hljs-number">00000000000000000000000000000010</span>): <span class="hljs-number">1</span><br><span class="hljs-number">3</span>(<span class="hljs-number">00000000000000000000000000000011</span>): <span class="hljs-number">2</span><br><span class="hljs-number">4</span>(<span class="hljs-number">00000000000000000000000000000100</span>): <span class="hljs-number">1</span><br><span class="hljs-number">5</span>(<span class="hljs-number">00000000000000000000000000000101</span>): <span class="hljs-number">2</span><br><span class="hljs-number">6</span>(<span class="hljs-number">00000000000000000000000000000110</span>): <span class="hljs-number">2</span><br><span class="hljs-number">7</span>(<span class="hljs-number">00000000000000000000000000000111</span>): <span class="hljs-number">3</span><br><span class="hljs-number">8</span>(<span class="hljs-number">00000000000000000000000000001000</span>): <span class="hljs-number">1</span><br><span class="hljs-number">9</span>(<span class="hljs-number">00000000000000000000000000001001</span>): <span class="hljs-number">2</span><br><span class="hljs-number">4294967294</span>(<span class="hljs-number">11111111111111111111111111111110</span>): <span class="hljs-number">31</span><br><span class="hljs-number">4294967295</span>(<span class="hljs-number">11111111111111111111111111111111</span>): <span class="hljs-number">32</span><br> <br>__builtin_parity:<br><span class="hljs-number">0</span>(<span class="hljs-number">00000000000000000000000000000000</span>): <span class="hljs-number">0</span><br><span class="hljs-number">1</span>(<span class="hljs-number">00000000000000000000000000000001</span>): <span class="hljs-number">1</span><br><span class="hljs-number">2</span>(<span class="hljs-number">00000000000000000000000000000010</span>): <span class="hljs-number">1</span><br><span class="hljs-number">3</span>(<span class="hljs-number">00000000000000000000000000000011</span>): <span class="hljs-number">0</span><br><span class="hljs-number">4</span>(<span class="hljs-number">00000000000000000000000000000100</span>): <span class="hljs-number">1</span><br><span class="hljs-number">5</span>(<span class="hljs-number">00000000000000000000000000000101</span>): <span class="hljs-number">0</span><br><span class="hljs-number">6</span>(<span class="hljs-number">00000000000000000000000000000110</span>): <span class="hljs-number">0</span><br><span class="hljs-number">7</span>(<span class="hljs-number">00000000000000000000000000000111</span>): <span class="hljs-number">1</span><br><span class="hljs-number">8</span>(<span class="hljs-number">00000000000000000000000000001000</span>): <span class="hljs-number">1</span><br><span class="hljs-number">9</span>(<span class="hljs-number">00000000000000000000000000001001</span>): <span class="hljs-number">0</span><br><span class="hljs-number">4294967294</span>(<span class="hljs-number">11111111111111111111111111111110</span>): <span class="hljs-number">1</span><br><span class="hljs-number">4294967295</span>(<span class="hljs-number">11111111111111111111111111111111</span>): <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h4><p>求解问题 在若干种选项中，寻找可行解&#x2F;最优解的问题。</p><p><font color=LightSalmon>暴力枚举</font> 遍历所有选项解决求解问题的手段。</p><p>循环枚举 数学优化，剪枝优化，打表法</p><p>子集枚举 二进制状态压缩，<code>__builtin_popcount </code></p><p>排列枚举 排列生成算法，<code>next_permutation</code></p><h3 id="4-递推与递归"><a href="#4-递推与递归" class="headerlink" title="4.递推与递归"></a>4.递推与递归</h3><h4 id="1-递推思想"><a href="#1-递推思想" class="headerlink" title="1.递推思想"></a>1.递推思想</h4><p>知道递推式，也知道初始条件，从初始条件开始往上顺推直到求得目标解的思想就是递推</p><p>技巧：只保留第i行和第i-1行的答案,取模</p><p><code>i%2≠(i-1)%2``x%2==x&amp;1</code></p><p>如果<em>x</em> 是偶数，那么<em>x</em> &amp; 1&#x3D;0，如果 <em>x</em> 是奇数，那么<em>x</em> &amp; 1&#x3D;1。</p><p>当就某个问题能写出递推式、能确定初始(边界)条件，那么可以考虑使用递推。对于某些数据规模很大的递推任务可以使用矩阵加速提升效率。</p><h4 id="2-递归思想"><a href="#2-递归思想" class="headerlink" title="2.递归思想"></a>2.递归思想</h4><p>构造函数，这个函数在运行过程中调用自己，从而解决问题的思路被称为递归思想</p><p>一旦计算完成就会被存下来，便于日后使用。这样的思想被称为记忆化搜索</p><p>有的情况下进行递推，需要求出初始条件，还需要确定递推顺序、所以这时使用递归思想会容易一些</p><p>例 11.6 外星密码 (洛谷 P1928）</p><p>有一种压缩字符串的方式：对于连续的 D(2 ≤ ≤ 99) 个相同的子串 X 会压缩为 “[DX]” 的形式，而 X 可能可以进行进一步的压缩。 </p><p>比如说字符串 CBCBCBCB 可以压缩为[4CB]或者[2[2CB]]。 现给出压缩后的字符串，求压缩前的字符串原文。</p><p>[2[2CB]] &#x3D; [2CB][2CB] &#x3D; CBCBCBCB</p><p>分析：假设只有一层方括号，那只需要找到方括号，就可以将该部分还原。</p><p>如果方括号的“重复部分”里还有方括号呢？没关系，设法把里面的方括号继续展开即可。因此可以写成递归函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">expand</span><span class="hljs-params">()</span> </span>&#123;<br>string s = <span class="hljs-string">&quot;&quot;</span>, X;<br><span class="hljs-type">char</span> c; <span class="hljs-type">int</span> D;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; c) &#123;<span class="hljs-comment">// 持续读入字符，直到全部读完</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123; <span class="hljs-comment">// 发现一个压缩区</span><br>cin &gt;&gt; D; <span class="hljs-comment">// 读入D X = expand(); // 递归地读入X</span><br><span class="hljs-keyword">while</span> (D--) s += X; <span class="hljs-comment">// 重复D次X并进行拼接</span><br><span class="hljs-comment">// 上面不能写成while (n--) s+=read();</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>)<br><span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 压缩区结束，返回已经处理好的X</span><br><span class="hljs-keyword">else</span> s += c; <span class="hljs-comment">// 如果不是&#x27;[&#x27;和&#x27;]&#x27;，那还是X的字符，加进去即可</span><br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">expand</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>如果能将一个大的任务分解成若干规模较小的任务，而且这些任务的形式与结构和原问题一致，就可以考虑使用递归。当问题规模足够小或者到达了边界条件就要停止递归。分解完问题后还要对这些规模小的任务合并然后返回解，最后逐级上报，解决最大规模的问题。有些问题使用递推策略和递归策略都能解决，但有些问题只能将大问题分割成小问题，但是却很难建立递推式，在这种情况下应当使用递归策略。</p><h4 id="3-总结："><a href="#3-总结：" class="headerlink" title="3.总结："></a>3.总结：</h4><p>递推：需要确定递推式、初始（边界）条件，从微观到宏观。</p><p>递归：将一个大的任务分解成若干个规模较小的任务，而且这些任务的 形式与结构和原问题一致，然后将结果合并，直到达到边界。 </p><p>有些问题使用递推策略和递归策略都能解决，但有些问题只能将大问题分割成小问题，但是却很难建立递推式，或者不好确定递推顺序，这种情况下应当使用递归策略。</p><p>但递归需要记录每一层的状态，因此可能会比较占用空间。</p><h3 id="5-贪心"><a href="#5-贪心" class="headerlink" title="5.贪心"></a>5.贪心</h3><h4 id="1-贪心与证明"><a href="#1-贪心与证明" class="headerlink" title="1.贪心与证明"></a>1.贪心与证明</h4><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响到以后的状态，只与当前状态有关。首先需要证明贪心策略是正确的，才可以考虑使用贪心算法解决该问题。在很多情况下，贪心的合理性并不是显然的，但如果能找到一个反例，就可以证明这样的贪心不正确。</p><h5 id="部分背包问题："><a href="#部分背包问题：" class="headerlink" title="部分背包问题："></a>部分背包问题：</h5><p>有n堆金币，第i堆金币的总重量和总价值分别是m,v。<br>阿里巴巴有一个承重量为 T(T ≤ 1000) 的背包，但无法将全部的金币都装进去。他想装走尽可能多价值的金币<br>所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。<br><strong>从单价高的开始装，装到不能装为止</strong></p><p>证明：</p><ol><li><p>所有的东西价值都是正的，因此只要金币总数足够，背包就必须要装满而不能留空；</p></li><li><p>（反证法）假设没在背包中放入单价高的金币，而放入了单价低的金币，那么可用等重量的高价值金币替换掉背包里的低价值金币，总价值更高了。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//为了方便排序，定义了coin结构体来存储金币堆的重量和价值——性价比不需要存下来，而是在调用sort的时候进行判断</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">coin</span> &#123;<br><span class="hljs-type">int</span> m, v; <span class="hljs-comment">// 金币堆的重量和价值</span><br>&#125; a[<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(coin x, coin y)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x.v*y.m &gt; y.v*x.m;<span class="hljs-comment">//判断单价</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, t, c, i; <br>    <span class="hljs-type">float</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);<br>c = t; <span class="hljs-comment">// 背包的剩余容量</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a[i].m, &amp;a[i].v);<br><span class="hljs-built_in">sort</span>(a, a + n, cmp); <span class="hljs-comment">// 对单价排序</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (a[i].m &gt; c) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果不能完整装下就跳出</span><br>c -= a[i].m;<br>ans += a[i].v; <br>    &#125;<br><span class="hljs-keyword">if</span> (i &lt; n)<br>ans += <span class="hljs-number">1.0</span> * c / a[i].m * a[i].v;<span class="hljs-comment">// 剩余空间装下部分金币</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>这就是证明贪心的第一种方法——假设要选择的方案不是贪心算法所要求的方案，只需要证明将需要贪心的方案替换掉要选择方案，结果会更好（至少不会更差）。</p><p>如果藏宝洞里面不是一堆堆金币，而是一个个单价不一且无法分割的金块，还能使用类似的策略吗？</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220219214533149.png" alt="image-20220219214533149"></p><p>(a) 是可分割金币的装包方案，通过贪心策略使利益最大化。 </p><p>(b) 然而使用同样的办法装包，非最优解</p><p>(c) 战略性放弃性价比最高的金块可能会让你获得更多。</p><p>仅仅举出了一个反例就推翻了一个错误的贪心算法，可见使用贪心策略时要特别注意正确性</p><p><strong>贪心需要证明正确性！</strong></p><p>一般用两种办法证明贪心成立。</p><ol><li><p>反证法：假设所选方案非贪心算法所要求的方案，只需要证明将需要贪心的方案替换掉所选方案，结果会更好（至少不会更差）</p></li><li><p>数学归纳法：每一步的选择都是到当前为止的最优解，一直到最后一步就成为了全局的最优解。</p></li></ol><p>可以大胆猜想贪心策略，但要保证正确性（最好能严格证明）推翻贪心：只需要找到一个反例！</p><h4 id="2-哈夫曼编码"><a href="#2-哈夫曼编码" class="headerlink" title="2.哈夫曼编码"></a>2.哈夫曼编码</h4><p>使用memset初始化int数组时，第二个参数如果是0，数组就会被初始化为0；如果是127，会初始化为一个很大且接近int类型上限的正数；如果是128，会初始化成很小且接近int类型下限的负数，如果是-1或者255时，数组会初始化为-1</p><h4 id="3-总结：-1"><a href="#3-总结：-1" class="headerlink" title="3.总结："></a>3.总结：</h4><ol><li><p>贪心算法</p><p>每一步都选择最优策略，结果也可以最优。</p><p>大胆假设，小心求证。找到一组反例就可以推翻贪心！</p><p>证明：反证法、数学归纳法。</p></li><li><p>哈夫曼编码</p><p>一般用于压缩编码，可以使编码变短。</p><p>从数量最少的元素开始合并建立哈夫曼树。</p><p>使用两个队列维护最小的两个元素</p></li></ol><h3 id="6-二分查找与二分答案"><a href="#6-二分查找与二分答案" class="headerlink" title="6.二分查找与二分答案"></a>6.二分查找与二分答案</h3><h4 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;r=n+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-comment">//最后l和r会相等</span><br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//有时l+r可能会超过int类型的极限，可以避免运算溢出</span><br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=x)&#123;<br>            r=mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>STL中lower_bound()和upper_bound()</p><p>头文件<algorithm></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">从小到大的数组中：<br><span class="hljs-built_in">lower_bound</span>(begin,end,val)：在值有序的数组连续地址[begin,end)中找到第一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序<br><span class="hljs-built_in">upper_bound</span>(begin,end,val)：在值有序的数组连续地址[begin,end)中找到最后一个位置并返回其地址，使得val插入在这个位置前面，整个数组仍然保持有序<br>假如排序后的数组名为a，可以认为其返回值减去数组名<span class="hljs-built_in">a</span>(其实等于a[<span class="hljs-number">0</span>])刚好等于所要找的元素的数组下标<br>从大到小的数组中：<br><span class="hljs-built_in">lower_bound</span>(a,a+n+<span class="hljs-number">1</span>,x,greater&lt;<span class="hljs-type">int</span>&gt;);<br>greater&lt;<span class="hljs-type">int</span>&gt;从大到小排序<br>less&lt;<span class="hljs-type">int</span>&gt;从小到大排序<br>greater和less在头文件&lt;functional&gt;中<br><br>lower_bound会找出序列中第一个大于等于x的数<br><br>upper_bound会找出序列中第一个大于x的数<br></code></pre></td></tr></table></figure><p>例：A-B数对，给出一个数列以及一个数字C，要求计算出所有A-B&#x3D;C的数对的个数。</p><p>分析：如果决定枚举A，那么问题变成了统计数列中B+C出现了多少次。把数列排序，那么B+C会对应这个数列的连续一段，只要能快速找到这个连续段的左端点和右端点，也就是B+C在有序数列中第一次出现和最后一次出现的位置。</p><table><thead><tr><th>数组</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>原输入</td><td>7</td><td>3</td><td>4</td><td>3</td><td>3</td><td>3</td><td>7</td><td>4</td></tr><tr><td>排序后</td><td>3</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>7</td><td>7</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 200010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-comment">//把long long 替换成LL节约打字时间</span><br>LL a[MAXN];<br><span class="hljs-type">int</span> n,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a,a+n);<br>    LL tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        tot+=<span class="hljs-built_in">upper_bound</span>(a,a+n,a[i]+c)-<span class="hljs-built_in">lower_bound</span>(a,a+n,a[i]+c);<br>        <span class="hljs-comment">//lower_bound(a,a+n,a[i]+c+1)和upper_bound(a,a+n,a[i]+c)是等价的</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,tot);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">排序后<span class="hljs-built_in">O</span>(n)的做法：寻找<span class="hljs-built_in">lower_bound</span>()和<span class="hljs-built_in">upper_bound</span>()的位置，可以发现随着被查询的a[i]+c的增大,lower_bound和upper_bound的位置也在变后，可以把这两个位置维护出来，即随着a[i]+c的增大而向后移动，因为这两个指针移动的次数不超过n，所以这个算法是<span class="hljs-built_in">O</span>(n)的。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 200010;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>LL a[maxn];<br><span class="hljs-type">int</span> n,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a,a+n);<br>    LL tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,L=<span class="hljs-number">0</span>,R=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">while</span>(L&lt;n &amp;&amp; a[L]&lt;a[i]+c)&#123;<br>            L++;<span class="hljs-comment">//L相当于lower_bound，即第一个a[L]&gt;=a[i]+c的位置</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(R&lt;n &amp;&amp; a[R]&gt;a[i]+c)&#123;<br>            R++;<span class="hljs-comment">//R相当于upper_bound，即第一个a[L]&gt;a[i]+c的位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lower_bound</span>(a,a+n,<span class="hljs-number">3</span>)-a=<span class="hljs-number">0</span>,<span class="hljs-built_in">lower_bound</span>(a,a+n,<span class="hljs-number">7</span>)-a=<span class="hljs-number">6</span>;<br><span class="hljs-built_in">upper_bound</span>(a,a+n,<span class="hljs-number">3</span>)-a=<span class="hljs-number">4</span>,<span class="hljs-built_in">upper_bound</span>(a,a+n,<span class="hljs-number">7</span>)-a=<span class="hljs-number">8</span>;<br>出现次数=<span class="hljs-built_in">upper_bound</span>()-<span class="hljs-built_in">lower_bound</span>();<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100000</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">2</span>*<span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span>)+<span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> num[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">15</span>,<span class="hljs-number">34</span>&#125;; <br><span class="hljs-built_in">sort</span>(num,num+<span class="hljs-number">6</span>);                           <span class="hljs-comment">//按从小到大排序 </span><br><span class="hljs-type">int</span> pos1=<span class="hljs-built_in">lower_bound</span>(num,num+<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)-num;    <span class="hljs-comment">//返回数组中第一个大于或等于被查数的值 </span><br><span class="hljs-type">int</span> pos2=<span class="hljs-built_in">upper_bound</span>(num,num+<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)-num;    <span class="hljs-comment">//返回数组中第一个大于被查数的值</span><br>cout&lt;&lt;pos1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[pos1]&lt;&lt;endl;<br>cout&lt;&lt;pos2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[pos2]&lt;&lt;endl;<br><span class="hljs-built_in">sort</span>(num,num+<span class="hljs-number">6</span>,cmd);                      <span class="hljs-comment">//按从大到小排序</span><br><span class="hljs-type">int</span> pos3=<span class="hljs-built_in">lower_bound</span>(num,num+<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())-num;  <span class="hljs-comment">//返回数组中第一个小于或等于被查数的值 </span><br><span class="hljs-type">int</span> pos4=<span class="hljs-built_in">upper_bound</span>(num,num+<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())-num;  <span class="hljs-comment">//返回数组中第一个小于被查数的值 </span><br>cout&lt;&lt;pos3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[pos3]&lt;&lt;endl;<br>cout&lt;&lt;pos4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;num[pos4]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-二分答案"><a href="#2-二分答案" class="headerlink" title="2.二分答案"></a>2.二分答案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<span class="hljs-comment">//使用前确保答案在[L,R]内</span><br>    <span class="hljs-type">int</span> ans,mid;<br>    <span class="hljs-keyword">while</span>(L&lt;=R)&#123;<span class="hljs-comment">//闭区间上的二分结束条件</span><br>        <span class="hljs-type">int</span> mid=L+R&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">P</span>(mid))&#123;<span class="hljs-comment">//条件成立</span><br>            ans=mid,R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//这里只需要记录满足条件的mid，最后循环一定会结束，也一定会在ans中保留正确的答案</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//L和R不用仔细考虑+1、-1，全都写上去</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<span class="hljs-comment">//ans=R-1;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>二分答案的算法复杂度时O(logn)</p><p>使用二分答案技巧的条件：</p><ol><li><p>命题可以被归纳为找到使得某命题P(x)成立(或不成立)的最大(或最小)的x;</p></li><li><p>把P(x)看作一个值为真或假的函数，那么它一定在某个分界线的一侧全为真，另一侧全为假;</p></li><li><p>可以找到一个复杂度优秀的算法来检验P(x)的真假</p><p><strong>二分答案可以用来处理“最大的最小”或“最小的最大”问题</strong></p></li></ol><p>二分的次数和精度有关，考虑每次二分的区间都可以减小一半，因此是对数级别。与整数区间二分不同，实数区间上的二分需要确认好精度。</p><h5 id="3-总结：-2"><a href="#3-总结：-2" class="headerlink" title="3.总结："></a>3.总结：</h5><h3 id="7-搜索"><a href="#7-搜索" class="headerlink" title="7.搜索"></a>7.搜索</h3><p>在更复杂的问题中，状态无法简单用单一变量表示。</p><p>同时，当数据范围扩大时，即便问题本质上仍为子集（指数）枚举或排列（阶乘）枚举，但很多状态是无效的。</p><p>搜索，是一种具有策略的枚举法。它许利用数据结构表示状态，并借此更有针对性地剪枝，从而求解传统枚举难以解决的问题。</p><h4 id="1-深度优先搜索与回溯法"><a href="#1-深度优先搜索与回溯法" class="headerlink" title="1.深度优先搜索与回溯法"></a>1.深度优先搜索与回溯法</h4><p>传统枚举中需要固定for循环的层数，会造成程序非常冗长，而且不能随意增减枚举层数。</p><p>利用函数递归枚举，枚举每一个填空中所有可能的选项，然后判断这种选项是否合法。如果这个选项合法的话就填写下一个选项，然后继续；如果这个填空中所有的选项都不合法，那就不用继续枚举下去了，而是去尝试更换上一个填空的选项，继续枚举。这种方式被称为<strong>回溯算法</strong>，常使用<strong>深度优先搜索</strong>来实现。</p><p>回溯法往往会尝试一条尽可能深而完整的搜索路线，直至完全无法继续递归时才回溯，因而需要用<strong>深度优先搜索（DFS）</strong>实现</p><p>减少浪费 &#x3D; 尽早剪枝</p><p>回溯算法的一般形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//k代表递归层数，或者说要填第几个空</span><br><span class="hljs-keyword">if</span>(所有空已经填完了)&#123;<br>        判断最优解/记录答案;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(枚举这个空能填的选项)<br>        <span class="hljs-keyword">if</span>(这个选项是合法的)&#123;<br>            记录下这个空(保存现场)；<br>            <span class="hljs-built_in">dfs</span>(k+<span class="hljs-number">1</span>);<br>            取消这个空(恢复现场)<br>        &#125;<br>&#125;<br>算法竞赛中，如果无法找到高效求解的方法（如贪心、递推、动态规划、公式推导等），使用搜索也可以解决一些规模较小的情况。<br>但不管怎么说，时间复杂度往往是指数级别的，效率相比于多项式时间复杂度还是要低。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 第x个空填什么</span><br><span class="hljs-keyword">if</span> (x &gt; n) &#123; <span class="hljs-comment">// 如果所有空已经填满</span><br>ans++; <span class="hljs-comment">// 增加结果数量</span><br><span class="hljs-keyword">return</span>; <br>&#125;<br><span class="hljs-comment">// 根据x计算出所在行、列、小块编号</span><br><span class="hljs-type">int</span> row = (x - <span class="hljs-number">1</span>) / <span class="hljs-number">4</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 横行编号</span><br><span class="hljs-type">int</span> col = (x - <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 竖排编号</span><br><span class="hljs-type">int</span> block = (row - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * <span class="hljs-number">2</span> + (col - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 小块编号</span><br><span class="hljs-comment">// 枚举所填内容为i</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++)<br><span class="hljs-keyword">if</span> (b1[row][i] == <span class="hljs-number">0</span> &amp;&amp; b2[col][i] == <span class="hljs-number">0</span> &amp;&amp; b3[block][i] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 合法性判断</span><br>a[x] = i; <span class="hljs-comment">// 记录放置位置</span><br>b1[row][i] = <span class="hljs-number">1</span>; b2[col][i] = <span class="hljs-number">1</span>; b3[block][i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 占位</span><br><span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一层递归</span><br>b1[row][i] = <span class="hljs-number">0</span>; b2[col][i] = <span class="hljs-number">0</span>; b3[block][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 取消占位</span><br>&#125; <br>&#125;<br>计算机运行函数时，为每一个子函数都分配了一片栈空间，专门用于存储每一层递归函数的信息，包括每层函数的各个局部变量的值。<br></code></pre></td></tr></table></figure><p>遇到了需要枚举排序的时候，搜索回溯会很好用。不需要生成所有的序列全排列，而是一个一个地填空，保证填空的时候序列是合法的，这样就可以不用枚举很多无效序列，节约程序运行时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn], n, ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b1[maxn], b2[maxn], b3[maxn];<br><span class="hljs-comment">// 分别记录y,x+y,x-y+15是否被占用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 第x行的皇后放哪儿</span><br><span class="hljs-keyword">if</span> (x &gt; n) &#123; <span class="hljs-comment">// 如果所有皇后已经放置</span><br>ans++; <span class="hljs-comment">// 增加结果数量</span><br><span class="hljs-keyword">if</span> (ans &lt;= <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 输出前三种答案</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span>; <br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span> (b1[i] == <span class="hljs-number">0</span> &amp;&amp; b2[x + i] == <span class="hljs-number">0</span> &amp;&amp; b3[x - i + <span class="hljs-number">15</span>] == <span class="hljs-number">0</span>) &#123; a[x] = i; <span class="hljs-comment">// 记录放置位置</span><br>b1[i] = <span class="hljs-number">1</span>; b2[x + i] = <span class="hljs-number">1</span>; b3[x - i + <span class="hljs-number">15</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 占位</span><br><span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一层递归</span><br>b1[i] = <span class="hljs-number">0</span>; b2[x + i] = <span class="hljs-number">0</span>; b3[x - i + <span class="hljs-number">15</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 取消占位</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &gt; maxdeep)&#123; <span class="hljs-comment">// 所有作业枚举完毕，达到了最大递归层数</span><br>maxtime = <span class="hljs-built_in">max</span>(maxtime, nowtime); <span class="hljs-comment">// 如果解更优，更新答案。</span><br><span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-keyword">if</span>(nowtime + a[x] &lt;= sum / <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 如果放入这个作业是合法的，选择它</span><br>nowtime += a[x]; <span class="hljs-comment">// 增加子集中这道题目的时间</span><br><span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一层递归</span><br>nowtime -= a[x]; <span class="hljs-comment">// 去除掉子集中这道题目的时间</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>); <span class="hljs-comment">// 不选这个题目，直接进行下一层递归</span><br>&#125;<br>可以换位思考：不仅可以为每一个集合选择元素，亦可以为每一个元素选择集合。<br></code></pre></td></tr></table></figure><p>对于一些枚举或者枚举子集的问题，可以使用搜索回溯来解决。但如果需要枚举的元素比较多（超过十几个），即使是搜索回溯也相当慢，可以使用动态规划的背包问题模型更高效地解决本题。</p><h4 id="2-广度优先搜索与洪泛法"><a href="#2-广度优先搜索与洪泛法" class="headerlink" title="2.广度优先搜索与洪泛法"></a>2.广度优先搜索与洪泛法</h4><p>深度优先搜索会优先考虑搜索的深度。不找到一个答案不回头。当答案在整棵解答树中比较稀疏时，深度优先搜索可能会先陷入过深的情况，找不到解。有时候需要解决连通性、最短路问题时，可以考虑使用广度优先搜索。</p><p>洪泛法：</p><p>深搜会尽快完成一个可行的解，再回溯尝试其他的可能性。当解相对稀疏，或问题很大时，深搜可能陷入过深、过窄的“陷阱”。</p><p>考虑另一种思路，从起点出发，类似于泼水一般，让水流顺着多个方向同时蔓延。这种方法被称为洪泛法。</p><p>洪泛法会扩展相同层更多的可能性以拓宽广度，往往会使用广度优先搜索（BFS）实现。</p><p>广度优先搜索会优先考虑每种状态的和初始状态的距离，与初始状态越接近的情况就会越先考虑。</p><p>广度优先搜索使用队列实现：先将初始状态加入到空的队列中，然后每次取出队首，找出队首所能转移到的状态，再将其压入队列；如此反复，直到队列为空。这样就能保证一个状态在被访问的时候一定是采用的最短路径。</p><p>广度优先搜索的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">Q.<span class="hljs-built_in">push</span>(初始状态); <span class="hljs-comment">// 将初始状态入队</span><br><span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>State u = Q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首</span><br>Q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队</span><br><span class="hljs-keyword">for</span> (枚举所有可扩展状态) <span class="hljs-comment">// 找到u的所有可达状态v</span><br><span class="hljs-keyword">if</span> (是合法的) <span class="hljs-comment">// v需要满足某些条件，如未访问过、未在队内等</span><br>Q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">// 入队（同时可能需要维护某些必要信息）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>广度优先搜索可以保证在求解最近、最短、最快等一类问题时，搜索到的首个解就是最优解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">使用 STL 的 queue 实现队列。建立结构体数组存储扩展的结点。 让起点入队，然后在队列逐个扩展。每个点被扩展到时步数最小。<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">coord</span> &#123; <span class="hljs-comment">//一个结构体存储x,y两个坐标</span><br><span class="hljs-type">int</span> x, y;<br>&#125;;<br>queue&lt;coord&gt; Q;<span class="hljs-comment">//队列</span><br><span class="hljs-type">int</span> ans[maxn][maxn];<span class="hljs-comment">//记录答案，-1表示未访问</span><br><span class="hljs-type">int</span> walk[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;<br>coord tmp = &#123;sx, sy&#125;;<br>Q.<span class="hljs-built_in">push</span>(tmp); <span class="hljs-comment">// 使起点入队扩展</span><br>ans[sx][sy] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 循环直到队列为空</span><br>coord u = Q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 拿出队首以扩展</span><br><span class="hljs-type">int</span> ux = u.x, uy = u.y;<br>    Q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++) &#123;<br><span class="hljs-type">int</span> x = ux + walk[k][<span class="hljs-number">0</span>], y = uy + walk[k][<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> d = ans[ux][uy];<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || x &gt; n || y &lt; <span class="hljs-number">1</span> || y &gt; m || ans[x][y] != <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 若坐标超过地图范围或者该点已被访问过则无需入队</span><br>ans[x][y] = d + <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录答案，是上一个点多走一步的结果。</span><br>coord tmp = &#123;x, y&#125;;<br>Q.<span class="hljs-built_in">push</span>(tmp);<br>&#125; <br>&#125;<br>因为每个点只被扩展一次，故复杂度是 <span class="hljs-built_in">O</span>(mn) 。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> floor, d; <span class="hljs-comment">//队列中记录的层数和按钮次数</span><br>&#125;;<br>queue&lt;node&gt; Q; <span class="hljs-comment">// 广度优先搜索的队列</span><br>Q.<span class="hljs-built_in">push</span>((node)&#123;a, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">//将初始元素加入到队列</span><br>vis[a] = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录初始楼层已访问过</span><br>node now;<br><span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>now = Q.<span class="hljs-built_in">front</span>();<br>Q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (now.floor == b) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到目标解</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sign = <span class="hljs-number">-1</span>; sign &lt;= <span class="hljs-number">1</span>; sign += <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// sign枚举-1和1</span><br><span class="hljs-type">int</span> dist = now.floor + k[now.floor] * sign; <span class="hljs-comment">// 目标楼层，sign为1是上</span><br><span class="hljs-keyword">if</span> (dist &gt;= <span class="hljs-number">1</span> &amp;&amp; dist &lt;= n &amp;&amp; vis[dist]==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 如果按按钮能到达的楼层有效并且未访问过该楼层</span><br>Q.<span class="hljs-built_in">push</span>((node)&#123;dist, now.d + <span class="hljs-number">1</span>&#125;);<br>vis[dist] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 该楼层为已访问过</span><br>&#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">if</span> (now.floor == b) <span class="hljs-comment">// 找到目标解</span><br>cout &lt;&lt; now.d &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 无法到达</span><br>cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>广度优先搜索从起点开始，以此拓展。先枚举完所有近处的结点，然后再依次拓展比较远的结点，而不是如同深度优先搜索一样一直往前走。基于这个特性，广度优先搜索可以找到步骤最少，距离最近的解，代价是必须使用队列来存储所有的结点信息，占用比较多的内存空间。</p><p>深度优先搜索寻找操作步骤字典序最小的解，而广度优先搜索可以找到步骤最少的解。</p><h4 id="3-总结：-3"><a href="#3-总结：-3" class="headerlink" title="3.总结："></a>3.总结：</h4><p>回溯法&#x2F;深度优先搜索（下图 a）</p><pre><code class="hljs">快速构造解，使用递归。不撞南墙心不死。但进入死路就回头了。</code></pre><p>洪泛法&#x2F;广度优先搜索（下图 b）</p><pre><code class="hljs">寻找最优解，使用队列从起点开始，逐层往外扩展。</code></pre><p>优化技巧：将不可能的解提前剪掉。</p><p>万能头文件：#include&lt;bits&#x2F;stdc++.h&gt;</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220228170915810.png" alt="image-20220228170915810"></p><p>综合深度优先和广度优先的长处，还有：</p><p>• 迭代加深深搜：行为上类似广搜，但仅需要深搜的空间；代价是较浅的层需要被反复搜索。</p><p>• 迭代增广广搜：行为上类似深搜，但如果策略合理，有几率快速寻找到最优答案；代价是策略失效时需要更多的查找。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.基础数论</title>
    <link href="/2022/04/20/4-%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"/>
    <url>/2022/04/20/4-%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="基础数学与数论"><a href="#基础数学与数论" class="headerlink" title="基础数学与数论"></a>基础数学与数论</h1><h3 id="1-位运算与进制转换"><a href="#1-位运算与进制转换" class="headerlink" title="1.位运算与进制转换"></a>1.位运算与进制转换</h3><h4 id="1-各种进制"><a href="#1-各种进制" class="headerlink" title="1.各种进制"></a>1.各种进制</h4><h5 id="1-其他进制转十进制："><a href="#1-其他进制转十进制：" class="headerlink" title="1.其他进制转十进制："></a>1.其他进制转十进制：</h5><p>对于十六进制来说，每个“个位数”都代表1，每个“十位数”权重是16，每个“百位数”权重是16<sup>2</sup>，每个“千位数”权重是16<sup>3</sup>.</p><p>因此(ABCD)<sub>16</sub>&#x3D;(43981)<sub>10</sub></p><p>10×16<sup>3</sup>+11×16<sup>2</sup>+12×16<sup>1</sup>+13×16<sup>0</sup>&#x3D;43981</p><p>不同进制下基底不同————十六进制的基底是16，十进制的基底是10</p><p>二进制数10101101转换为十进制数：最右边一位代表2<sup>0</sup>&#x3D;1，右边第二位代表2<sup>1</sup>&#x3D;2，第三位代表2<sup>2</sup>&#x3D;4······最左边一位(从右边数第八位)代表2<sup>7</sup>&#x3D;128. 因此将各位代表的数字累加起来，则12<sup>0</sup>+2<sup>2</sup>+2<sup>3</sup>+2<sup>5</sup>+2<sup>7</sup>&#x3D;173.</p><h5 id="2-十进制转其他进制："><a href="#2-十进制转其他进制：" class="headerlink" title="2.十进制转其他进制："></a>2.十进制转其他进制：</h5><p>将十进制的数字每次除以基底，然后分别记录下商和余数，然后继续将商除以基底，以次反复，直到商小于基底为止。从最后一个商开始，从下往上记录每一个得到的数字，就是对应的十六进制数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">114514</span>/<span class="hljs-number">16</span>=<span class="hljs-number">7157</span>······<span class="hljs-number">2</span><br><span class="hljs-number">7157</span>/<span class="hljs-number">16</span>=<span class="hljs-number">447</span>·········<span class="hljs-number">5</span><br><span class="hljs-number">447</span>/<span class="hljs-number">16</span>=<span class="hljs-number">27</span>···········<span class="hljs-number">15</span>(F)<br><span class="hljs-number">27</span>/<span class="hljs-number">16</span>=<span class="hljs-number">1</span>·············<span class="hljs-number">11</span>(B)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>从下往上记录，因此(114514)<sub>10</sub>&#x3D;(1BF52)<sub>16</sub></p><pre><code class="hljs">                                                                        **0~15的十进制、十六进制和二进制的对应关系**</code></pre><table><thead><tr><th align="center">十进制</th><th align="center">十六进制</th><th align="center">二进制</th><th align="center">十进制</th><th align="center">十六进制</th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0000</td><td align="center">8</td><td align="center">8</td><td align="center">1000</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0001</td><td align="center">9</td><td align="center">9</td><td align="center">1001</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">0010</td><td align="center">10</td><td align="center">A</td><td align="center">1010</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">0011</td><td align="center">11</td><td align="center">B</td><td align="center">1011</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">0100</td><td align="center">12</td><td align="center">C</td><td align="center">1100</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">0101</td><td align="center">13</td><td align="center">D</td><td align="center">1101</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">0110</td><td align="center">14</td><td align="center">E</td><td align="center">1110</td></tr><tr><td align="center">7</td><td align="center">7</td><td align="center">0111</td><td align="center">15</td><td align="center">F</td><td align="center">1111</td></tr></tbody></table><p>进制转换：</p><p>将输入的n进制数转换为十进制数，然后在转换为m进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">char_to_int</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span></span>&#123;<span class="hljs-comment">//单个字母转换成数字</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>&lt;=a &amp;&amp; a&lt;=<span class="hljs-string">&#x27;9&#x27;</span>?a-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">10</span>+a-<span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">int_to_char</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<span class="hljs-comment">//数字转换成单个字母</span><br>    <span class="hljs-keyword">return</span> a&lt;=<span class="hljs-number">9</span>? a+<span class="hljs-string">&#x27;0&#x27;</span>:a<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> output[<span class="hljs-number">33</span>];<br>    <span class="hljs-type">int</span> n,m,dec=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;<br>    string input;<br>    cin&gt;&gt;n&gt;&gt;input&gt;&gt;m;<br>    <span class="hljs-comment">//原数转换为十进制</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;input.<span class="hljs-built_in">length</span>();i++)&#123;<br>        dec=dec*n+<span class="hljs-built_in">char_to_int</span>(input[i]);<br>    &#125;<br>    <span class="hljs-comment">//转换为m进制</span><br>    <span class="hljs-keyword">while</span>(dec!=<span class="hljs-number">0</span>)&#123;<br>        output[num++]=dec%m,dec/=m;<br>    &#125;<br>    <span class="hljs-comment">//输出转换好的数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=num<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        cout&lt;&lt;<span class="hljs-built_in">int_to_char</span>(output[i]);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>十六进制数码对应4位数的二进制数码，所以将十六进制和二进制之间相互转换时并不需要以十进制为过渡，直接进行转换即可(注：二进制需要四位四位分组，而且必须从右往左分组)，例如二进制数1010110111经过分组后可以变为001010110111可转换为2B7.</p><h4 id="2-二进制的深入研究"><a href="#2-二进制的深入研究" class="headerlink" title="2.二进制的深入研究"></a>2.二进制的深入研究</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">233</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">-233</span>;<br><span class="hljs-type">float</span> c=<span class="hljs-number">3.14</span>;<br><span class="hljs-type">char</span> d[<span class="hljs-number">4</span>]=<span class="hljs-string">&quot;Ha!&quot;</span>;<br>十六进制数字前常常会加上“<span class="hljs-number">0</span>x<span class="hljs-string">&quot;以作提示。实际上，在计算机内存中变量是这样存储的。</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20220408221702349.png" alt="image-20220408221702349"></p><p>内存非常大，如果希望定位到某个变量，就需要知道这个变量所在的地址。在32位计算机中，地址是32位二进制数，可以缩写为8位十六进制。内存地址是连续的，使用<code>cout&lt;&lt;&amp;a</code>可以输出变量a的地址。一个0或1的数码被称为一位，一个内存地址对应的8位，被称为字节，也就是1B(Byte).</p><p>int类型或float类型占用32位空间。十进制数字233转换为二进制数字为11101001，所以233在低位(右边)填入11101001，高位(左边)用0填充。十进制-233是一个负数，在内存中会表示为1········100010111，高位用1填充。存储浮点数需要将十进制浮点数转换为二进制的浮点数，然后在内存中分别记录符号、指数和有效数字。</p><p>一个char变量占用8位，大小为4的char类型数组占用32位。将这个数组中的每个原数的ASCII码转换为二进制后直接转入内存中，例如’H’的ASCII码值是72，’a’的ASCII码值是97，’!’的ASCII码值是33，字符串最后的’\0’对应的值是0.</p><p>定义一个变量，就会为这个变量准备一块内存空间，并记录这个空间的起始地址。当访问这个变量时，就会根据地址在内存中找到这个变量的值。</p><p>有些变量类型也有无符号数，例如unsigned int类型。这个类型和int类型一样，占用32位。以放弃存储正负号为代价，可以存储比int多一倍的整数值(0到2<sup>32</sup>-1，接近4.3×10<sup>9</sup>).</p><p>计算机中还有其他表示数据大小的单位，比如1KB是2<sup>10</sup>&#x3D;1024字节，1MB是2<sup>20</sup>字节(大约100万字节)，1GB是2<sup>30</sup>字节。但是如果谈论到网络带宽，常常指的是位而不是字节。</p><h6 id="负数转换二进制："><a href="#负数转换二进制：" class="headerlink" title="负数转换二进制："></a>负数转换二进制：</h6><p>在带符号整数signed char的情况下，-56表示成负数的方法</p><p>int类型占有32位，因此使用只占8位的signed char类型。57用二进制表示为0011 1001(补足8位).可以占用最高位的一位来表示正负，0表示非负，1表示负数。</p><ol><li>第一种方式是用除了第一位的数字表示这个负数的绝对值，第一位变成1.这样，-57表示为1011 1001.这种表示方式称为<strong>原码</strong>。但计算机不使用这种方式来表示负数。</li><li>第二种方式是将这个负数的绝对值的数全部取反，由1变为0,0变为1。这样，-57表示为1100 0110。这种方式称为<strong>反码</strong>。使用反码的问题是0会有两种表示方式(全0和全1)，因此不常用。</li><li>第三种方式是先计算这个负数的反码，然后加1.这样-57表示为1100 0111。这是计算机使用的表示负数的方法，被称为<strong>补码</strong>。这种表示方式下0只有1个，全0代表0，全1代表-1。</li></ol><p>使用补码这种表示负数的方式，计算机就可以计算二进制减法了。例如66-57可以认为是66+(-57)。66的二进制是0100 0010，-57的二进制是1100 0111，列竖式累加(异或运算并进位)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0100</span> <span class="hljs-number">0010</span><br>  + <span class="hljs-number">1100</span> <span class="hljs-number">0111</span><br>---------------<br>   <span class="hljs-number">10000</span> <span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure><p>由于这个数字溢出了8位，所以只取低位数的8位，得到答案是0000  1001也就是十进制下的9.补码这种方式可以使计算机化减为加。但是谈论补码时必须要确定总位数，因为char类型的1100 0111和int类型的0···0  1100  0111表示的不是同一个数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">memset给<span class="hljs-type">int</span>数组初始化时，只有填充<span class="hljs-number">0</span>和<span class="hljs-number">1</span>时才能初始化为<span class="hljs-number">0</span>或<span class="hljs-number">-1</span>(给一个其他数字，则不会将数组初始化为这个数字)的原因：<br>memset只能将一片数组区域的每一个字节初始化为给定的数字(小于<span class="hljs-number">255</span>)，而一个<span class="hljs-type">int</span>是由<span class="hljs-number">4</span>字节组成的，所以只能填充成全<span class="hljs-number">0</span>(最后的值还是<span class="hljs-number">0</span>)或者全<span class="hljs-number">1</span>(最后的值是<span class="hljs-number">-1</span>)。如果填充成<span class="hljs-number">3</span>，则这个<span class="hljs-type">int</span>的值实际上就变成了<span class="hljs-number">0x03030303</span>.<br>使用memset初始化<span class="hljs-type">int</span>数组时，第二个参数如果是<span class="hljs-number">0</span>，数组就会被初始化为<span class="hljs-number">0</span>，如果是<span class="hljs-number">127</span>会初始化为一个很大且接近<span class="hljs-type">int</span>类型上限的正数，如果是<span class="hljs-number">128</span>，会初始化成很小且接近<span class="hljs-type">int</span>类型下限的负数，如果是<span class="hljs-number">-1</span>或者<span class="hljs-number">255</span>时，数组会初始化为<span class="hljs-number">-1.</span><br></code></pre></td></tr></table></figure><h6 id="小数转换二进制："><a href="#小数转换二进制：" class="headerlink" title="小数转换二进制："></a>小数转换二进制：</h6><p>3.14转换成二进制，将实数从十进制转换为二进制，可以将整数部分和实数部分分别处理。整数部分的3是二进制的11.</p><p>将原来的小数数字，每次都乘2，如果得到的结果中整数部分是1，则答案记录一个1并去掉这个整数部分，然后继续运算；如果结果中整数部分还是0，那么答案记录一个0，继续计算。因此3.14表示为二进制数就是11.00100011···，在二进制下是一个无限小数，这也是计算机浮点数类型无法精确表示很多实数的原因。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0.14</span>×<span class="hljs-number">2</span>=<span class="hljs-number">0.28</span><br><span class="hljs-number">0.28</span>×<span class="hljs-number">2</span>=<span class="hljs-number">0.56</span><br><span class="hljs-number">0.56</span>×<span class="hljs-number">2</span>=<span class="hljs-number">1.12</span><br><span class="hljs-number">0.12</span>×<span class="hljs-number">2</span>=<span class="hljs-number">0.24</span><br><span class="hljs-number">0.24</span>×<span class="hljs-number">2</span>=<span class="hljs-number">0.48</span><br><span class="hljs-number">0.48</span>×<span class="hljs-number">2</span>=<span class="hljs-number">0.96</span><br><span class="hljs-number">0.96</span>×<span class="hljs-number">2</span>=<span class="hljs-number">1.92</span><br><span class="hljs-number">0.92</span>×<span class="hljs-number">2</span>=<span class="hljs-number">1.84</span><br>依次记录整数数字：<span class="hljs-number">00100011</span>···<br></code></pre></td></tr></table></figure><p>将一个二进制小数转换成十进制。例如101.101，同样将整数部分和小数部分分开，整数部分十进制是5。小数部分的计算方式和整数转换方式差不多：1×2<sup>-1</sup>+0×2<sup>-2</sup>+1×2<sup>-3</sup>&#x3D;0.625，所以二进制下的101.101就是十进制下的5.0625.</p><h4 id="3-逻辑命题与位运算"><a href="#3-逻辑命题与位运算" class="headerlink" title="3.逻辑命题与位运算"></a>3.逻辑命题与位运算</h4><ol><li>或：A∨B：两个命题中至少有一个真命题时，其复合命题为真。</li><li>与：A∧B：两个命题必须全为真命题，其复合命题才是真命题。</li><li>非：¬A：将原命题取反。</li><li>异或：A⊕B：两个命题相同时为假，不同时为真，等价于(A∧¬B)∨(¬A∧B).</li></ol><p>为了简化逻辑表达式，可以将或运算变成加号，与运算变成乘号，非运算变成上划线。<br>$$<br>\neg((A\wedge\neg B)\vee(\neg A\wedge B)可以表示为  \overline{A\overline{B}+\overline{A}B}<br>$$<br>逻辑运算与普通代数运算有类似的性质，而且与运算的优先级高于或运算。</p><p>逻辑运算有以下性质：<br>$$<br>\begin{flalign}<br>&amp; 1)\mathbf{交换律}:AB&#x3D;BA,A+B&#x3D;B+A &amp;<br>\<br>&amp; 2)\mathbf{结合律}:(AB)C&#x3D;A(BC),(A+B)+C&#x3D;A+(B+C)<br>\<br>&amp; 3)\mathbf{分配律}:A(B+C)&#x3D;AB+AC<br>\<br>&amp; 4)A+1&#x3D;1,0A&#x3D;0<br>\<br>&amp; 5)AA&#x3D;A,A+A&#x3D;A,A+\overline{A}&#x3D;1<br>\<br>&amp; 6)\mathbf{德·摩根定律}:\overline{A}+\overline{B}&#x3D;\overline{AB},\overline{A}\cdot\overline{B}&#x3D;\overline{A+B}<br>\end{flalign}<br>$$</p><h6 id="C-位运算："><a href="#C-位运算：" class="headerlink" title="C++位运算："></a>C++位运算：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> A=<span class="hljs-number">85</span>,B=<span class="hljs-number">51</span>;<br><span class="hljs-type">int</span> p,q,r,s,u,v;<br>p=A&amp;B;<br>q=A|b;<br>r=A^B;<br>s=~A;<br>u=A&lt;&lt;<span class="hljs-number">2</span>;<br>v=A&gt;&gt;<span class="hljs-number">3</span>;<br>cout&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v;<br>Output:<br><span class="hljs-number">17</span> <span class="hljs-number">119</span> <span class="hljs-number">102</span> <span class="hljs-number">-86</span> <span class="hljs-number">340</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>&amp;按位与，将前后两个操作数按位对齐，然后每一位上都进行与计算，最后得到位运算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">例如<span class="hljs-number">85</span>的二进制数为<span class="hljs-number">101</span> <span class="hljs-number">0101</span>，<span class="hljs-number">51</span>的二进制数为<span class="hljs-number">11</span> <span class="hljs-number">0011</span>，计算过程如下(<span class="hljs-type">int</span>类型是<span class="hljs-number">32</span>位二进制数)<br>A <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <span class="hljs-number">0101</span><br> &amp;  B <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0011</span> <span class="hljs-number">0011</span><br> ---------------------------------------------<br>    P <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><p>可以发现每一位都进行了与运算，最后结果是1 0001也就是十进制的17.</p><p>|符号是按位或，^符号按位异或。异或运算符的优先级高于按位或运算，低于按位与运算。</p><p>~符号是取反；&lt;&lt;符号是位左移，&gt;&gt;符号是位右移。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">A:<span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <span class="hljs-number">0101</span><br>  ~A:<span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1010</span> <span class="hljs-number">1010</span><br>A&lt;&lt;<span class="hljs-number">2</span>:<span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0101</span> <span class="hljs-number">0100</span><br>A&gt;&gt;<span class="hljs-number">3</span>:<span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1010</span><br></code></pre></td></tr></table></figure><p>取反是将这个数字的二进制数0变1,1变0，根据补码就可以知道转换后的数字。对于带符号整数来说，~A的值和-A-1的值是相同的。</p><p>左移是将这个二进制数的所有位数往左移动指定的位数，右边用0补齐，左边截掉。</p><p>右移是将这个二进制数的所有位数往右移动指定的位数，右边截掉。右移时，如果原数是非负数，则左边补0，否则左边补1。</p><p>因此a&lt;&lt;n&#x3D;a×2<sup>n</sup>，a&gt;&gt;n&#x3D;a&#x2F;2<sup>n</sup>.</p><h3 id="2-计数原理与排列组合"><a href="#2-计数原理与排列组合" class="headerlink" title="2.计数原理与排列组合"></a>2.计数原理与排列组合</h3><h4 id="1-加法原理和乘法原理"><a href="#1-加法原理和乘法原理" class="headerlink" title="1.加法原理和乘法原理"></a>1.加法原理和乘法原理</h4><h4 id="2-排列与组合"><a href="#2-排列与组合" class="headerlink" title="2.排列与组合"></a>2.排列与组合</h4><p>$$<br>\begin{flalign}<br>&amp;从n个人里面选出m个排成一排的方案数是：n(n-1)···(n-m+1)&#x3D;\frac{n!}{(n-m)!}称他为排列数&amp;<br>\<br>&amp;用A_{n}^{m}表示从n个元素里面取m个元素。&amp;<br>\<br>&amp;A_{n}^{m}&#x3D;\frac{n!}{(n-m)!}&amp;<br>\<br>\end{flalign}<br>$$</p><p>$$<br>\begin{flalign}<br>&amp;用C_{n}^{m}表示从n个元素里面取m个元素。称为组合数<br>\<br>&amp;C_{n}^{m}&#x3D;C_{n-1}^{m-1}+C_{n-1}^{m}是组合数的递推公式，称为帕斯卡公式<br>\<br>&amp;C_{n}^{m}&#x3D;\frac{A_{n}^{m}}{A_{m}^{m}}&#x3D;\frac{n\mathbf{\cdot} (n-1)·\cdots·(n-m+1)}{m·(m-1)·\cdots·2·1}&#x3D;\frac{n!}{m!·(n-m)!}&amp;<br>\<br>&amp;C_{n}^{m}&#x3D;C_{n}^{n-m}&amp;<br>\<br>&amp;C_{n}^{0}&#x3D;C_{n}^{n}&#x3D;1&amp;<br>\end{flalign}<br>$$</p><h3 id="3-整除理论"><a href="#3-整除理论" class="headerlink" title="3.整除理论"></a>3.整除理论</h3><h4 id="1-整除的基本知识"><a href="#1-整除的基本知识" class="headerlink" title="1.整除的基本知识"></a>1.整除的基本知识</h4><p>设a,b是两个整数，且a≠0，如果存在另一个整数q，使得b&#x3D;aq，那么就说b可以被a整除，记做a|b，且称b是a的倍数，a是b的约数。</p><p>使用<code>a%b==0</code>来表示b能够整除a</p><p>整除有下面3个常用性质：</p><ol><li>若a|b且b|c，那么a|c</li><li>若a|b且a|c，那么对任意的整数x,y，有a|bx+cy</li><li>设整数m≠0，那么a|b等价于ma|mb</li></ol><p>$$<br>\begin{flalign}<br>&amp;用优化的枚举法寻找n的所有约数，如果k是n的约数，那么\frac{n}{k}也一定是n的约数，只要限定k\le\frac{n}{k}，即k\le \sqrt{n},就可以在O(\sqrt{n})的时间&amp;<br>\&amp;复杂度内找到n的所有因数&amp;<br>\end{flalign}<br>$$</p><h4 id="2-质数与合数"><a href="#2-质数与合数" class="headerlink" title="2.质数与合数"></a>2.质数与合数</h4><p>$$<br>\begin{flalign}<br>&amp;设正整数p≠0,1。如果它除了1和p外没有其他的约数，那么就称p为\mathbf{质数}。&amp;<br>\<br>&amp;若正整数a≠0,1且a不是质数，则称a为合数。&amp;<br>\<br>&amp;每个合数都会有相对较小的质因子&amp;<br>\<br>&amp;推论：若a为合数，则a能被表示成a&#x3D;pq,其中p,q&gt;1。易证p,q中一定有一个不超过\sqrt{a}。&amp;<br>\<br>&amp;更严格地，若a为合数，则一定存在质数p|a，且p\le\sqrt{a}&amp;<br>\end{flalign}<br>$$</p><p>线性筛：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//判断x是否为质数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;<span class="hljs-comment">//i不超过sqrt(x)</span><br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>埃拉托尼斯筛（埃氏筛）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Eratosthenes_Sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">bool</span> a[])</span></span>&#123;<br>    <span class="hljs-comment">//寻找不超过n的所有质数，数组a用来存放结果，用a[i]==1表示a是合数。</span><br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>)*(n+<span class="hljs-number">1</span>));<span class="hljs-comment">//清零</span><br>    a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//0和1需要特殊标记</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果i未被之前的数筛去说明i是质数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i&lt;&lt;<span class="hljs-number">1</span>;j&lt;=n;j+=i)&#123;<br>                a[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//筛去i的所有倍数i*j</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>埃氏筛的时间复杂度是O(nlnlnn)，欧拉筛法时间复杂度是O(n).</p><h4 id="3-最大公约数与最小公倍数"><a href="#3-最大公约数与最小公倍数" class="headerlink" title="3.最大公约数与最小公倍数"></a>3.最大公约数与最小公倍数</h4><p>$$<br>\begin{flalign}<br>&amp;设a_{1},a_{2}是两个整数，如果d|a_{1},d|a_{2},那么d就称为a_{1}和a_{2}的\mathbf{公约数}，其中最大的称为a_{1}和a_{2}的\mathbf{最大公约数}.记作(a_{1}，a_{2}).&amp;<br>\<br>&amp;一般地，可以类似地定义k个整数a_{1},a_{2}\cdots a_{k}的公约数和最大公约数，后者记作(a_{1}，a_{2}\cdots a_{k}).&amp;<br>\<br>&amp;设a_{1},a_{2}是两个整数，如果a_{1}|l,a_{2}|l,那么l就称为a_{1}和a_{2}的\mathbf{公倍数}，其中最小的称为a_{1}和a_{2}的\mathbf{最小公倍数}，记作[a_{1},a_{2}].&amp;<br>\<br>&amp;一般地，可以类似地定义k个整数a_{1},a_{2}\cdots a_{k}的公倍数和最小公倍数，后者记作[a_{1}，a_{2}\cdots a_{k}].&amp;<br>\end{flalign}<br>$$</p><p>$$<br>\begin{flalign}<br>&amp;有关最大公约数和最小公倍数的常见性质与结论:&amp;<br>\<br>&amp;性质1:对任意整数m,m(a_{1},\cdots,a_{k})&#x3D;(ma_{1},\cdots,ma_{k}),即整数同时成倍放大,最大公约数也放大相同倍数.(最小公倍数也适用).<br>\<br>&amp;性质2:对任意整数x,(a_{1},a_{2})&#x3D;(a_{1},a_{2}+a_{1}x),即一个整数加上另一整数的任意倍数，它们的最大公约数不变.(最小公倍数不适用).<br>\<br>&amp;(a,0)&#x3D;a<br>\<br>&amp;性质3:(a_{1},a_{2},a_{3},\cdots,a_{k})&#x3D;((a_{1},a_{2}),a_{3},\cdots,a_{k}),以及一个显然的结论(a_{1},a_{2},a_{3},\cdots,a_{k+r})&#x3D;((a_{1},\cdots,a_{k}),(a_{k+1},\cdots,a_{k+r})).<br>\<br>&amp;性质4:<a href="a_%7B1%7D,a_%7B2%7D">a_{1},a_{2}</a>&#x3D;a_{1}a_{2},最大公约数\times 最小公倍数&#x3D;原来两个数的乘积.<br>\end{flalign}<br>$$</p><p><strong>辗转相除法</strong> <strong>（Euclid算法）</strong>:</p><p>每次让较大的数对较小的数取模，可以缩小问题规模而保持最大公约数不变，然后递归，递归边界时某数变成了0，此时另一个数即为所求答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(y,x%y);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度是O(logmax(x,y))，相近规模下能让辗转相处执行次数最多（最坏情况）的数是相邻的两个斐波那契数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> y?<span class="hljs-built_in">gcd</span>(y,x%y):x;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x/<span class="hljs-built_in">gcd</span>(x,y)*y;&#125;<br></code></pre></td></tr></table></figure><h4 id="4-算术基本定理"><a href="#4-算术基本定理" class="headerlink" title="4.算术基本定理"></a>4.算术基本定理</h4><p>一个整数可以被表示成若干质数的乘积。例如：48&#x3D;2<sup>4</sup>×3，49&#x3D;7<sup>2</sup>，50&#x3D;2×5<sup>2</sup></p><h5 id="1-算术基本定理："><a href="#1-算术基本定理：" class="headerlink" title="1.算术基本定理："></a>1.算术基本定理：</h5><p>$$<br>\begin{flalign}<br>&amp;设a&gt;1,那么必有a&#x3D;p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{s}^{a_{s}},其中p_{j}(1\le j\le s)是两两不相同的质数，a_{j}表示对应质数的幂次(出现的次数).<br>\<br>&amp;若在不计次序的意义下，该分解式是唯一的.<br>\<br>&amp;分解质因数的时间和枚举因数一样是O(\sqrt{n}).&amp;<br>\end{flalign}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Decomposition</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> a[])</span></span>&#123;<br>    <span class="hljs-comment">//分解x，数组a升序记录所有质数，函数值返回分解出来的质数数量</span><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">for</span>(;x%i==<span class="hljs-number">0</span>;x/=i)&#123;<br>            a[++cnt]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>)a[++cnt]=x;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算术基本定理常用推论："><a href="#算术基本定理常用推论：" class="headerlink" title="算术基本定理常用推论："></a>算术基本定理常用推论：</h5><p>$$<br>\begin{flalign}<br>&amp;给定a&#x3D;p_{1}^{\alpha_{1}}p_{2}^{\alpha_{2}}\cdots p_{s}^{\alpha_{s}}&amp;<br>\end{flalign}<br>$$</p><h5 id="推论1："><a href="#推论1：" class="headerlink" title="推论1："></a>推论1：</h5><p>$$<br>\begin{flalign}<br>&amp;d是a的约数的充要条件是d&#x3D;p_{1}^{e_{1}}p_{2}^{e_{2}}\dots p_{s}^{e_{s}},0 \le e_{j} \le \alpha_{j},1\le j\le s,即d中每个质数的幂次都不超过a的.&amp;<br>\<br>&amp;每个质因子上的幂次直接决定了两数之间的整除性&amp;<br>\<br>&amp;例如12&#x3D;2^{2}×3,72&#x3D;2^{3}×3^{2},12的质因子上的每个幂次都比72小,可以在进行取模运算的情况下给出12|72的结论.&amp;<br>\end{flalign}<br>$$</p><h5 id="推论2："><a href="#推论2：" class="headerlink" title="推论2："></a>推论2：</h5><p>$$<br>\begin{flalign}<br>&amp;若b&#x3D;p_{1}^{\beta_{1}}p_{2}^{\beta_{2}} \cdots p_{s}^{\beta_{s}}(允许某些\alpha_{j}或 \beta_{j}为零)<br>\<br>&amp;那么(a,b)&#x3D;p_{1}^{\delta_{1}}p_{2}^{\delta_{2}} \cdots p_{s}^{\delta <em>{s}},\delta</em>{j}&#x3D;min(\alpha_{j},\beta_{j}),1\le j\le s<br>\<br>&amp;以及[a,b]&#x3D;p_{1}^{\gamma_{1}}p_{2}^{\gamma_{2}} \cdots p_{s}^{\gamma_{s}},\gamma_{j}&#x3D;max(\alpha_{j},\beta_{j}),1\le j\le s&amp;<br>\<br>&amp;例如10&#x3D;2×5,16&#x3D;2^{4},那么(10,16)&#x3D;2^{min(1,4)}×5^{min(1,0)}&#x3D;2^{1}×5^{0}&#x3D;2,且[10,16]&#x3D;2^{max(1,4)}×5^{max(1,0)}&#x3D;2^{4}×5^{1}&#x3D;80.&amp;<br>\<br>&amp;可以直接证明(a_{1},a_{2})×[a_{1},a_{2}]&#x3D;a_{1}a_{2}.&amp;<br>\<br>&amp;所以<a href="a_%7B1%7D,a_%7B2%7D">a_{1},a_{2}</a>&#x3D;a_{1}a_{2}的本质其实是min(\alpha,\beta)+max(\alpha,\beta)&#x3D;\alpha+\beta.&amp;<br>\end{flalign}<br>$$</p><h5 id="推论3："><a href="#推论3：" class="headerlink" title="推论3："></a>推论3：</h5><p>$$<br>\begin{flalign}<br>&amp;用\mathbf{除数函数}\tau(a)表示a的所有正约数的个数，则\tau(a)&#x3D;(\alpha_{1}+1)\cdots (\alpha_{s}+1)&#x3D;\tau(p_{1}^{\alpha_{1}})\cdots \tau(p_{1}^{\alpha_{s}}). &amp;<br>\<br>&amp;对于每个质因子上的幂次,可以取0到\alpha_{i}中的任意整数，共\alpha_{i}+1个.&amp;<br>\<br>&amp;例如,a&#x3D;2^{7}×3^{8}×5^{9},a的质因子个数&#x3D;(7+1)(8+1)(9+1)&#x3D;720.&amp;<br>\end{flalign}<br>$$</p><h5 id="推论4："><a href="#推论4：" class="headerlink" title="推论4："></a>推论4：</h5><p>$$<br>\begin{flalign}<br>&amp;用\mathbf{除数和函数}\sigma(a)表示a的所有正约数的和，则\sigma(a)&#x3D;\frac{p_{1}^{a_{1}+1}-1}{p_{1}-1}\cdots\frac{p_{s}^{a_{s}+1}-1}{p_{s}-1}&#x3D;\sigma(p_{1}^{a_{1}})\cdots\sigma(p_{s}^{a_{s}}).&amp;<br>\end{flalign}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.语言入门</title>
    <link href="/2022/03/21/1-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/21/1-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="语言入门"><a href="#语言入门" class="headerlink" title="语言入门"></a>语言入门</h1><h4 id="1-浮点数"><a href="#1-浮点数" class="headerlink" title="1.浮点数"></a>1.浮点数</h4><p>$$<br>1.6666e6&#x3D;1.6666*10^6<br>$$</p><p>$$<br>1.6666e-6&#x3D;1.6666*10^{-6}<br>$$</p><h4 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h4><p><code>#include&lt;cmath&gt;</code></p><p><code>pow()</code></p><p><code>sqrt()</code></p><p>abs()求整数的绝对值，fabs()求实数的绝对值<br>$$<br>&amp;pow(x,y)&#x3D;x^y<br>\<br>&amp;sqrt(x)&#x3D;\sqrt{x}(double类型)<br>\<br>&amp;exp(x)&#x3D;e^x<br>\<br>&amp;fabs(x)&#x3D;\left| x \right|<br>\<br>&amp;ceil(x)&#x3D;\lceil x \rceil<br>\<br>&amp;floor(x)&#x3D;\lfloor x \rfloor<br>$$</p><p><img src="C:\Users\Harrison\AppData\Roaming\Typora\typora-user-images\image-20211219020318341.png" alt="image-20211219020318341"></p><h4 id="3-定义常量"><a href="#3-定义常量" class="headerlink" title="3.定义常量"></a>3.定义常量</h4><p><font size=5><code>const double 变量名</code></font></p><h4 id="4-头文件"><a href="#4-头文件" class="headerlink" title="4.头文件"></a>4.头文件</h4><p><font size=5> <code>&lt;iomanip&gt;</code></font></p><p><font size=5> <code>setw()</code><strong>当后面紧跟着的输出字段长度小于 n 的时候，在该字段前面用空格补齐，当输出字段长度大于 n 时，全部整体输出。</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 开头设置宽度为 4，后面的 runoob 字符长度大于 4，所以不起作用</span><br>    cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 中间位置设置宽度为 4，后面的 runoob 字符长度大于 4，所以不起作用</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 开头设置间距为 14，后面 runoob 字符数为6，前面补充 8 个空格</span><br>    cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 中间位置设置间距为 14 ，后面 runoob 字符数为6，前面补充 8 个空格</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; <span class="hljs-string">&quot;runoob&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>out<br>runoob<br>runoobrunoob<br>        runoob<br>runoob        runoob<br></code></pre></td></tr></table></figure><p><font size=5> <code>setfill(x)</code>用x填充<code>set(w)</code></font></p><p><a href="%5B(4%E6%9D%A1%E6%B6%88%E6%81%AF">fixed的用法</a> 详解C++中fixed，setprecision(),setw()的用法_xian__xian的博客-CSDN博客_c++ fixed](<a href="https://blog.csdn.net/xian__xian/article/details/114017770">https://blog.csdn.net/xian__xian/article/details/114017770</a>))</p><p>cout.setf(ios::fixed);</p><p>cout.unsetf(ios::fixed);</p><p>关闭同步流加快cin</p><p>ios::sync_with_stdio(false);</p><p>fixed单独使用是控制小数点后输出6位</p><p>setprecision控制有效数字位数</p><p><code>cout&lt;&lt;fixed&lt;&lt;setprecision(x)</code>输出x位数字</p><p>fixed是输出格式流用&#96;cout.unsetf(ios::fixed)消除</p><h4 id="4-随机数算法"><a href="#4-随机数算法" class="headerlink" title="4.随机数算法"></a>4.随机数算法</h4><p><strong>rand函数需使用<code>&lt;stdlib.h&gt;</code>\<code>&lt;cstdlib&gt;</code>头文件</strong></p><p>rand(),srand();</p><p>可以用 rand()%a 来产生一个 0 到 a-1 的随机数。如果想产生一个 a 到 b 的随机数可以使用 rand()%(b-a+1)+a。</p><p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a （结果值含a不含b）。<br>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a （结果值含a和b）。<br>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1 （结果值不含a含b）。</p><p>srand()一定要放在循环外面或者是循环调用的外面，否则的话得到的是相同的随机数。</p><p>srand(time(0));</p><p>srand((unsigned)time(NULL)); &#x2F;&#x2F;需要用<code>&lt;time.h&gt;</code>头文件</p><p>要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;</p><p>要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;</p><p>要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;</p><p><strong>通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。</strong></p><p>要取得 a 到 b 之间的随机整数，另一种表示：DD。</p><p>要取得 0～1 之间的浮点数，可以使用 rand() &#x2F; double(RAND_MAX)。</p><p>abs在C中是<code>&lt;stdlib.h&gt;</code>头文件，C++中用<code>&lt;cmath&gt;</code>头文件</p><h4 id="5-输入输出字符串"><a href="#5-输入输出字符串" class="headerlink" title="5.输入输出字符串"></a>5.输入输出字符串</h4><p><code>puts()  gets()</code></p><p><code>getchar() putchar()</code></p><p><code>scanf()  printf()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-built_in">puts</span>(str)==<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);<span class="hljs-comment">//puts自带换行符</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//直接输出字符串</span><br>    <span class="hljs-type">char</span>=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-type">char</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;<span class="hljs-type">char</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,string);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,string);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-type">char</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getchar()putchar()</code>输入输出单个字符char;</p><p><code>gets()puts()</code>输入输出字符串string（gets()易导致字符数组越界不常用）;</p><p><code>scanf()printf()</code>中%c输入输出char,%s输入输出string;</p><h4 id="6-字符串函数"><a href="#6-字符串函数" class="headerlink" title="6.字符串函数"></a>6.字符串函数</h4><p>头文件<code>&lt;ctring&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">1000</span>],b[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">strlen</span>(a);<span class="hljs-comment">//查询字符串长度</span><br>    <span class="hljs-built_in">strcpy</span>(a,<span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(a,b);<br>    strcmp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toupper()</code>将小写字母转换为大写字母</p><p><code>tolower()</code>将大写字母转换为小写字母</p><h4 id="7-输入输出"><a href="#7-输入输出" class="headerlink" title="7.输入输出"></a>7.输入输出</h4><p><code>fgets(string,sizeof(string),stdin);</code>&#x2F;&#x2F;从输入流<code>stdin</code>即输入缓冲区中读取<code>sizeof(string)</code>个字符到字符数组<code>string</code>中</p><p><strong>注：fgets是从输入缓冲区中读取字符，若上一次输入有换行符，需先用getchar()清空缓冲区或使用<code>scanf(&quot;%d\n&quot;,&amp;int);</code>用’\n’清空缓冲区</strong></p><p><code>fgets()</code>同样自带换行符</p><p><code>gets</code>易导致数组越界,<code>fgets</code>可以指定最大读入数量，防止溢出;</p><p><code>fgets()</code>中n未输入满时，若其余位置有初始值，则不变，否则为’\0’;输入多余n个字符时，其余字符仍在输入缓冲区，下次输入前需用<code>getchar()</code>清空输入缓冲区;</p><p><code>sscanf(s,&quot;%d&quot;,&amp;a)</code>从s字符串中读入整数a</p><p><code>sprintf(s,&quot;%d&quot;,a)</code>把int类型的a输出到字符串s中</p><h4 id="8-cstring和string头文件的区别"><a href="#8-cstring和string头文件的区别" class="headerlink" title="8.cstring和string头文件的区别"></a>8.cstring和string头文件的区别</h4><p><code>&lt;string.h&gt;</code>是c中字符串头文件</p><p><code>&lt;string&gt;</code>是C++中字符串的STL模板</p><p><code>&lt;cstring&gt;</code>C++中字符串</p><h4 id="9-输入输出的返回值"><a href="#9-输入输出的返回值" class="headerlink" title="9.输入输出的返回值"></a>9.输入输出的返回值</h4><ol><li><code>scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s</code>返回值为成功赋值的接收参数的数量，结束时返回EOF，未读取到时返回0;</li><li><code>cin</code>为对象，返回值为<code>cin</code>本身，当输入EOF时，返回值为0：</li></ol><p><code>getchar, putchar</code>成功时为获得的字符，失败时为 EOF 。</p><p><code>gets</code>成功时为 str（char*） ，失败时为 NULL 。</p><p><code>puts</code>成功时返回非负值</p><h4 id="9-字符串函数"><a href="#9-字符串函数" class="headerlink" title="9.字符串函数"></a>9.字符串函数</h4><p><code>strcat(str,string)</code>在str后面接上string</p><h4 id="10-文件操作与重定向"><a href="#10-文件操作与重定向" class="headerlink" title="10.文件操作与重定向"></a>10.文件操作与重定向</h4><h5 id="头文件-include-lt-cstdio-gt"><a href="#头文件-include-lt-cstdio-gt" class="headerlink" title="头文件#include&lt;cstdio&gt;"></a>头文件<code>#include&lt;cstdio&gt;</code></h5><p><code>freopen(&quot;program.in&quot;,&quot;r&quot;,stdin)</code></p><p><code>freopen(&quot;program.out&quot;,&quot;w&quot;,stdout)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ONLINE_JUDGE<span class="hljs-comment">//防止OJ运行重定向操作</span></span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;tilte.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;tilte.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ......</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="11-函数"><a href="#11-函数" class="headerlink" title="11.函数"></a>11.函数</h4><p><code>scanf(&quot;%s,&amp;a&quot;)</code></p><p><code>scanf(&quot;%s,a&quot;)</code></p><p>字符串数组名代表该字符串数组的起始地址</p><p>a为字符串数组时，&amp;a和a(数组名)同为数组的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;s[i]);<span class="hljs-comment">//输入一个字符</span><br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<span class="hljs-comment">//输入一串字符串，s作为字符数组时&amp;s与数组名s同为s的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于字符串数组或字符串指针变量，由于数组名可以转换为数组和指针变量名本身就是地址，因此使用scanf()函数时，不需要在它们前面加上”&amp;”操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(a,b)</span><span class="hljs-comment">//只会交换形参，不会改变实参</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(&amp;a,&amp;b)</span><span class="hljs-comment">//&amp;用来传参，改变a,b地址存放的实际参数</span></span><br></code></pre></td></tr></table></figure><p><code>string s</code>中string将字符数组封装成为一个整体，本质仍是字符数组，因此s的变量名即为地址。将字符串s复制进函数成为一个新的字符串，函数中的操作针对新字符串改变，原字符串仍不变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> s[<span class="hljs-number">25</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> m)</span></span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">stat</span>(s,m);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>int a[]指int类型的数组名，传递数组名即传递数组在内存中的地址</p><p><strong>总结：除string外的数组，在函数中传递数组名即为传递地址，可以改变数组中的内容，string作为字符串数组时，不可以改变数组中的内容</strong></p><h4 id="12-结构体"><a href="#12-结构体" class="headerlink" title="12.结构体"></a>12.结构体</h4><p><code>i&lt;&lt;n</code>表示i*(2^n)<br>$$<br>i&lt;&lt;n&#x3D;i*2^n<br>i&gt;&gt;n&#x3D;i&#x2F;2^n<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    string name;<br>    <span class="hljs-type">int</span> chinese;<br>&#125;a,ans;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    ......<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> a;<span class="hljs-comment">//struct可省略</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;a.chinese;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立结构体时可以在结构体中定义和结构体名称相同的构造函数，例如下程序中的student结构体和student函数，函数不必加上返回值对结构体进行初始化时直接调用构造函数进行初始化。</p><p>还可以在结构体中定义成员函数，用于处理结构体对象的内部变量，构造函数是一种特殊的成员函数，在结构体内部访问自己对象结构体的成员变量或成员函数时，在对应的变量名或函数名前需要加上<code>this-&gt;</code>，如果不产生歧义，可以不加。</p><p>在结构体外调用结构体成员函数时，需要<code>结构体变量名.成员变量名</code>即可，例如<code>one_student.sum()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> academic,quality;<br>    <span class="hljs-type">double</span> overall;<br>    <span class="hljs-built_in">student</span>(<span class="hljs-type">int</span> _id,<span class="hljs-type">int</span> _ac,<span class="hljs-type">int</span> _qu)&#123;<span class="hljs-comment">//初始化构造函数</span><br>        <span class="hljs-keyword">this</span>-&gt;id=_id;<br>        <span class="hljs-keyword">this</span>-&gt;ac=_ac;<br>        <span class="hljs-keyword">this</span>-&gt;qu=_qu;<br>        <span class="hljs-keyword">this</span>-&gt;overall=<span class="hljs-number">0.7</span>*_ac+<span class="hljs-number">0.3</span>*_qu;<br>    &#125;<br>    <span class="hljs-built_in">student</span>()&#123;&#125;<span class="hljs-comment">//定义一个空参数的函数，没有传递参数的初始化构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//成员函数</span><br>        <span class="hljs-keyword">return</span> academic+quality;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_excellent</span><span class="hljs-params">(student s)</span></span>&#123;<span class="hljs-comment">//访问成员变量s.oveall与调用成员函数s.sum()</span><br>    <span class="hljs-keyword">return</span> s.overall&gt;=<span class="hljs-number">80</span> &amp;&amp; s.<span class="hljs-built_in">sum</span>()&gt;<span class="hljs-number">140</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> tmp_id,tmp_ac,tmp_qu;<br>        cin&gt;&gt;tmp_id&gt;&gt;tmp_ac&gt;&gt;tmp_qu;<br>        <span class="hljs-function">student <span class="hljs-title">one_student</span><span class="hljs-params">(tmp_td,tmp_ac,tmp_qu)</span></span>;<span class="hljs-comment">//结构体初始化</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_excellent</span>(one_student))&#123;<span class="hljs-comment">//结构体变量作为参数传递</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;Excellent&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;“No Excellent<span class="hljs-string">&quot;&lt;&lt;endl;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>结构体对象可以像单个变量一样，作为参数直接进入函数，而不是和数组一样只能传入地址，在函数中修改结构体对象中的成员变量时，不会影响到函数外面，除非加上&amp;传参。</p><p>**总结：除string外的数组，在函数中传递数组名即为传递地址，可以改变数组中的内容，string作为字符串数组时，不可以改变数组中的内容，在函数中改变成员变量时，不会影响函数外成员变量。 **</p><p>函数中改变除string外的数组会影响函数外的值，改变变量、string数组或成员变量时不会影响函数外的值.</p><h4 id="13-补充"><a href="#13-补充" class="headerlink" title="13.补充"></a>13.补充</h4><ol><li><p>短路判断：计算表达式时，如果只计算部分内容就可以确保一个表达式的结果，那么剩余部分计算机就不会继续运算下去了。</p></li><li><p>三目运算符的形式是 S1?S2:S3 如果 S1 条件成立，那么这个表达式的值是 S2，否则是 S3。</p></li><li><p>我们还可以使用 memset 函数来实现（需要 cstring 头文件）</p><p>int a[10010]&#x3D;{0}; &#x2F;&#x2F; 这表示 a 数组中的所有变量初始化为 0。 </p><p>memset(数组名称,0,sizeof(数组名称));</p></li><li><p>scanf或cin读入字符串,只能读入到空格 或者换行符为止</p><p>使用 getchar() 函数获取输入数据中一个字符 使用 putchar() 函数则是输出一个字符。</p></li><li><p>cstring函数</p><table><thead><tr><th>cstring头文件</th><th>用法</th></tr></thead><tbody><tr><td>strlen(s)</td><td>获得字符数组的长度，数到 ’\0’</td></tr><tr><td>strcpy(a,b)</td><td>将 b 字符数组的数据复制到 a</td></tr><tr><td>strcmp(a,b)</td><td>比较两个字符串，a&gt;b 则返回 1</td></tr><tr><td>char a[100]；strcpy(a, “hello”);</td><td>给字符数组赋值常量</td></tr></tbody></table></li><li><p>不能直接给字符数组赋值，除非在定义时初始化。char a[100]&#x3D;”Luogu!”</p><p>从输入中读入完整一行（含空格）可这么写。fgets(s, sizeof(s), stdin);</p></li><li><p>字符串string头文件的STL</p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>string s</td><td>定义一个名字为 s 的字符串变量</td></tr><tr><td>s+&#x3D;str 或 s.append(str)</td><td>在字符串 s 后面拼接字符串 str</td></tr><tr><td>s&lt;str</td><td>比较字符串 s 的是否在字符串 str 的字典序之前</td></tr><tr><td>s.size() 或 s.length()</td><td>得到字符串 s 的长度</td></tr><tr><td>s.substr(pos,len)</td><td>截取字符串 s，从第 pos 个位置开始 len 个字符， 并返回这个字符串</td></tr><tr><td>s.insert(pos, str)</td><td>字符串 s 的第 pos 个字符之前，插入字符串 str， 并返回这个字符串</td></tr><tr><td>s.find(str, [pos])</td><td>字符串 s 中从第 pos 个字符开始寻找 str，并返回位置，如 果找不到返回 string::npos(将其强制转换为 int 类型后才是 -1)。pos 可以省略，默认值是 0</td></tr></tbody></table></li><li><p>字符数组和字符串的异同</p><p>字符数组：C 语言就存在，比较原始； </p><p>string：在 C++ 中可以使用字符数组的“进化版本” </p><p>string 的变量名在很多情况下可当做字符数组的变量名，用于 sscanf、sprintf 等地方。</p><p>string 和字符数组也是可以相互转换的，见下方例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// string转字符数组</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br>string s = <span class="hljs-string">&quot;LUOGU&quot;</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">copy</span>(arr, <span class="hljs-number">9</span>);<br><span class="hljs-comment">// 最多允许复制9个字符，否则就越界了</span><br>arr[len] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 在末尾增加结束标记</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br>string s = <span class="hljs-string">&quot;LUOGU&quot;</span>;<br><span class="hljs-built_in">strcpy</span>(arr, s.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-comment">// strncpy(arr, s.c_str(), 10);</span><br><span class="hljs-comment">// 字符数组转string就更简单了</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">strcpy</span>(arr, <span class="hljs-string">&quot;LUOGU&quot;</span>);<br>string s;<br>s = arr;<br></code></pre></td></tr></table></figure><p>提示：读入一整行的 string 字符串 getline(cin, 字符串名称)</p></li><li><p><strong>0和1都不是质数</strong></p></li><li><p>在参数的变量名前面加上一个 &amp; 符号，代表引用传参。</p><p>告知 swap 函数 a 和 b 的地址，故 x 是 a 别名，y 是 b 的别名，修</p><p>改 x 和 y 的值，就会影响到 a 和 b。</p></li><li></li></ol><h4 id="14-总结"><a href="#14-总结" class="headerlink" title="14.总结"></a>14.总结</h4><ol><li><p>程序设计流程 分析问题 建立模型 编写程序 调试与测试 </p><p>程序基本框架 头文件 名字空间 主函数 输出语句 返回值 </p><p>加减乘除的运算 运算优先级 </p><p>整数与浮点数 使用数学函数<code>&lt;cmath&gt;</code></p><p>变量：用于存放数据的容器。有不同的类型，值可以变化。可以当做表达式的一部分参与计算。变量的命名有讲究 </p><p>常量：用于表达固定的常数。 可以使用变量分步骤完成比较复杂的计算。</p></li><li><p>double：用于存放小数的变量类型。 </p><p>char：用于存放字符的变量类型。ASCII将每个字母和数字对应。</p><p>cin&gt;&gt;a：用于读入输入的信息给表示变量 a。</p><p> 一道题目如果按照题意不好解决，不妨想想能不能换一种数据处 理的方式，比如把数字当成字符。</p><p>占位符：scanf&#x2F;printf 用于来格式化输入输出。需要牢记几个重要占位符，并区分。</p><p>算法竞赛基本格式： 每个题目都有固定的输入输出格式，需要认真阅读。 </p><p>数据类型强制转换： 将其他类型的数据类型转换为需要的数据类型。 </p><p>常见评测状态： 是对选手作答结果的反馈。 可以根据反馈的结果对代码进行修改。</p></li><li><p>if 语句、if-else 语句 如果给定的表达式为真，那么执行指定语句 否则（else）执行另外的语句 </p><p>switch-case 分支语句 判断某个表达式的值在几个常量的值 每个分支要加 break 退出，default 其余情况 </p><p>条件语句嵌套 可以多个 else 多个分支，或者分支中还有分支 注意复杂的分支语句，以及大括号的用法 </p><p>缩进、逗号表达式、注释、问号表达式 让编程更容易的一些窍门</p><p>关系表达式：真（1）假（0） 大于小于等于不等于，注意优先级 </p><p>逻辑表达式 </p><p>与（&amp;&amp;）：同时为真则为真 </p><p>或（||） ：至少有一个为真则为真 </p><p>异或（^） ：刚好有一个为真则为真 </p><p>非（!） ：颠倒黑白 </p><p>浮点数精度误差、短路判断</p></li><li><p>for 循环 for 循环格式 &#x2F; 常用于有固定次数的循环 </p><p>while 循环 循环体运行前验证循环成立条件 </p><p>do-while 语句 循环体运行结束后再验证循环成立条件 i++ 和 ++i 是有区别的 </p><p>随机数 随机生成一个范围的随机数 生成随机数前加上srand(time(0))</p><p>数字按位拆分 n % 10 得到 n 的最后一位（即个位） n &#x2F; 10 删去 n 的最后一位 </p><p>多重循环 将任务分解为多个需要循环的子任务 每个子任务中又需要进行循环 </p><p>计算机运行时间 计算机很快，但也有极限，超过一亿次循环很难一秒钟跑完 </p><p>判断质数 i 从 2 枚举到 √n 判断是否能整除 n </p><p>break 和 continue 跳出这个循环，以及直接开始下一轮循环</p></li><li><p>数组 数组是多个变量的集合 定义方式：数据类型 数组变量名称[元素个数]； 数组定义时应略微定义大一些，例如 int a[1010] 可以用 a[50]，a[i] 这种形式访问一个值 </p><p>数组初始化 可用循环依次赋值，也可用memset或定义时初始化 注意初始化所花费的时间 不同题目初始化的值应分别考虑</p><p>数组下标的应用 查找数组中的指定元素 在数组中插入&#x2F;删除一个元素 </p><p>多维数组 可定义多维数组，变成一个矩阵，例如 int a[105][105] 数组通常与循环结构共同使用 </p><p>一些数组的比较复杂的应用:数组的坐标表示：(x,y) 坐标系统，往下 x 变大，往右 y 变大 </p><p>桶计数，设置数组，用于统计每个元素的数量</p></li><li><p>字符数组 就是数组中存储字符的数组，知道如何输入输出 对数组中的字符进行处理、修改 </p><p>STL 中的字符串 string STL 提供了很多封装好的工具可以使用 功能强大，使字符串处理的问题简单很多 </p><p>文件输入输出 在一些竞赛中必须使用文件输入输出 相比于标准输入输出，在本地调试可能更省时间</p></li><li><p>定义子程序：可以定义函数并且调用它，参数有实际参数和形式参数，可以将大程序拆成几个小的部分</p><p>变量作用域与参数传递：局部变量和全局变量，以及引用传参</p><p>递归函数：自己调用自己。可以将大问题分解成形式一样的小问题</p><p>结构体的使用：结构体可以集合不同数据类型为独立结构，也可以批量存储和作为函数的参数或者返回值</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJTU</title>
    <link href="/2021/09/01/BJTU/"/>
    <url>/2021/09/01/BJTU/</url>
    
    <content type="html"><![CDATA[<p>千万别来北京交通大学！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>School life</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
